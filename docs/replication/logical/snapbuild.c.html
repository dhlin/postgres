<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/snapbuild.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/snapbuild.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L283">ExportInProgress</a></li>
<li><a href="#L282">SavedResourceOwnerDuringExport</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L152">SnapBuild</a></li>
<li><a href="#L1556">SnapBuildOnDisk</a></li>
<li><a href="#L1575">SnapBuildOnDisk</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L316">AllocateSnapshotBuilder</a></li>
<li><a href="#L2054">CheckPointSnapBuild</a></li>
<li><a href="#L362">FreeSnapshotBuilder</a></li>
<li><a href="#L913">SnapBuildAddCommittedTxn</a></li>
<li><a href="#L489">SnapBuildBuildSnapshot</a></li>
<li><a href="#L729">SnapBuildClearExportedSnapshot</a></li>
<li><a href="#L1024">SnapBuildCommitTxn</a></li>
<li><a href="#L406">SnapBuildCurrentState</a></li>
<li><a href="#L860">SnapBuildDistributeNewCatalogSnapshot</a></li>
<li><a href="#L668">SnapBuildExportSnapshot</a></li>
<li><a href="#L1319">SnapBuildFindSnapshot</a></li>
<li><a href="#L381">SnapBuildFreeSnapshot</a></li>
<li><a href="#L708">SnapBuildGetOrBuildSnapshot</a></li>
<li><a href="#L415">SnapBuildGetTwoPhaseAt</a></li>
<li><a href="#L569">SnapBuildInitialSnapshot</a></li>
<li><a href="#L768">SnapBuildProcessChange</a></li>
<li><a href="#L818">SnapBuildProcessNewCid</a></li>
<li><a href="#L1217">SnapBuildProcessRunningXacts</a></li>
<li><a href="#L947">SnapBuildPurgeOlderTxn</a></li>
<li><a href="#L756">SnapBuildResetExportedSnapshotState</a></li>
<li><a href="#L1845">SnapBuildRestore</a></li>
<li><a href="#L2017">SnapBuildRestoreContents</a></li>
<li><a href="#L1592">SnapBuildSerializationPoint</a></li>
<li><a href="#L1605">SnapBuildSerialize</a></li>
<li><a href="#L424">SnapBuildSetTwoPhaseAt</a></li>
<li><a href="#L457">SnapBuildSnapDecRefcount</a></li>
<li><a href="#L445">SnapBuildSnapIncRefcount</a></li>
<li><a href="#L2142">SnapBuildSnapshotExists</a></li>
<li><a href="#L1509">SnapBuildWaitSnapshot</a></li>
<li><a href="#L433">SnapBuildXactNeedsSkip</a></li>
<li><a href="#L1187">SnapBuildXidHasCatalogChanges</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1582">SNAPBUILD_MAGIC</a></li>
<li><a href="#L1583">SNAPBUILD_VERSION</a></li>
<li><a href="#L1577">SnapBuildOnDiskConstantSize</a></li>
<li><a href="#L1579">SnapBuildOnDiskNotChecksummedSize</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * snapbuild.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Infrastructure for building historic catalog snapshots based on contents<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of the WAL, for the purpose of decoding heapam.c style <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We build snapshots which can *only* be used to read catalog contents and we<br/></li>
<li></span><span class="Comment"> * do so by reading and interpreting the WAL stream. The aim is to build a<br/></li>
<li></span><span class="Comment"> * snapshot that behaves the same as a freshly taken MVCC snapshot would have<br/></li>
<li></span><span class="Comment"> * at the time the XLogRecord was generated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To build the snapshots we reuse the infrastructure built for Hot<br/></li>
<li></span><span class="Comment"> * Standby. The in-memory snapshots we build look different than HS' because<br/></li>
<li></span><span class="Comment"> * we have different needs. To successfully decode data from the WAL we only<br/></li>
<li></span><span class="Comment"> * need to access catalog tables and (sys|rel|cat)cache, not the actual user<br/></li>
<li></span><span class="Comment"> * tables since the data we decode is wholly contained in the WAL<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. Also, our snapshots need to be different in comparison to normal<br/></li>
<li></span><span class="Comment"> * MVCC ones because in contrast to those we cannot fully rely on the clog and<br/></li>
<li></span><span class="Comment"> * pg_subtrans for information about committed transactions because they might<br/></li>
<li></span><span class="Comment"> * commit in the future from the POV of the WAL entry we're currently<br/></li>
<li></span><span class="Comment"> * decoding. This definition has the advantage that we only need to prevent<br/></li>
<li></span><span class="Comment"> * removal of catalog rows, while normal table's rows can still be<br/></li>
<li></span><span class="Comment"> * removed. This is achieved by using the replication slot mechanism.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As the percentage of transactions modifying the catalog normally is fairly<br/></li>
<li></span><span class="Comment"> * small in comparisons to ones only manipulating user data, we keep track of<br/></li>
<li></span><span class="Comment"> * the committed catalog modifying ones inside [xmin, xmax) instead of keeping<br/></li>
<li></span><span class="Comment"> * track of all running transactions like it's done in a normal snapshot. Note<br/></li>
<li></span><span class="Comment"> * that we're generally only looking at transactions that have acquired an<br/></li>
<li></span><span class="Comment"> * xid. That is we keep a list of transactions between snapshot-&gt;(xmin, xmax)<br/></li>
<li></span><span class="Comment"> * that we consider committed, everything else is considered aborted/in<br/></li>
<li></span><span class="Comment"> * progress. That also allows us not to care about subtransactions <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they<br/></li>
<li></span><span class="Comment"> * have committed which means this module, in contrast to HS, doesn't have to<br/></li>
<li></span><span class="Comment"> * care about suboverflowed subtransactions and similar.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One complexity of doing this is that to e.g. handle mixed DDL/DML<br/></li>
<li></span><span class="Comment"> * transactions we need Snapshots that see intermediate versions of the<br/></li>
<li></span><span class="Comment"> * catalog in a transaction. During normal operation this is achieved by using<br/></li>
<li></span><span class="Comment"> * CommandIds/cmin/cmax. The problem with that however is that for space<br/></li>
<li></span><span class="Comment"> * efficiency reasons, the cmin and cmax are not included in WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. We<br/></li>
<li></span><span class="Comment"> * cannot read the cmin/cmax from the tuple itself, either, because it is<br/></li>
<li></span><span class="Comment"> * reset on crash recovery. Even if we could, we could not decode combocids<br/></li>
<li></span><span class="Comment"> * which are only tracked in the original backend's memory. To work around<br/></li>
<li></span><span class="Comment"> * that, heapam writes an extra WAL record (XLOG_HEAP2_NEW_CID) every time a<br/></li>
<li></span><span class="Comment"> * catalog row is modified, which includes the cmin and cmax of the<br/></li>
<li></span><span class="Comment"> * tuple. During decoding, we insert the ctid-&gt;(cmin,cmax) mappings into the<br/></li>
<li></span><span class="Comment"> * reorder buffer, and use them at visibility checks instead of the cmin/cmax<br/></li>
<li></span><span class="Comment"> * on the tuple itself. Check the reorderbuffer.c's comment above<br/></li>
<li></span><span class="Comment"> * <a href="reorderbuffer.c.html#L5245" title="replication/logical/reorderbuffer.c:5245">ResolveCminCmaxDuringDecoding</a>() for details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To facilitate all this we need our own visibility routine, as the normal<br/></li>
<li></span><span class="Comment"> * ones are optimized for different usecases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To replace the normal catalog snapshots with decoding ones use the<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/time/snapmgr.c.html#L1649" title="utils/time/snapmgr.c:1649">SetupHistoricSnapshot</a>() and <a href="../../utils/time/snapmgr.c.html#L1665" title="utils/time/snapmgr.c:1665">TeardownHistoricSnapshot</a>() <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The snapbuild machinery is starting up in several stages, as illustrated<br/></li>
<li></span><span class="Comment"> * by the following graph describing the <a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>-&gt;state transitions:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; +-------------------------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; +----|&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; START&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |-------------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; +-------------------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running_xacts #1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; +-------------------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; |&nbsp;&nbsp; BUILDING_SNAPSHOT&nbsp; &nbsp;&nbsp; |------------&gt;|<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; +-------------------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; | running_xacts #2, xacts from #1 finished&nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; +-------------------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; |&nbsp; &nbsp; &nbsp;&nbsp; FULL_SNAPSHOT&nbsp; &nbsp;&nbsp; |------------&gt;|<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; +-------------------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> * running_xacts&nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; saved snapshot<br/></li>
<li></span><span class="Comment"> * with zero xacts&nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at running_xacts's lsn<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; | running_xacts with xacts from #2 finished&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; +-------------------------+&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; +---&gt;|SNAPBUILD_CONSISTENT&nbsp; &nbsp;&nbsp; |&lt;------------+<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; +-------------------------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initially the machinery is in the START stage. When an xl_running_xacts<br/></li>
<li></span><span class="Comment"> * record is read that is sufficiently new (above the safe xmin horizon),<br/></li>
<li></span><span class="Comment"> * there's a state transition. If there were no running xacts when the<br/></li>
<li></span><span class="Comment"> * xl_running_xacts record was generated, we'll directly go into CONSISTENT<br/></li>
<li></span><span class="Comment"> * state, otherwise we'll switch to the BUILDING_SNAPSHOT state. Having a full<br/></li>
<li></span><span class="Comment"> * snapshot means that all transactions that start henceforth can be decoded<br/></li>
<li></span><span class="Comment"> * in their entirety, but transactions that started previously can't. In<br/></li>
<li></span><span class="Comment"> * FULL_SNAPSHOT we'll switch into CONSISTENT once all those previously<br/></li>
<li></span><span class="Comment"> * running transactions have committed or aborted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only transactions that commit after CONSISTENT state has been reached will<br/></li>
<li></span><span class="Comment"> * be replayed, even though they might have started while still in<br/></li>
<li></span><span class="Comment"> * FULL_SNAPSHOT. That ensures that we'll reach a point where no previous<br/></li>
<li></span><span class="Comment"> * changes has been exported, but all the following ones will be. That point<br/></li>
<li></span><span class="Comment"> * is a convenient point to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> replication from, which is why we<br/></li>
<li></span><span class="Comment"> * export a snapshot at that point, which *can* be used to read normal data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2012-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/snapbuild.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/reorderbuffer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/snapbuild.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapshot.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This struct contains the current state of the snapshot building<br/></li>
<li></span><span class="Comment"> * machinery. Besides a forward declaration in the header, it is not exposed<br/></li>
<li></span><span class="Comment"> * to the public, so we can easily change its contents.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L152">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">SnapBuild</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* how far are we along building our first full snapshot */<br/></li>
<li></span>&nbsp; &nbsp; SnapBuildState state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* private memory context used to allocate memory for this module. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all transactions &lt; than this have committed/aborted */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all transactions &gt;= than this are uncommitted */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId xmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't replay commits from an LSN &lt; this LSN. This can be set externally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it will also be advanced (never retreat) from within snapbuild.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; start_decoding_at;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN at which two-phase decoding was enabled or LSN at which we found a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent point at the time of slot creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The prepared transactions, that were skipped because previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * two-phase was not enabled or are not covered by initial snapshot, need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be sent later along with commit prepared and they must be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; two_phase_at;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't start decoding WAL until the &quot;xl_running_xacts&quot; information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicates there are no running xids with an xid smaller than this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId initial_xmin_horizon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Indicates if we are building full snapshot or just catalog one. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; building_full_snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Snapshot that's valid to see the catalog state seen at this moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN of the last location we are sure a snapshot has been serialized to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; last_serialized_snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The reorderbuffer we need to update with usable snapshots et al.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ReorderBuffer *reorder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TransactionId at which the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase of initial snapshot building will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen. InvalidTransactionId if not known (i.e. SNAPBUILD_START), or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when no <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase necessary (SNAPBUILD_CONSISTENT).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId next_phase_at;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array of transactions which could have catalog changes that committed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between xmin and xmax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of committed transactions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; xcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* available space for committed transactions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; xcnt_space;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Until we reach a CONSISTENT state, we record commits of all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions, not just the catalog changing ones. Record when that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes so we know we cannot export a snapshot safely anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; includes_all_transactions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Array of committed transactions that have modified the catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As this array is frequently modified we do *not* keep it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a> order. Instead we sort the array when building &amp;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distributing a snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">TODO</span><span class="Comment">: It's unclear whether that reasoning has much merit. Every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time we add something here after becoming consistent will also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * require distributing a snapshot. Storing them sorted would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * potentially also make it easier to purge (but more complicated wrt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wraparound?). Should be improved if sorting while building the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot shows up in profiles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xip;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; committed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array of transactions and subtransactions that had modified catalogs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and were running when the snapshot was serialized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We normally rely on some WAL record types such as HEAP2_NEW_CID to know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the transaction has changed the catalog. But it could happen that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the logical decoding decodes only the commit record of the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after restoring the previously serialized snapshot in which case we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> adding the xid to the snapshot and end up looking at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalogs with the wrong snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now to avoid the above problem, we serialize the transactions that had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modified the catalogs and are still running at the time of snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serialization. We fill this array while restoring the snapshot and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refer it while decoding commit to ensure if the xact has modified the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog. We discard this array when all the xids in the list become old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to matter. See <a href="#L947" title="replication/logical/snapbuild.c:947">SnapBuildPurgeOlderTxn</a> for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of transactions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; xcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This array must be sorted in <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a> order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xip;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; catchange;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Starting a transaction -- which we need to do while exporting a snapshot --<br/></li>
<li></span><span class="Comment"> * removes knowledge about the previously used resowner, so we save it here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L282">&#x200c;</a></span><span class="Type">static</span> ResourceOwner <span class="linkable">SavedResourceOwnerDuringExport</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L283">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">ExportInProgress</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* -&gt;committed and -&gt;catchange manipulation */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L947" title="replication/logical/snapbuild.c:947">SnapBuildPurgeOlderTxn</a>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder);<br/></li>
<li><br/></li>
<li><span class="Comment">/* snapshot building/manipulation/distribution <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> Snapshot <a href="#L489" title="replication/logical/snapbuild.c:489">SnapBuildBuildSnapshot</a>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L381" title="replication/logical/snapbuild.c:381">SnapBuildFreeSnapshot</a>(Snapshot snap);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(Snapshot snap);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L860" title="replication/logical/snapbuild.c:860">SnapBuildDistributeNewCatalogSnapshot</a>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1187" title="replication/logical/snapbuild.c:1187">SnapBuildXidHasCatalogChanges</a>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 xinfo);<br/></li>
<li><br/></li>
<li><span class="Comment">/* xlog reading helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="#L1217" title="replication/logical/snapbuild.c:1217">SnapBuildProcessRunningXacts</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1319" title="replication/logical/snapbuild.c:1319">SnapBuildFindSnapshot</a>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn, xl_running_xacts *running);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1509" title="replication/logical/snapbuild.c:1509">SnapBuildWaitSnapshot</a>(xl_running_xacts *running, TransactionId cutoff);<br/></li>
<li><br/></li>
<li><span class="Comment">/* serialization <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1605" title="replication/logical/snapbuild.c:1605">SnapBuildSerialize</a>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1845" title="replication/logical/snapbuild.c:1845">SnapBuildRestore</a>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2017" title="replication/logical/snapbuild.c:2017">SnapBuildRestoreContents</a>(<span class="Type">int</span> fd, <span class="Type">char</span> *dest, Size size, <span class="Type">const</span> <span class="Type">char</span> *path);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new snapshot builder.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xmin_horizon is the xid &gt;= which we can be sure no catalog rows have been<br/></li>
<li></span><span class="Comment"> * removed, start_lsn is the LSN &gt;= we want to replay commits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *<br/></li>
<li><a id="L316">&#x200c;</a><span class="linkable">AllocateSnapshotBuilder</span>(ReorderBuffer *reorder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmin_horizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> need_full_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr two_phase_at)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext context;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>&nbsp; *builder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate memory in own context, to have better accountability */<br/></li>
<li></span>&nbsp; &nbsp; context = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;snapshot builder context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; builder = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; builder-&gt;state = SNAPBUILD_START;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;context = context;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;reorder = reorder;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Other struct members initialized by zeroing via <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> above */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; builder-&gt;committed.xcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;committed.xcnt_space = <span class="Constant">128</span>;&nbsp; &nbsp; <span class="Comment">/* arbitrary number */<br/></li>
<li></span>&nbsp; &nbsp; builder-&gt;committed.xip =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(builder-&gt;committed.xcnt_space * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; builder-&gt;committed.includes_all_transactions = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; builder-&gt;catchange.xcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;catchange.xip = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; builder-&gt;initial_xmin_horizon = xmin_horizon;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;start_decoding_at = start_lsn;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;building_full_snapshot = need_full_snapshot;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;two_phase_at = two_phase_at;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> builder;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a snapshot builder.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L362">&#x200c;</a></span><span class="linkable">FreeSnapshotBuilder</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext context = builder-&gt;context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free snapshot explicitly, that contains some error checking */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;snapshot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a>(builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;snapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* other resources are deallocated via memory context reset */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free an unreferenced snapshot that has previously been built by us.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L381">&#x200c;</a></span><span class="linkable">SnapBuildFreeSnapshot</span>(Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure we don't get passed an external snapshot */<br/></li>
<li></span>&nbsp; &nbsp; Assert(snap-&gt;snapshot_type == SNAPSHOT_HISTORIC_MVCC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure nobody modified our snapshot */<br/></li>
<li></span>&nbsp; &nbsp; Assert(snap-&gt;curcid == FirstCommandId);<br/></li>
<li>&nbsp; &nbsp; Assert(!snap-&gt;suboverflowed);<br/></li>
<li>&nbsp; &nbsp; Assert(!snap-&gt;takenDuringRecovery);<br/></li>
<li>&nbsp; &nbsp; Assert(snap-&gt;regd_count == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* slightly more likely, so it's checked even without c-asserts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot free a copied snapshot&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;active_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot free an active snapshot&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(snap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In which state of snapshot building are we?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SnapBuildState<br/></li>
<li><a id="L406">&#x200c;</a><span class="linkable">SnapBuildCurrentState</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> builder-&gt;state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the LSN at which the two-phase decoding was first enabled.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L415">&#x200c;</a><span class="linkable">SnapBuildGetTwoPhaseAt</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> builder-&gt;two_phase_at;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the LSN at which two-phase decoding is enabled.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L424">&#x200c;</a></span><span class="linkable">SnapBuildSetTwoPhaseAt</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; builder-&gt;two_phase_at = ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Should the contents of transaction ending at 'ptr' be decoded?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L433">&#x200c;</a></span><span class="linkable">SnapBuildXactNeedsSkip</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ptr &lt; builder-&gt;start_decoding_at;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Increase refcount of a snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used when handing out a snapshot to some external resource or when<br/></li>
<li></span><span class="Comment"> * adding a Snapshot as builder-&gt;snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L445">&#x200c;</a></span><span class="linkable">SnapBuildSnapIncRefcount</span>(Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; snap-&gt;active_count++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decrease refcount of a snapshot and free if the refcount reaches zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Externally visible, so that external resources that have been handed an<br/></li>
<li></span><span class="Comment"> * IncRef'ed Snapshot can adjust its refcount easily.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L457">&#x200c;</a></span><span class="linkable">SnapBuildSnapDecRefcount</span>(Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure we don't get passed an external snapshot */<br/></li>
<li></span>&nbsp; &nbsp; Assert(snap-&gt;snapshot_type == SNAPSHOT_HISTORIC_MVCC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure nobody modified our snapshot */<br/></li>
<li></span>&nbsp; &nbsp; Assert(snap-&gt;curcid == FirstCommandId);<br/></li>
<li>&nbsp; &nbsp; Assert(!snap-&gt;suboverflowed);<br/></li>
<li>&nbsp; &nbsp; Assert(!snap-&gt;takenDuringRecovery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snap-&gt;regd_count == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snap-&gt;active_count &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* slightly more likely, so it's checked even without casserts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot free a copied snapshot&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap-&gt;active_count--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;active_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="replication/logical/snapbuild.c:381">SnapBuildFreeSnapshot</a>(snap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a new snapshot, based on currently committed catalog-modifying<br/></li>
<li></span><span class="Comment"> * transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In-progress transactions with catalog access are *not* allowed to modify<br/></li>
<li></span><span class="Comment"> * these snapshots; they have to copy them and fill in appropriate -&gt;curcid<br/></li>
<li></span><span class="Comment"> * and -&gt;subxip/subxcnt <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Snapshot<br/></li>
<li><a id="L489">&#x200c;</a><span class="linkable">SnapBuildBuildSnapshot</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; ssize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(builder-&gt;state &gt;= SNAPBUILD_FULL_SNAPSHOT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ssize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * builder-&gt;committed.xcnt<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * <span class="Constant">1</span> <span class="Comment">/* toplevel xid */</span> ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(builder-&gt;context, ssize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;snapshot_type = SNAPSHOT_HISTORIC_MVCC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We misuse the original meaning of SnapshotData's xip and subxip fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to make the more fitting for our needs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the 'xip' array we store transactions that have to be treated as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed. Since we will only ever look at tuples from transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that have modified the catalog it's more efficient to store those few<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that exist between xmin and xmax (frequently there are <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Snapshots that are used in transactions that have modified the catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also use the 'subxip' array to store their toplevel xid and all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction xids so we can recognize when we need to treat rows as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible that are not in xip but still need to be visible. Subxip only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gets filled when the transaction is copied into the context of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog modifying transaction since we otherwise share a snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between transactions. As long as a txn hasn't modified the catalog it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't need to treat <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> uncommitted rows as visible, so there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need for those xids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both arrays are qsort'ed so that we can use bsearch() on them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsNormal(builder-&gt;xmin));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(builder-&gt;xmax));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xmin = builder-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xmax = builder-&gt;xmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store all transactions to be treated as committed by this snapshot */<br/></li>
<li></span>&nbsp; &nbsp; snapshot-&gt;xip =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (TransactionId *) ((<span class="Type">char</span> *) snapshot + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData));<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xcnt = builder-&gt;committed.xcnt;<br/></li>
<li>&nbsp; &nbsp; memcpy(snapshot-&gt;xip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;committed.xip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;committed.xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort so we can bsearch() */<br/></li>
<li></span>&nbsp; &nbsp; qsort(snapshot-&gt;xip, snapshot-&gt;xcnt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initially, subxip is empty, i.e. it's a snapshot to be used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions that don't modify the catalog. Will be filled by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="reorderbuffer.c.html#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>() if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot-&gt;subxcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;subxip = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;suboverflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;takenDuringRecovery = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;copied = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;curcid = FirstCommandId;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;active_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;regd_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;snapXactCompletionCount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build the initial slot snapshot and convert it to a normal snapshot that<br/></li>
<li></span><span class="Comment"> * is understood by <a href="../../access/heap/heapam_visibility.c.html#L960" title="access/heap/heapam_visibility.c:960">HeapTupleSatisfiesMVCC</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The snapshot will be usable directly in current transaction or exported<br/></li>
<li></span><span class="Comment"> * for loading in different transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L569">&#x200c;</a><span class="linkable">SnapBuildInitialSnapshot</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; TransactionId safeXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId *newxip;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newxcnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L77" title="access/transam/xact.c:77">XactIsoLevel</a> == XACT_REPEATABLE_READ);<br/></li>
<li>&nbsp; &nbsp; Assert(builder-&gt;building_full_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't allow older snapshots */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();&nbsp; &nbsp; <span class="Comment">/* about to overwrite <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/time/snapmgr.c.html#L1624" title="utils/time/snapmgr.c:1624">HaveRegisteredOrActiveSnapshot</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot build an initial slot snapshot when snapshots exist&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../utils/time/snapmgr.c.html#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state != SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot build an initial slot snapshot <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching a consistent state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!builder-&gt;committed.includes_all_transactions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot build an initial slot snapshot, not all transactions are monitored anymore&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* so we don't overwrite the existing value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot build an initial slot snapshot when <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin already is valid&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap = <a href="#L489" title="replication/logical/snapbuild.c:489">SnapBuildBuildSnapshot</a>(builder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know that snap-&gt;xmin is alive, enforced by the logical xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mechanism. Due to that we can do this without locks, we're only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changing our own value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Building an initial snapshot is expensive and an unenforced xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * horizon would have bad consequences, therefore always double-check that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the horizon is enforced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; safeXid = <a href="../../storage/ipc/procarray.c.html#L2932" title="storage/ipc/procarray.c:2932">GetOldestSafeDecodingTransactionId</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(safeXid, snap-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot build an initial slot snapshot as oldest safe xid </span><span class="Special">%u</span><span class="Constant"> follows snapshot's xmin </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; safeXid, snap-&gt;xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = snap-&gt;xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate in transaction context */<br/></li>
<li></span>&nbsp; &nbsp; newxip = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * <a href="../../storage/ipc/procarray.c.html#L2057" title="storage/ipc/procarray.c:2057">GetMaxSnapshotXidCount</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapbuild.c builds transactions in an &quot;inverted&quot; manner, which means it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stores committed transactions in -&gt;xip, not ones in progress. Build a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * classical snapshot by marking all non-committed transactions as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-progress. This can be expensive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (xid = snap-&gt;xmin; NormalTransactionIdPrecedes(xid, snap-&gt;xmax);)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *test;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether transaction committed using the decoding snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * meaning of -&gt;xip.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; test = bsearch(&amp;xid, snap-&gt;xip, snap-&gt;xcnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (test == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newxcnt &gt;= <a href="../../storage/ipc/procarray.c.html#L2057" title="storage/ipc/procarray.c:2057">GetMaxSnapshotXidCount</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;initial slot snapshot too large&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newxip[newxcnt++] = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* adjust remaining snapshot fields as needed */<br/></li>
<li></span>&nbsp; &nbsp; snap-&gt;snapshot_type = SNAPSHOT_MVCC;<br/></li>
<li>&nbsp; &nbsp; snap-&gt;xcnt = newxcnt;<br/></li>
<li>&nbsp; &nbsp; snap-&gt;xip = newxip;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Export a snapshot so it can be set in another session with <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TRANSACTION<br/></li>
<li></span><span class="Comment"> * SNAPSHOT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For that we need to start a transaction in the current backend as the<br/></li>
<li></span><span class="Comment"> * importing side checks whether the source transaction is still open to make<br/></li>
<li></span><span class="Comment"> * sure the xmin horizon hasn't advanced since then.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L668">&#x200c;</a><span class="linkable">SnapBuildExportSnapshot</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *snapname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot export a snapshot from within a transaction&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L282" title="replication/logical/snapbuild.c:282">SavedResourceOwnerDuringExport</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;can only export one snapshot at a time&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L282" title="replication/logical/snapbuild.c:282">SavedResourceOwnerDuringExport</a> = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="replication/logical/snapbuild.c:283">ExportInProgress</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There doesn't seem to a nice API to set these */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L77" title="access/transam/xact.c:77">XactIsoLevel</a> = XACT_REPEATABLE_READ;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap = <a href="#L569" title="replication/logical/snapbuild.c:569">SnapBuildInitialSnapshot</a>(builder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we've built a plain snapshot, make it active and use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normal mechanisms for exporting it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapname = <a href="../../utils/time/snapmgr.c.html#L1095" title="utils/time/snapmgr.c:1095">ExportSnapshot</a>(snap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;exported logical decoding snapshot: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with </span><span class="Special">%u</span><span class="Constant"> transaction ID&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;exported logical decoding snapshot: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with </span><span class="Special">%u</span><span class="Constant"> transaction IDs&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snap-&gt;xcnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapname, snap-&gt;xcnt)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapname;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure there is a snapshot and if not build one for current transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L708">&#x200c;</a><span class="linkable">SnapBuildGetOrBuildSnapshot</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(builder-&gt;state == SNAPBUILD_CONSISTENT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* only build a new snapshot if we don't have a prebuilt one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;snapshot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;snapshot = <a href="#L489" title="replication/logical/snapbuild.c:489">SnapBuildBuildSnapshot</a>(builder);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increase refcount for the snapshot builder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> builder-&gt;snapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset a previously <a href="#L668" title="replication/logical/snapbuild.c:668">SnapBuildExportSnapshot</a>()'ed snapshot if there is<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. Aborts the previously started transaction and resets the resource<br/></li>
<li></span><span class="Comment"> * owner back to its original value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L729">&#x200c;</a></span><span class="linkable">SnapBuildClearExportedSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResourceOwner tmpResOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing exported, that is the usual case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L283" title="replication/logical/snapbuild.c:283">ExportInProgress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;clearing exported snapshot in wrong transaction state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>() takes care of resetting the snapshot state,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so remember <a href="#L282" title="replication/logical/snapbuild.c:282">SavedResourceOwnerDuringExport</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmpResOwner = <a href="#L282" title="replication/logical/snapbuild.c:282">SavedResourceOwnerDuringExport</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure nothing could have ever happened */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = tmpResOwner;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear snapshot export state during transaction abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L756">&#x200c;</a></span><span class="linkable">SnapBuildResetExportedSnapshotState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L282" title="replication/logical/snapbuild.c:282">SavedResourceOwnerDuringExport</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="replication/logical/snapbuild.c:283">ExportInProgress</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle the effects of a single heap change, appropriate to the current state<br/></li>
<li></span><span class="Comment"> * of the snapshot builder and returns whether changes made at (xid, lsn) can<br/></li>
<li></span><span class="Comment"> * be decoded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L768">&#x200c;</a></span><span class="linkable">SnapBuildProcessChange</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, TransactionId xid, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't handle data in transactions if we haven't built a snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * yet, so don't store them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_FULL_SNAPSHOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No point in keeping track of changes in transactions that we don't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough information about to decode. This means that they started <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we got into the SNAPBUILD_FULL_SNAPSHOT state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_CONSISTENT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, builder-&gt;next_phase_at))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the reorderbuffer doesn't yet have a snapshot, add one <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be needed to decode the change we're currently processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="reorderbuffer.c.html#L3461" title="replication/logical/reorderbuffer.c:3461">ReorderBufferXidHasBaseSnapshot</a>(builder-&gt;reorder, xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only build a new snapshot if we don't have a prebuilt one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;snapshot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;snapshot = <a href="#L489" title="replication/logical/snapbuild.c:489">SnapBuildBuildSnapshot</a>(builder);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* increase refcount for the snapshot builder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Increase refcount for the transaction we're handing the snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="reorderbuffer.c.html#L3133" title="replication/logical/reorderbuffer.c:3133">ReorderBufferSetBaseSnapshot</a>(builder-&gt;reorder, xid, lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do CommandId/combo CID handling after reading an xl_heap_new_cid record.<br/></li>
<li></span><span class="Comment"> * This implies that a transaction has done some form of write to system<br/></li>
<li></span><span class="Comment"> * catalogs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L818">&#x200c;</a></span><span class="linkable">SnapBuildProcessNewCid</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, xl_heap_new_cid *xlrec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we only log new_cid's if a catalog tuple was modified, so mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction as containing catalog modifications<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="reorderbuffer.c.html#L3371" title="replication/logical/reorderbuffer.c:3371">ReorderBufferXidSetCatalogChanges</a>(builder-&gt;reorder, xid, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="reorderbuffer.c.html#L3263" title="replication/logical/reorderbuffer.c:3263">ReorderBufferAddNewTupleCids</a>(builder-&gt;reorder, xlrec-&gt;top_xid, lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;target_locator, xlrec-&gt;target_tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;cmin, xlrec-&gt;cmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;combocid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* figure out new command id */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;cmin != InvalidCommandId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;cmax != InvalidCommandId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cid = Max(xlrec-&gt;cmin, xlrec-&gt;cmax);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xlrec-&gt;cmax != InvalidCommandId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cid = xlrec-&gt;cmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xlrec-&gt;cmin != InvalidCommandId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cid = xlrec-&gt;cmin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cid = InvalidCommandId; <span class="Comment">/* silence compiler */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;xl_heap_new_cid record without a valid CommandId&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="reorderbuffer.c.html#L3164" title="replication/logical/reorderbuffer.c:3164">ReorderBufferAddNewCommandId</a>(builder-&gt;reorder, xid, lsn, cid + <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a new Snapshot to all transactions we're decoding that currently are<br/></li>
<li></span><span class="Comment"> * in-progress so they can see new catalog contents made by the transaction<br/></li>
<li></span><span class="Comment"> * that just committed. This is necessary because those in-progress<br/></li>
<li></span><span class="Comment"> * transactions will use the new catalog's contents from here on (at the very<br/></li>
<li></span><span class="Comment"> * least everything they do needs to be compatible with newer catalog<br/></li>
<li></span><span class="Comment"> * contents).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L860">&#x200c;</a></span><span class="linkable">SnapBuildDistributeNewCatalogSnapshot</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; txn_i;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate through all toplevel transactions. This can include<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransactions which we just don't yet know to be that, but that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fine, they will just get an unnecessary snapshot queued.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(txn_i, &amp;builder-&gt;reorder-&gt;toplevel_by_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = dlist_container(ReorderBufferTXN, node, txn_i.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(txn-&gt;xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't have a base snapshot yet, there are no changes in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction which in turn implies we don't yet need a snapshot at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all. We'll add a snapshot when the first change gets queued.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: This works correctly even for subtransactions because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="reorderbuffer.c.html#L1069" title="replication/logical/reorderbuffer.c:1069">ReorderBufferAssignChild</a>() takes care to transfer the base snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the top-level transaction, and while iterating the changequeue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll get the change from the subtxn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="reorderbuffer.c.html#L3461" title="replication/logical/reorderbuffer.c:3461">ReorderBufferXidHasBaseSnapshot</a>(builder-&gt;reorder, txn-&gt;xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to add snapshot to prepared transactions as they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should not see the new catalog contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_prepared(txn) || rbtxn_skip_prepared(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;adding a new snapshot to </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txn-&gt;xid, LSN_FORMAT_ARGS(lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increase the snapshot's refcount for the transaction we are handing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it out to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="reorderbuffer.c.html#L3115" title="replication/logical/reorderbuffer.c:3115">ReorderBufferAddSnapshot</a>(builder-&gt;reorder, txn-&gt;xid, lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Keep track of a new catalog changing transaction that has committed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L913">&#x200c;</a></span><span class="linkable">SnapBuildAddCommittedTxn</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;committed.xcnt == builder-&gt;committed.xcnt_space)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;committed.xcnt_space = builder-&gt;committed.xcnt_space * <span class="Constant">2</span> + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;increasing space for committed transactions to </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) builder-&gt;committed.xcnt_space);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;committed.xip = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(builder-&gt;committed.xip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;committed.xcnt_space * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">TODO</span><span class="Comment">: It might make sense to keep the array sorted here instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing it every time we build a new snapshot. On the other hand this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gets called repeatedly when a transaction with subtransactions commits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; builder-&gt;committed.xip[builder-&gt;committed.xcnt++] = xid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove knowledge about transactions we treat as committed or containing catalog<br/></li>
<li></span><span class="Comment"> * changes that are smaller than -&gt;xmin. Those won't ever get checked via<br/></li>
<li></span><span class="Comment"> * the -&gt;committed or -&gt;catchange array, respectively. The committed xids will<br/></li>
<li></span><span class="Comment"> * get checked via the clog machinery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can ideally remove the transaction from catchange array once it is<br/></li>
<li></span><span class="Comment"> * finished (committed/aborted) but that could be costly as we need to maintain<br/></li>
<li></span><span class="Comment"> * the xids order in the array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L947">&#x200c;</a></span><span class="linkable">SnapBuildPurgeOlderTxn</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li>&nbsp; &nbsp; TransactionId *workspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; surviving_xids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not ready yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(builder-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment">: Neater algorithm than just copying and iterating? */<br/></li>
<li></span>&nbsp; &nbsp; workspace =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(builder-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;committed.xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy xids that still are interesting to workspace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (off = <span class="Constant">0</span>; off &lt; builder-&gt;committed.xcnt; off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (NormalTransactionIdPrecedes(builder-&gt;committed.xip[off],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace[surviving_xids++] = builder-&gt;committed.xip[off];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy workspace back to persistent state */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(builder-&gt;committed.xip, workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; surviving_xids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;purged committed transactions from </span><span class="Special">%u</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant">, xmin: </span><span class="Special">%u</span><span class="Constant">, xmax: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) builder-&gt;committed.xcnt, (uint32) surviving_xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;xmin, builder-&gt;xmax);<br/></li>
<li>&nbsp; &nbsp; builder-&gt;committed.xcnt = surviving_xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(workspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Purge xids in -&gt;catchange as well. The purged array must also be sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a> order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;catchange.xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since catchange.xip is sorted, we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of xids that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are still interesting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (off = <span class="Constant">0</span>; off &lt; builder-&gt;catchange.xcnt; off++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(builder-&gt;catchange.xip[off],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; surviving_xids = builder-&gt;catchange.xcnt - off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (surviving_xids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(builder-&gt;catchange.xip, &amp;(builder-&gt;catchange.xip[off]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; surviving_xids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(builder-&gt;catchange.xip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;catchange.xip = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;purged catalog modifying transactions from </span><span class="Special">%u</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant">, xmin: </span><span class="Special">%u</span><span class="Constant">, xmax: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) builder-&gt;catchange.xcnt, (uint32) surviving_xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;xmin, builder-&gt;xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;catchange.xcnt = surviving_xids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle everything that needs to be done when a transaction commits<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1024">&#x200c;</a></span><span class="linkable">SnapBuildCommitTxn</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nsubxacts, TransactionId *subxacts, uint32 xinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_snapshot = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_timetravel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sub_needs_timetravel = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TransactionId xmax = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transactions preceding BUILDING_SNAPSHOT will neither be decoded, nor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will they be part of a snapshot.&nbsp; So we don't need to record anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state == SNAPBUILD_START ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (builder-&gt;state == SNAPBUILD_BUILDING_SNAPSHOT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, builder-&gt;next_phase_at)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure that only commits after this are getting replayed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;start_decoding_at &lt;= lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;start_decoding_at = lsn + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure that only commits after this are getting replayed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;start_decoding_at &lt;= lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;start_decoding_at = lsn + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If building an exportable snapshot, force xid to be tracked, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the transaction didn't modify the catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;building_full_snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_timetravel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (nxact = <span class="Constant">0</span>; nxact &lt; nsubxacts; nxact++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId subxid = subxacts[nxact];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add subtransaction to base snapshot if catalog modifying, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distinguish to toplevel transactions there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1187" title="replication/logical/snapbuild.c:1187">SnapBuildXidHasCatalogChanges</a>(builder, subxid, xinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_needs_timetravel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_snapshot = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;found subtransaction </span><span class="Special">%u</span><span class="Constant">:</span><span class="Special">%u</span><span class="Constant"> with catalog changes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, subxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L913" title="replication/logical/snapbuild.c:913">SnapBuildAddCommittedTxn</a>(builder, subxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (NormalTransactionIdFollows(subxid, xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmax = subxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're forcing timetravel we also need visibility information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about subtransaction, so keep track of subtransaction's state, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if not catalog modifying.&nbsp; Don't need to distribute a snapshot in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (needs_timetravel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L913" title="replication/logical/snapbuild.c:913">SnapBuildAddCommittedTxn</a>(builder, subxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (NormalTransactionIdFollows(subxid, xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmax = subxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if top-level modified catalog, it'll need a snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1187" title="replication/logical/snapbuild.c:1187">SnapBuildXidHasCatalogChanges</a>(builder, xid, xinfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;found top level transaction </span><span class="Special">%u</span><span class="Constant">, with catalog changes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needs_snapshot = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needs_timetravel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L913" title="replication/logical/snapbuild.c:913">SnapBuildAddCommittedTxn</a>(builder, xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sub_needs_timetravel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* track toplevel txn as well, subxact alone isn't meaningful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;forced transaction </span><span class="Special">%u</span><span class="Constant"> to do timetravel due to one of its subtransactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needs_timetravel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L913" title="replication/logical/snapbuild.c:913">SnapBuildAddCommittedTxn</a>(builder, xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (needs_timetravel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;forced transaction </span><span class="Special">%u</span><span class="Constant"> to do timetravel&quot;</span>, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L913" title="replication/logical/snapbuild.c:913">SnapBuildAddCommittedTxn</a>(builder, xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!needs_timetravel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* record that we cannot export a general snapshot anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;committed.includes_all_transactions = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!needs_snapshot || needs_timetravel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust xmax of the snapshot builder, we only do that for committed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog modifying, transactions, everything else isn't interesting for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us since we'll never look at the respective rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needs_timetravel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!TransactionIdIsValid(builder-&gt;xmax) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xmax, builder-&gt;xmax)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;xmax = xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdAdvance(builder-&gt;xmax);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reason to build a historic snapshot, do so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needs_snapshot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we haven't built a complete snapshot yet there's no need to hand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it out, it wouldn't (and couldn't) be used anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_FULL_SNAPSHOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decrease the snapshot builder's refcount of the old snapshot, note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it still will be used if it has been handed out to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reorderbuffer earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a>(builder-&gt;snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;snapshot = <a href="#L489" title="replication/logical/snapbuild.c:489">SnapBuildBuildSnapshot</a>(builder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we might need to execute invalidations, add snapshot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="reorderbuffer.c.html#L3461" title="replication/logical/reorderbuffer.c:3461">ReorderBufferXidHasBaseSnapshot</a>(builder-&gt;reorder, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="reorderbuffer.c.html#L3133" title="replication/logical/reorderbuffer.c:3133">ReorderBufferSetBaseSnapshot</a>(builder-&gt;reorder, xid, lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* refcount of the snapshot builder for the new snapshot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(builder-&gt;snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add a new catalog snapshot to all currently running transactions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L860" title="replication/logical/snapbuild.c:860">SnapBuildDistributeNewCatalogSnapshot</a>(builder, lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check the reorder buffer and the snapshot to see if the given transaction has<br/></li>
<li></span><span class="Comment"> * modified catalogs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1187">&#x200c;</a></span><span class="linkable">SnapBuildXidHasCatalogChanges</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 xinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="reorderbuffer.c.html#L3444" title="replication/logical/reorderbuffer.c:3444">ReorderBufferXidHasCatalogChanges</a>(builder-&gt;reorder, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The transactions that have changed catalogs must have invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(xinfo &amp; XACT_XINFO_HAS_INVALS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the catchange XID array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> ((builder-&gt;catchange.xcnt &gt; <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (bsearch(&amp;xid, builder-&gt;catchange.xip, builder-&gt;catchange.xcnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a>) != <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------------------------<br/></li>
<li></span><span class="Comment"> * Snapshot building <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> dealing with xlog <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> * -----------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process a running xacts record, and use its information to first build a<br/></li>
<li></span><span class="Comment"> * historic snapshot and later to release resources that aren't needed<br/></li>
<li></span><span class="Comment"> * anymore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1217">&#x200c;</a></span><span class="linkable">SnapBuildProcessRunningXacts</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn, xl_running_xacts *running)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not consistent yet, inspect the record to see whether it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows to get closer to being consistent. If we are consistent, <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our snapshot so others or we, after a restart, can use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* returns false if there's no point in performing <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> just yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1319" title="replication/logical/snapbuild.c:1319">SnapBuildFindSnapshot</a>(builder, lsn, running))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1605" title="replication/logical/snapbuild.c:1605">SnapBuildSerialize</a>(builder, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of interesting xids based on the running xacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information. We don't increase -&gt;xmax using it, because once we are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a consistent state we can do that ourselves and much more efficiently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so, because we only need to do it for catalog transactions since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only ever look at those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: We only increase xmax when a catalog modifying transaction commits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (see <a href="#L1024" title="replication/logical/snapbuild.c:1024">SnapBuildCommitTxn</a>).&nbsp; Because of this, xmax can be <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmin, which looks odd but is correct and actually more efficient, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we hit fast paths in heapam_visibility.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; builder-&gt;xmin = running-&gt;oldestRunningXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove transactions we don't need to keep track off anymore */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L947" title="replication/logical/snapbuild.c:947">SnapBuildPurgeOlderTxn</a>(builder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance the xmin limit for the current replication slot, to allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> to clean up the tuples this slot has been protecting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The reorderbuffer might have an xmin among the currently running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshots; use it if so.&nbsp; If not, we need only consider the snapshots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll produce later, which can't be less than the oldest running xid in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the record we're reading <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xmin = <a href="reorderbuffer.c.html#L1042" title="replication/logical/reorderbuffer.c:1042">ReorderBufferGetOldestXmin</a>(builder-&gt;reorder);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xmin == InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmin = running-&gt;oldestRunningXid;<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;xmin: </span><span class="Special">%u</span><span class="Constant">, xmax: </span><span class="Special">%u</span><span class="Constant">, oldest running: </span><span class="Special">%u</span><span class="Constant">, oldest xmin: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;xmin, builder-&gt;xmax, running-&gt;oldestRunningXid, xmin);<br/></li>
<li>&nbsp; &nbsp; <a href="logical.c.html#L1692" title="replication/logical/logical.c:1692">LogicalIncreaseXminForSlot</a>(lsn, xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also tell the slot where we can restart decoding from. We don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do that after every commit because changing that implies an fsync of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the logical slot's state file, so we only do it every time we see a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running xacts record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do so by looking for the oldest in progress transaction (determined by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first LSN of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its relevant <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>). Every transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remembers the last location we stored the snapshot to disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beginning. That point is where we can restart from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't know about a serialized snapshot's location if we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="reorderbuffer.c.html#L1014" title="replication/logical/reorderbuffer.c:1014">ReorderBufferGetOldestTXN</a>(builder-&gt;reorder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oldest ongoing txn might have started when we didn't yet serialize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything because we hadn't reached a consistent state yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn != <span class="Constant">NULL</span> &amp;&amp; txn-&gt;restart_decoding_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical.c.html#L1760" title="replication/logical/logical.c:1760">LogicalIncreaseRestartDecodingForSlot</a>(lsn, txn-&gt;restart_decoding_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No in-progress transaction, can reuse the last serialized snapshot if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (txn == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;reorder-&gt;current_restart_decoding_lsn != InvalidXLogRecPtr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;last_serialized_snapshot != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical.c.html#L1760" title="replication/logical/logical.c:1760">LogicalIncreaseRestartDecodingForSlot</a>(lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;last_serialized_snapshot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build the start of a snapshot that's capable of decoding the catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L1217" title="replication/logical/snapbuild.c:1217">SnapBuildProcessRunningXacts</a>() while we're not yet<br/></li>
<li></span><span class="Comment"> * consistent.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if there is a point in performing <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> maintenance/<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment"> * using the xl_running_xacts record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1319">&#x200c;</a></span><span class="linkable">SnapBuildFindSnapshot</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn, xl_running_xacts *running)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build catalog decoding snapshot incrementally using information about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the currently running transactions. There are several ways to do that:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a) There were no running transactions when the xl_running_xacts record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; was inserted, jump to CONSISTENT immediately. We might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; state while <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on c)'s sub-states.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * b) This (in a previous run) or another decoding slot serialized a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; snapshot to disk that we can use.&nbsp; Can't use this method for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; initial snapshot when slot is being created and needs full snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; for export or direct use, as that snapshot will only contain catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; modifying transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * c) First incrementally build a snapshot for catalog tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; (BUILDING_SNAPSHOT), that requires all, already in-progress,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; transactions to finish.&nbsp; Every transaction starting after that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; (FULL_SNAPSHOT state), has enough information to be decoded.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; for older running transactions no viable snapshot exists yet, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; CONSISTENT will only be reached once all of those have finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xl_running_xacts record is older than what we can use, we might not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have all necessary catalog rows anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(builder-&gt;initial_xmin_horizon) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NormalTransactionIdPrecedes(running-&gt;oldestRunningXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;initial_xmin_horizon))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;skipping snapshot at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> while building logical decoding snapshot, xmin horizon too low&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(lsn)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;initial xmin horizon of </span><span class="Special">%u</span><span class="Constant"> vs the snapshot's </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;initial_xmin_horizon, running-&gt;oldestRunningXid)));<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1509" title="replication/logical/snapbuild.c:1509">SnapBuildWaitSnapshot</a>(running, builder-&gt;initial_xmin_horizon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a) No transaction were running, we can jump to consistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not affected by races around xl_running_xacts, because we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> transaction commits, but currently not transactions starting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: We might have already started to incrementally assemble a snapshot,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we need to be careful to deal with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (running-&gt;oldestRunningXid == running-&gt;nextXid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;start_decoding_at == InvalidXLogRecPtr ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;start_decoding_at &lt;= lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can decode everything after this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;start_decoding_at = lsn + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As no transactions were running xmin/xmax can be trivially set. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;xmin = running-&gt;nextXid;&nbsp; &nbsp; <span class="Comment">/* &lt; are finished */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;xmax = running-&gt;nextXid;&nbsp; &nbsp; <span class="Comment">/* &gt;= are running */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* so we can safely use the faster comparisons */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(builder-&gt;xmin));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(builder-&gt;xmax));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;state = SNAPBUILD_CONSISTENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;next_phase_at = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding found consistent point at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;There are no running transactions.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* b) valid on disk state and not building full snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!builder-&gt;building_full_snapshot &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1845" title="replication/logical/snapbuild.c:1845">SnapBuildRestore</a>(builder, lsn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there won't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state to <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * c) transition from START to BUILDING_SNAPSHOT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In START state, and a xl_running_xacts record with running xacts is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * encountered.&nbsp; In that case, switch to BUILDING_SNAPSHOT state, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record xl_running_xacts-&gt;nextXid.&nbsp; Once all running xacts have finished<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. they're all &gt;= nextXid), we have a complete catalog snapshot.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might look that we could use xl_running_xacts's -&gt;xids information to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get there quicker, but that is problematic because transactions marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as running, might already have inserted their commit record - it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infeasible to change that with locking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (builder-&gt;state == SNAPBUILD_START)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;state = SNAPBUILD_BUILDING_SNAPSHOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;next_phase_at = running-&gt;nextXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start with an xmin/xmax that's correct for future, when all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently running transactions have finished. We'll update both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the pending transactions to finish.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;xmin = running-&gt;nextXid;&nbsp; &nbsp; <span class="Comment">/* &lt; are finished */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;xmax = running-&gt;nextXid;&nbsp; &nbsp; <span class="Comment">/* &gt;= are running */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* so we can safely use the faster comparisons */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(builder-&gt;xmin));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(builder-&gt;xmax));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding found initial starting point at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Waiting for transactions (approximately </span><span class="Special">%d</span><span class="Constant">) older than </span><span class="Special">%u</span><span class="Constant"> to end.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running-&gt;xcnt, running-&gt;nextXid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1509" title="replication/logical/snapbuild.c:1509">SnapBuildWaitSnapshot</a>(running, running-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * c) transition from BUILDING_SNAPSHOT to FULL_SNAPSHOT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In BUILDING_SNAPSHOT state, and this xl_running_xacts' oldestRunningXid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is &gt;= than nextXid from when we switched to BUILDING_SNAPSHOT.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * means all transactions starting afterwards have enough information to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be decoded.&nbsp; Switch to FULL_SNAPSHOT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (builder-&gt;state == SNAPBUILD_BUILDING_SNAPSHOT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(builder-&gt;next_phase_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running-&gt;oldestRunningXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;state = SNAPBUILD_FULL_SNAPSHOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;next_phase_at = running-&gt;nextXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding found initial consistent point at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Waiting for transactions (approximately </span><span class="Special">%d</span><span class="Constant">) older than </span><span class="Special">%u</span><span class="Constant"> to end.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running-&gt;xcnt, running-&gt;nextXid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1509" title="replication/logical/snapbuild.c:1509">SnapBuildWaitSnapshot</a>(running, running-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * c) transition from FULL_SNAPSHOT to CONSISTENT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In FULL_SNAPSHOT state, and this xl_running_xacts' oldestRunningXid is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &gt;= than nextXid from when we switched to FULL_SNAPSHOT.&nbsp; This means all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions that are currently in progress have a catalog snapshot,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and all their changes have been collected.&nbsp; Switch to CONSISTENT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (builder-&gt;state == SNAPBUILD_FULL_SNAPSHOT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(builder-&gt;next_phase_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; running-&gt;oldestRunningXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;state = SNAPBUILD_CONSISTENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;next_phase_at = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding found consistent point at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;There are no old transactions anymore.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We already started to track running xacts and need to wait for all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-progress ones to finish. We fall through to the normal processing of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> so incremental <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> can be performed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---<br/></li>
<li></span><span class="Comment"> * Iterate through xids in record, wait for all older than the cutoff to<br/></li>
<li></span><span class="Comment"> * finish.&nbsp; Then, if possible, log a new xl_running_xacts record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This isn't required for the correctness of decoding, but to:<br/></li>
<li></span><span class="Comment"> * a) allow isolationtester to notice that we're currently <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; something.<br/></li>
<li></span><span class="Comment"> * b) log a new xl_running_xacts record where it'd be helpful, without having<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to wait for bgwriter or checkpointer.<br/></li>
<li></span><span class="Comment"> * ---<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1509">&#x200c;</a></span><span class="linkable">SnapBuildWaitSnapshot</span>(xl_running_xacts *running, TransactionId cutoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (off = <span class="Constant">0</span>; off &lt; running-&gt;xcnt; off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid = running-&gt;xids[off];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Upper layers should prevent that we ever need to wait on ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check anyway, since failing to do so would either result in an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * endless wait or an Assert() failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for ourselves&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xid, cutoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(xid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, XLTW_None);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All transactions we needed to finish finished - try to ensure there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another xl_running_xacts record in a timely manner, without having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wait for bgwriter or checkpointer to log one.&nbsp; During recovery we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enforce that, so we'll have to wait.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L1285" title="storage/ipc/standby.c:1285">LogStandbySnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* -----------------------------------<br/></li>
<li></span><span class="Comment"> * Snapshot serialization support<br/></li>
<li></span><span class="Comment"> * -----------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We store current state of struct <a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> on disk in the following manner:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * struct <a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a>;<br/></li>
<li></span><span class="Comment"> * TransactionId * committed.xcnt; (*not xcnt_space*)<br/></li>
<li></span><span class="Comment"> * TransactionId * catchange.xcnt;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1556">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SnapBuildOnDisk</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first part of this struct needs to be version independent */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* data not covered by checksum */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; checksum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* data covered by checksum */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* version, in case we want to support pg_upgrade */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; version;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* how large is the on disk data, excluding the constant sized part */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* version dependent part */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>&nbsp; &nbsp; builder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* variable amount of TransactionIds follows */<br/></li>
<li><a id="L1575">&#x200c;</a></span>} <span class="linkable">SnapBuildOnDisk</span>;<br/></li>
<li><br/></li>
<li><a id="L1577">&#x200c;</a><span class="PreProc">#define <span class="linkable">SnapBuildOnDiskConstantSize</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; offsetof(<a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a>, builder)<br/></li>
<li><a id="L1579">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SnapBuildOnDiskNotChecksummedSize</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; offsetof(<a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a>, version)<br/></li>
<li></span><br/></li>
<li><a id="L1582">&#x200c;</a><span class="PreProc">#define <span class="linkable">SNAPBUILD_MAGIC</span> </span><span class="Constant">0x51A1E001<br/></li>
<li><a id="L1583">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SNAPBUILD_VERSION</span> </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store/Load a snapshot from disk, depending on the snapshot builder's state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Supposed to be used by external (i.e. not snapbuild.c) code that just read<br/></li>
<li></span><span class="Comment"> * a record that's a potential location for a serialized snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1592">&#x200c;</a></span><span class="linkable">SnapBuildSerializationPoint</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1845" title="replication/logical/snapbuild.c:1845">SnapBuildRestore</a>(builder, lsn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1605" title="replication/logical/snapbuild.c:1605">SnapBuildSerialize</a>(builder, lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Serialize the snapshot 'builder' at the location 'lsn' if it hasn't already<br/></li>
<li></span><span class="Comment"> * been done by another decoding process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1605">&#x200c;</a></span><span class="linkable">SnapBuildSerialize</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; needed_length;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a> *ondisk = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; TransactionId *catchange_xip = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_ctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; catchange_xcnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ondisk_c;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmppath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; Assert(builder-&gt;last_serialized_snapshot == InvalidXLogRecPtr ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;last_serialized_snapshot &lt;= lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no point in serializing if we cannot continue to work immediately after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restoring the snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* consistent snapshots have no <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase */<br/></li>
<li></span>&nbsp; &nbsp; Assert(builder-&gt;next_phase_at == InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We identify snapshots by the LSN they are valid for. We don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include timelines in the name as each LSN <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> to exactly one timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless the user used pg_resetwal or similar. If a user did so, there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no hope continuing to decode anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sprintf(path, <span class="Constant">&quot;pg_logical/snapshots/</span><span class="Special">%X</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">.snap&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first check whether some other backend already has written the snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for this LSN. It's perfectly fine if there's <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, so we <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> ENOENT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as a valid state. Everything else is an unexpected error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ret = stat(path, &amp;stat_buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ret == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * somebody else has already serialized to this point, don't overwrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but remember location, so we don't need to read old data again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To be sure it has been synced to disk after the rename() from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tempfile filename to the real filename, we just <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the fsync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That ought to be cheap because in most scenarios it should already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be safely on disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(path, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(<span class="Constant">&quot;pg_logical/snapshots&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;last_serialized_snapshot = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is an obvious race condition here between the time we stat(2) the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file and us writing the file. But we rename the file into place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atomically and all files created need to contain the same data anyway,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so this is perfectly fine, although a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a resource waste. Locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems like pointless complication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;serializing snapshot to </span><span class="Special">%s</span><span class="Constant">&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* to make sure only we will write to this tempfile, include pid */<br/></li>
<li></span>&nbsp; &nbsp; sprintf(tmppath, <span class="Constant">&quot;pg_logical/snapshots/</span><span class="Special">%X</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">.snap.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn), <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlink temporary file if it already exists, needs to have been <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crash/error since we won't enter this function twice from within a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single decoding slot/backend and the temporary file contains the pid of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlink(tmppath) != <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_ctx = MemoryContextSwitchTo(builder-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the catalog modifying transactions that are yet not committed */<br/></li>
<li></span>&nbsp; &nbsp; catchange_xip = <a href="reorderbuffer.c.html#L3409" title="replication/logical/reorderbuffer.c:3409">ReorderBufferGetCatalogChangesXacts</a>(builder-&gt;reorder);<br/></li>
<li>&nbsp; &nbsp; catchange_xcnt = dclist_count(&amp;builder-&gt;reorder-&gt;catchange_txns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; needed_length = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * (builder-&gt;committed.xcnt + catchange_xcnt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ondisk_c = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(needed_length);<br/></li>
<li>&nbsp; &nbsp; ondisk = (<a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a> *) ondisk_c;<br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;magic = <a href="#L1582" title="replication/logical/snapbuild.c:1582">SNAPBUILD_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;version = <a href="#L1583" title="replication/logical/snapbuild.c:1583">SNAPBUILD_VERSION</a>;<br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;length = needed_length;<br/></li>
<li>&nbsp; &nbsp; INIT_CRC32C(ondisk-&gt;checksum);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(ondisk-&gt;checksum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) ondisk) + <a href="#L1579" title="replication/logical/snapbuild.c:1579">SnapBuildOnDiskNotChecksummedSize</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1577" title="replication/logical/snapbuild.c:1577">SnapBuildOnDiskConstantSize</a> - <a href="#L1579" title="replication/logical/snapbuild.c:1579">SnapBuildOnDiskNotChecksummedSize</a>);<br/></li>
<li>&nbsp; &nbsp; ondisk_c += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;ondisk-&gt;builder, builder, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NULL-ify memory-only data */<br/></li>
<li></span>&nbsp; &nbsp; ondisk-&gt;builder.context = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;builder.snapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;builder.reorder = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;builder.committed.xip = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;builder.catchange.xip = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update catchange only on disk data */<br/></li>
<li></span>&nbsp; &nbsp; ondisk-&gt;builder.catchange.xcnt = catchange_xcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(ondisk-&gt;checksum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ondisk-&gt;builder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy committed xacts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;committed.xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * builder-&gt;committed.xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ondisk_c, builder-&gt;committed.xip, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(ondisk-&gt;checksum, ondisk_c, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ondisk_c += sz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy catalog modifying xacts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (catchange_xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * catchange_xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ondisk_c, catchange_xip, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(ondisk-&gt;checksum, ondisk_c, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ondisk_c += sz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(ondisk-&gt;checksum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we have valid data <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, open tempfile and write it there */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(tmppath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_CREAT | O_EXCL | O_WRONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((write(fd, ondisk, needed_length)) != needed_length)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno ? save_errno : <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fsync the file <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> renaming so that even if we crash after this we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have either a fully valid file or nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's safe to just ERROR on fsync() here because we'll retry the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation including the writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">TODO</span><span class="Comment">: Do the fsync() via checkpoints/restartpoints, doing it here has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some noticeable overhead since it's performed synchronously during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoding?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(<span class="Constant">&quot;pg_logical/snapshots&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We may overwrite the work from some other backend, but that's ok, our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot is valid as well, we'll just have done some superfluous work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rename(tmppath, path) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure we persist */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(path, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(<span class="Constant">&quot;pg_logical/snapshots&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now there's no way we can lose the dumped state anymore, remember this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as a serialization point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; builder-&gt;last_serialized_snapshot = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_ctx);<br/></li>
<li><br/></li>
<li><span class="Statement">out</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="reorderbuffer.c.html#L1057" title="replication/logical/reorderbuffer.c:1057">ReorderBufferSetRestartPoint</a>(builder-&gt;reorder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; builder-&gt;last_serialized_snapshot);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* be tidy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ondisk);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (catchange_xip)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(catchange_xip);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Restore a snapshot into 'builder' if previously one has been stored at the<br/></li>
<li></span><span class="Comment"> * location indicated by 'lsn'. Returns true if successful, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1845">&#x200c;</a></span><span class="linkable">SnapBuildRestore</span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> *builder, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1556" title="replication/logical/snapbuild.c:1556">SnapBuildOnDisk</a> ondisk;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; checksum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no point in loading a snapshot if we're already there */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;state == SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sprintf(path, <span class="Constant">&quot;pg_logical/snapshots/</span><span class="Special">%X</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">.snap&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the snapshot had been stored safely to disk, that's normally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we do not need PANIC here, nobody will be able to use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot without fsyncing, and saving it won't succeed without an fsync()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(path, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(<span class="Constant">&quot;pg_logical/snapshots&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read statically sized portion of snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2017" title="replication/logical/snapbuild.c:2017">SnapBuildRestoreContents</a>(fd, (<span class="Type">char</span> *) &amp;ondisk, <a href="#L1577" title="replication/logical/snapbuild.c:1577">SnapBuildOnDiskConstantSize</a>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk.magic != <a href="#L1582" title="replication/logical/snapbuild.c:1582">SNAPBUILD_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;snapbuild state file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has wrong magic number: </span><span class="Special">%u</span><span class="Constant"> instead of </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, ondisk.magic, <a href="#L1582" title="replication/logical/snapbuild.c:1582">SNAPBUILD_MAGIC</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk.version != <a href="#L1583" title="replication/logical/snapbuild.c:1583">SNAPBUILD_VERSION</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;snapbuild state file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has unsupported version: </span><span class="Special">%u</span><span class="Constant"> instead of </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, ondisk.version, <a href="#L1583" title="replication/logical/snapbuild.c:1583">SNAPBUILD_VERSION</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INIT_CRC32C(checksum);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(checksum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) &amp;ondisk) + <a href="#L1579" title="replication/logical/snapbuild.c:1579">SnapBuildOnDiskNotChecksummedSize</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1577" title="replication/logical/snapbuild.c:1577">SnapBuildOnDiskConstantSize</a> - <a href="#L1579" title="replication/logical/snapbuild.c:1579">SnapBuildOnDiskNotChecksummedSize</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read <a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2017" title="replication/logical/snapbuild.c:2017">SnapBuildRestoreContents</a>(fd, (<span class="Type">char</span> *) &amp;ondisk.builder, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>), path);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(checksum, &amp;ondisk.builder, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore committed xacts information */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk.builder.committed.xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * ondisk.builder.committed.xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ondisk.builder.committed.xip = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(builder-&gt;context, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2017" title="replication/logical/snapbuild.c:2017">SnapBuildRestoreContents</a>(fd, (<span class="Type">char</span> *) ondisk.builder.committed.xip, sz, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(checksum, ondisk.builder.committed.xip, sz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore catalog modifying xacts information */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk.builder.catchange.xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * ondisk.builder.catchange.xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ondisk.builder.catchange.xip = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(builder-&gt;context, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2017" title="replication/logical/snapbuild.c:2017">SnapBuildRestoreContents</a>(fd, (<span class="Type">char</span> *) ondisk.builder.catchange.xip, sz, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(checksum, ondisk.builder.catchange.xip, sz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(checksum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* verify checksum of what we've read */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!EQ_CRC32C(checksum, ondisk.checksum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;checksum mismatch for snapbuild state file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: is </span><span class="Special">%u</span><span class="Constant">, should be </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, checksum, ondisk.checksum)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ok, we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have a sensible snapshot here, figure out if it has more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information than we have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are only interested in consistent snapshots for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, comparing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether one incomplete snapshot is more &quot;advanced&quot; seems to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnecessarily complex.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk.builder.state &lt; SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> snapshot_not_interesting;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't use a snapshot that requires an xmin that we cannot guarantee to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(ondisk.builder.xmin, builder-&gt;initial_xmin_horizon))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> snapshot_not_interesting;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consistent snapshots have no <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase. Reset next_phase_at as it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible that an old value may remain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ondisk.builder.next_phase_at == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; builder-&gt;next_phase_at = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ok, we think the snapshot is sensible, copy over everything important */<br/></li>
<li></span>&nbsp; &nbsp; builder-&gt;xmin = ondisk.builder.xmin;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;xmax = ondisk.builder.xmax;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;state = ondisk.builder.state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; builder-&gt;committed.xcnt = ondisk.builder.committed.xcnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We only allocated/stored xcnt, not xcnt_space xids ! */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* don't overwrite preallocated xip, if we don't have anything here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;committed.xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(builder-&gt;committed.xip);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;committed.xcnt_space = ondisk.builder.committed.xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; builder-&gt;committed.xip = ondisk.builder.committed.xip;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ondisk.builder.committed.xip = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set catalog modifying transactions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;catchange.xip)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(builder-&gt;catchange.xip);<br/></li>
<li>&nbsp; &nbsp; builder-&gt;catchange.xcnt = ondisk.builder.catchange.xcnt;<br/></li>
<li>&nbsp; &nbsp; builder-&gt;catchange.xip = ondisk.builder.catchange.xip;<br/></li>
<li>&nbsp; &nbsp; ondisk.builder.catchange.xip = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* our snapshot is not interesting anymore, build a new one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (builder-&gt;snapshot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a>(builder-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; builder-&gt;snapshot = <a href="#L489" title="replication/logical/snapbuild.c:489">SnapBuildBuildSnapshot</a>(builder);<br/></li>
<li>&nbsp; &nbsp; <a href="#L445" title="replication/logical/snapbuild.c:445">SnapBuildSnapIncRefcount</a>(builder-&gt;snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="reorderbuffer.c.html#L1057" title="replication/logical/reorderbuffer.c:1057">ReorderBufferSetRestartPoint</a>(builder-&gt;reorder, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(builder-&gt;state == SNAPBUILD_CONSISTENT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding found consistent point at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Logical decoding will begin using saved snapshot.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">snapshot_not_interesting</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk.builder.committed.xip != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ondisk.builder.committed.xip);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ondisk.builder.catchange.xip != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ondisk.builder.catchange.xip);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the contents of the serialized snapshot to 'dest'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2017">&#x200c;</a></span><span class="linkable">SnapBuildRestoreContents</span>(<span class="Type">int</span> fd, <span class="Type">char</span> *dest, Size size, <span class="Type">const</span> <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readBytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_READ);<br/></li>
<li>&nbsp; &nbsp; readBytes = read(fd, dest, size);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (readBytes != size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, readBytes, size)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all serialized snapshots that are not required anymore because no<br/></li>
<li></span><span class="Comment"> * slot can need them. This doesn't actually have to run during a checkpoint,<br/></li>
<li></span><span class="Comment"> * but it's a convenient point to schedule this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: We run this during checkpoints even if logical decoding is disabled so<br/></li>
<li></span><span class="Comment"> * we <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> old slots at some point after it got disabled.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2054">&#x200c;</a></span><span class="linkable">CheckPointSnapBuild</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; cutoff;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; redo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *snap_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *snap_de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH + <span class="Constant">21</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We start off with a minimum of the last redo pointer. No new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication slot will start <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that, so that's a safe <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for removal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; redo = <a href="../../access/transam/xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> check for the restart ptrs from existing slots */<br/></li>
<li></span>&nbsp; &nbsp; cutoff = <a href="../slot.c.html#L1154" title="replication/slot.c:1154">ReplicationSlotsComputeLogicalRestartLSN</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't start earlier than the restart lsn */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (redo &lt; cutoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cutoff = redo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap_dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_logical/snapshots&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((snap_de = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(snap_dir, <span class="Constant">&quot;pg_logical/snapshots&quot;</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGFileType&nbsp; &nbsp; de_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(snap_de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(snap_de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), <span class="Constant">&quot;pg_logical/snapshots/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, snap_de-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; de_type = get_dirent_type(path, snap_de, <span class="Constant">false</span>, DEBUG1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (de_type != PGFILETYPE_ERROR &amp;&amp; de_type != PGFILETYPE_REG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;only regular files expected: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporary filenames from <a href="#L1605" title="replication/logical/snapbuild.c:1605">SnapBuildSerialize</a>() include the LSN and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * everything but are postfixed by .$pid.tmp. We can just remove them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same as other files because there can be <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently being written that are older than cutoff.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We just log a message if a file doesn't fit the pattern, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably some editors lock/state file or similar...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sscanf(snap_de-&gt;d_name, <span class="Constant">&quot;</span><span class="Special">%X</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">.snap&quot;</span>, &amp;hi, &amp;lo) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> file name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn = ((uint64) hi) &lt;&lt; <span class="Constant">32</span> | lo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check whether we still need it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lsn &lt; cutoff || cutoff == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;removing snapbuild snapshot </span><span class="Special">%s</span><span class="Constant">&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's not particularly harmful, though strange, if we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove the file here. Don't prevent the checkpoint from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completing, that'd be a cure worse than the disease.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(snap_dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if a logical snapshot at the specified point has been serialized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2142">&#x200c;</a></span><span class="linkable">SnapBuildSnapshotExists</span>(XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sprintf(path, <span class="Constant">&quot;pg_logical/snapshots/</span><span class="Special">%X</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">.snap&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = stat(path, &amp;stat_buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret == <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
