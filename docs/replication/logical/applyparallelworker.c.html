<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/applyparallelworker.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/applyparallelworker.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L239">MyParallelShared</a></li>
<li><a href="#L245">ParallelApplyMessagePending</a></li>
<li><a href="#L225">ParallelApplyTxnHash</a></li>
<li><a href="#L234">ParallelApplyWorkerPool</a></li>
<li><a href="#L252">stream_apply_worker</a></li>
<li><a href="#L255">subxactlist</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L215">ParallelApplyWorkerEntry</a></li>
<li><a href="#L219">ParallelApplyWorkerEntry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1001">HandleParallelApplyMessage</a></li>
<li><a href="#L989">HandleParallelApplyMessageInterrupt</a></li>
<li><a href="#L1063">HandleParallelApplyMessages</a></li>
<li><a href="#L734">LogicalParallelApplyLoop</a></li>
<li><a href="#L857">ParallelApplyWorkerMain</a></li>
<li><a href="#L712">ProcessParallelApplyInterrupts</a></li>
<li><a href="#L470">pa_allocate_worker</a></li>
<li><a href="#L265">pa_can_start</a></li>
<li><a href="#L1591">pa_decr_and_wait_stream_block</a></li>
<li><a href="#L622">pa_detach_all_error_mq</a></li>
<li><a href="#L518">pa_find_worker</a></li>
<li><a href="#L556">pa_free_worker</a></li>
<li><a href="#L595">pa_free_worker_info</a></li>
<li><a href="#L1518">pa_get_fileset_state</a></li>
<li><a href="#L1319">pa_get_xact_state</a></li>
<li><a href="#L642">pa_has_spooled_message_pending</a></li>
<li><a href="#L404">pa_launch_parallel_worker</a></li>
<li><a href="#L1540">pa_lock_stream</a></li>
<li><a href="#L1573">pa_lock_transaction</a></li>
<li><a href="#L658">pa_process_spooled_messages_if_required</a></li>
<li><a href="#L1402">pa_reset_subtrans</a></li>
<li><a href="#L1348">pa_savepoint_name</a></li>
<li><a href="#L1146">pa_send_data</a></li>
<li><a href="#L1498">pa_set_fileset_state</a></li>
<li><a href="#L1334">pa_set_stream_apply_worker</a></li>
<li><a href="#L1307">pa_set_xact_state</a></li>
<li><a href="#L327">pa_setup_dsm</a></li>
<li><a href="#L844">pa_shutdown</a></li>
<li><a href="#L1362">pa_start_subtrans</a></li>
<li><a href="#L1416">pa_stream_abort</a></li>
<li><a href="#L1211">pa_switch_to_partial_serialize</a></li>
<li><a href="#L1547">pa_unlock_stream</a></li>
<li><a href="#L1580">pa_unlock_transaction</a></li>
<li><a href="#L1274">pa_wait_for_xact_finish</a></li>
<li><a href="#L1244">pa_wait_for_xact_state</a></li>
<li><a href="#L1618">pa_xact_finish</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L195">DSM_ERROR_QUEUE_SIZE</a></li>
<li><a href="#L187">DSM_QUEUE_SIZE</a></li>
<li><a href="#L184">PARALLEL_APPLY_KEY_ERROR_QUEUE</a></li>
<li><a href="#L183">PARALLEL_APPLY_KEY_MQ</a></li>
<li><a href="#L182">PARALLEL_APPLY_KEY_SHARED</a></li>
<li><a href="#L209">PARALLEL_APPLY_LOCK_STREAM</a></li>
<li><a href="#L210">PARALLEL_APPLY_LOCK_XACT</a></li>
<li><a href="#L175">PG_LOGICAL_APPLY_SHM_MAGIC</a></li>
<li><a href="#L1168">SHM_SEND_RETRY_INTERVAL_MS</a></li>
<li><a href="#L1169">SHM_SEND_TIMEOUT_MS</a></li>
<li><a href="#L203">SIZE_STATS_MESSAGE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * applyparallelworker.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Support routines for applying xact by parallel apply worker<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2023-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/applyparallelworker.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains the code to launch, set up, and teardown a parallel apply<br/></li>
<li></span><span class="Comment"> * worker which receives the changes from the leader worker and invokes routines<br/></li>
<li></span><span class="Comment"> * to apply those on the subscriber database. Additionally, this file contains<br/></li>
<li></span><span class="Comment"> * routines that are intended to support setting up, using, and tearing down a<br/></li>
<li></span><span class="Comment"> * ParallelApplyWorkerInfo which is required so the leader worker and parallel<br/></li>
<li></span><span class="Comment"> * apply workers can communicate with each other.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The parallel apply workers are assigned (if available) as soon as xact's<br/></li>
<li></span><span class="Comment"> * first stream is received for subscriptions that have set their 'streaming'<br/></li>
<li></span><span class="Comment"> * option as parallel. The leader apply worker will <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> changes to this new<br/></li>
<li></span><span class="Comment"> * worker via shared memory. We keep this worker assigned till the transaction<br/></li>
<li></span><span class="Comment"> * commit is received and also wait for the worker to finish at commit. This<br/></li>
<li></span><span class="Comment"> * preserves commit ordering and avoid file I/O in most cases, although we<br/></li>
<li></span><span class="Comment"> * still need to spill to a file if there is no worker available. See comments<br/></li>
<li></span><span class="Comment"> * atop logical/worker to know more about streamed xacts whose changes are<br/></li>
<li></span><span class="Comment"> * spilled to disk. It is important to maintain commit order to avoid failures<br/></li>
<li></span><span class="Comment"> * due to: (a) transaction dependencies - say if we insert a row in the first<br/></li>
<li></span><span class="Comment"> * transaction and update it in the second transaction on publisher then<br/></li>
<li></span><span class="Comment"> * allowing the subscriber to apply both in parallel can lead to failure in the<br/></li>
<li></span><span class="Comment"> * update; (b) deadlocks - allowing transactions that update the same set of<br/></li>
<li></span><span class="Comment"> * rows/tables in the opposite order to be applied in parallel can lead to<br/></li>
<li></span><span class="Comment"> * deadlocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A worker pool is used to avoid restarting workers for each streaming<br/></li>
<li></span><span class="Comment"> * transaction. We maintain each worker's information (ParallelApplyWorkerInfo)<br/></li>
<li></span><span class="Comment"> * in the <a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>. After successfully launching a new worker,<br/></li>
<li></span><span class="Comment"> * its information is added to the <a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>. Once the worker<br/></li>
<li></span><span class="Comment"> * finishes applying the transaction, it is marked as available for re-use.<br/></li>
<li></span><span class="Comment"> * Now, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting a new worker to apply the streaming transaction, we<br/></li>
<li></span><span class="Comment"> * check the list for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> available worker. Note that we retain a maximum of<br/></li>
<li></span><span class="Comment"> * half the <a href="launcher.c.html#L52" title="replication/logical/launcher.c:52">max_parallel_apply_workers_per_subscription</a> workers in the pool and<br/></li>
<li></span><span class="Comment"> * after that, we simply exit the worker after applying the transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This worker pool threshold is arbitrary and we can provide a GUC<br/></li>
<li></span><span class="Comment"> * variable for this in the future if required.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The leader apply worker will create a separate dynamic shared memory segment<br/></li>
<li></span><span class="Comment"> * when each parallel apply worker starts. The reason for this design is that<br/></li>
<li></span><span class="Comment"> * we cannot predict how many workers will be needed. It may be possible to<br/></li>
<li></span><span class="Comment"> * allocate enough shared memory in one segment based on the maximum number of<br/></li>
<li></span><span class="Comment"> * parallel apply workers (<a href="launcher.c.html#L52" title="replication/logical/launcher.c:52">max_parallel_apply_workers_per_subscription</a>), but<br/></li>
<li></span><span class="Comment"> * this would waste memory if no process is actually started.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The dynamic shared memory segment contains: (a) a <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> that is used to<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> changes in the transaction from leader apply worker to parallel apply<br/></li>
<li></span><span class="Comment"> * worker; (b) another <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> that is used to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> errors (and other messages<br/></li>
<li></span><span class="Comment"> * reported via elog/ereport) from the parallel apply worker to leader apply<br/></li>
<li></span><span class="Comment"> * worker; (c) necessary information to be shared among parallel apply workers<br/></li>
<li></span><span class="Comment"> * and the leader apply worker (i.e. members of ParallelApplyWorkerShared).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Locking Considerations<br/></li>
<li></span><span class="Comment"> * ----------------------<br/></li>
<li></span><span class="Comment"> * We have a risk of deadlock due to concurrently applying the transactions in<br/></li>
<li></span><span class="Comment"> * parallel mode that were independent on the publisher side but became<br/></li>
<li></span><span class="Comment"> * dependent on the subscriber side due to the different database structures<br/></li>
<li></span><span class="Comment"> * (like schema of subscription tables, constraints, etc.) on each side. This<br/></li>
<li></span><span class="Comment"> * can happen even without parallel mode when there are concurrent operations<br/></li>
<li></span><span class="Comment"> * on the subscriber. In order to detect the deadlocks among leader (LA) and<br/></li>
<li></span><span class="Comment"> * parallel apply (PA) workers, we used lmgr locks when the PA waits for the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> stream (set of changes) and LA waits for PA to finish the transaction.<br/></li>
<li></span><span class="Comment"> * An alternative approach could be to not allow parallelism when the schema of<br/></li>
<li></span><span class="Comment"> * tables is different between the publisher and subscriber but that would be<br/></li>
<li></span><span class="Comment"> * too restrictive and would require the publisher to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> much more<br/></li>
<li></span><span class="Comment"> * information than it is currently sending.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider a case where the subscribed table does not have a unique key on the<br/></li>
<li></span><span class="Comment"> * publisher and has a unique key on the subscriber. The deadlock can happen in<br/></li>
<li></span><span class="Comment"> * the following ways:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1) Deadlock between the leader apply worker and a parallel apply worker<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider that the parallel apply worker (PA) is executing TX-1 and the<br/></li>
<li></span><span class="Comment"> * leader apply worker (LA) is executing TX-2 concurrently on the subscriber.<br/></li>
<li></span><span class="Comment"> * Now, LA is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for PA because of the unique key constraint of the<br/></li>
<li></span><span class="Comment"> * subscribed table while PA is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for LA to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> stream of<br/></li>
<li></span><span class="Comment"> * changes or transaction finish command message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In order for lmgr to detect this, we have LA acquire a session lock on the<br/></li>
<li></span><span class="Comment"> * remote transaction (by <a href="#L1540" title="replication/logical/applyparallelworker.c:1540">pa_lock_stream</a>()) and have PA wait on the lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * trying to receive the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> stream of changes. Specifically, LA will acquire<br/></li>
<li></span><span class="Comment"> * the lock in AccessExclusive mode <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending the STREAM_STOP and will<br/></li>
<li></span><span class="Comment"> * release it if already acquired after sending the STREAM_START, STREAM_ABORT<br/></li>
<li></span><span class="Comment"> * (for toplevel transaction), STREAM_PREPARE, and STREAM_COMMIT. The PA will<br/></li>
<li></span><span class="Comment"> * acquire the lock in AccessShare mode after processing STREAM_STOP and<br/></li>
<li></span><span class="Comment"> * STREAM_ABORT (for subtransaction) and then release the lock immediately<br/></li>
<li></span><span class="Comment"> * after acquiring it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The lock graph for the above example will look as follows:<br/></li>
<li></span><span class="Comment"> * LA (<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to acquire the lock on the unique index) -&gt; PA (<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to<br/></li>
<li></span><span class="Comment"> * acquire the stream lock) -&gt; LA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This way, when PA is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for LA for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> stream of changes, we can<br/></li>
<li></span><span class="Comment"> * have a wait-edge from PA to LA in lmgr, which will make us detect the<br/></li>
<li></span><span class="Comment"> * deadlock between LA and PA.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2) Deadlock between the leader apply worker and parallel apply workers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This scenario is similar to the first case but TX-1 and TX-2 are executed by<br/></li>
<li></span><span class="Comment"> * two parallel apply workers (PA-1 and PA-2 respectively). In this scenario,<br/></li>
<li></span><span class="Comment"> * PA-2 is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for PA-1 to complete its transaction while PA-1 is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment"> * for subsequent input from LA. Also, LA is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for PA-2 to complete its<br/></li>
<li></span><span class="Comment"> * transaction in order to preserve the commit order. There is a deadlock among<br/></li>
<li></span><span class="Comment"> * the three processes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In order for lmgr to detect this, we have PA acquire a session lock (this is<br/></li>
<li></span><span class="Comment"> * a different lock than referred in the previous case, see<br/></li>
<li></span><span class="Comment"> * <a href="#L1573" title="replication/logical/applyparallelworker.c:1573">pa_lock_transaction</a>()) on the transaction being applied and have LA wait on<br/></li>
<li></span><span class="Comment"> * the lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> proceeding in the transaction finish commands. Specifically,<br/></li>
<li></span><span class="Comment"> * PA will acquire this lock in AccessExclusive mode <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> executing the first<br/></li>
<li></span><span class="Comment"> * message of the transaction and release it at the xact end. LA will acquire<br/></li>
<li></span><span class="Comment"> * this lock in AccessShare mode at transaction finish commands and release it<br/></li>
<li></span><span class="Comment"> * immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The lock graph for the above example will look as follows:<br/></li>
<li></span><span class="Comment"> * LA (<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to acquire the transaction lock) -&gt; PA-2 (<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to acquire the<br/></li>
<li></span><span class="Comment"> * lock due to unique index constraint) -&gt; PA-1 (<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to acquire the stream<br/></li>
<li></span><span class="Comment"> * lock) -&gt; LA<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This way when LA is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to finish the transaction end command to preserve<br/></li>
<li></span><span class="Comment"> * the commit order, we will be able to detect deadlock, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One might think we can use <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(), but <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>()<br/></li>
<li></span><span class="Comment"> * considers PREPARED TRANSACTION as still in progress which means the lock<br/></li>
<li></span><span class="Comment"> * won't be released even after the parallel apply worker has prepared the<br/></li>
<li></span><span class="Comment"> * transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3) Deadlock when the <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> buffer is full<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the previous scenario (ie. PA-1 and PA-2 are executing transactions<br/></li>
<li></span><span class="Comment"> * concurrently), if the <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> buffer between LA and PA-2 is full, LA has to<br/></li>
<li></span><span class="Comment"> * wait to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> messages, and this wait doesn't appear in lmgr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid this wait, we use a non-blocking write and wait with a timeout. If<br/></li>
<li></span><span class="Comment"> * the timeout is exceeded, the LA will serialize all the pending messages to<br/></li>
<li></span><span class="Comment"> * a file and indicate PA-2 that it needs to read that file for the remaining<br/></li>
<li></span><span class="Comment"> * messages. Then LA will start <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for commit as in the previous case<br/></li>
<li></span><span class="Comment"> * which will detect deadlock if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. See <a href="#L1146" title="replication/logical/applyparallelworker.c:1146">pa_send_data</a>() and<br/></li>
<li></span><span class="Comment"> * enum <a href="worker.c.html#L275" title="replication/logical/worker.c:275">TransApplyAction</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock types<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> * Both the stream lock and the transaction lock mentioned above are<br/></li>
<li></span><span class="Comment"> * session-level locks because both locks could be acquired outside the<br/></li>
<li></span><span class="Comment"> * transaction, and the stream lock in the leader needs to persist across<br/></li>
<li></span><span class="Comment"> * transaction boundaries i.e. until the end of the streaming transaction.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqmq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicallauncher.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/worker_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L175">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_LOGICAL_APPLY_SHM_MAGIC</span> </span><span class="Constant">0x787ca067<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * DSM keys for parallel apply worker. Unlike other parallel execution code,<br/></li>
<li></span><span class="Comment"> * since we don't need to worry about DSM keys conflicting with plan_node_id we<br/></li>
<li></span><span class="Comment"> * can use small integers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_APPLY_KEY_SHARED</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L183">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_APPLY_KEY_MQ</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L184">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_APPLY_KEY_ERROR_QUEUE</span>&nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Queue size of DSM, 16 MB for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSM_QUEUE_SIZE</span>&nbsp; &nbsp; (</span><span class="Constant">16</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error queue size of DSM. It is desirable to make it large enough that a<br/></li>
<li></span><span class="Comment"> * typical ErrorResponse can be sent without blocking. That way, a worker that<br/></li>
<li></span><span class="Comment"> * errors out can write the whole message into the queue and terminate without<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the user backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L195">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSM_ERROR_QUEUE_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">16</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * There are three fields in each message received by the parallel apply<br/></li>
<li></span><span class="Comment"> * worker: start_lsn, end_lsn and send_time. Because we have updated these<br/></li>
<li></span><span class="Comment"> * statistics in the leader apply worker, we can ignore these fields in the<br/></li>
<li></span><span class="Comment"> * parallel apply worker (see function <a href="worker.c.html#L3478" title="replication/logical/worker.c:3478">LogicalRepApplyLoop</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L203">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIZE_STATS_MESSAGE</span> (</span><span class="Constant">2</span><span class="PreProc"> * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(XLogRecPtr) + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(TimestampTz))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The type of session-level lock on a transaction being applied on a logical<br/></li>
<li></span><span class="Comment"> * replication subscriber.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L209">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_APPLY_LOCK_STREAM</span>&nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_APPLY_LOCK_XACT</span>&nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash table entry to map xid to the parallel apply worker state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L215">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ParallelApplyWorkerEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hash key -- must be first */<br/></li>
<li></span>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li><a id="L219">&#x200c;</a>} <span class="linkable">ParallelApplyWorkerEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table used to cache the state of streaming transactions being applied<br/></li>
<li></span><span class="Comment"> * by the parallel apply workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L225">&#x200c;</a></span><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">ParallelApplyTxnHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">* A list (pool) of active parallel apply workers. The information for<br/></li>
<li></span><span class="Comment">* the new worker is added to the list after successfully launching it. The<br/></li>
<li></span><span class="Comment">* list entry is removed if there are already enough workers in the worker<br/></li>
<li></span><span class="Comment">* pool at the end of the transaction. For more information about the worker<br/></li>
<li></span><span class="Comment">* pool, see comments atop this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L234">&#x200c;</a></span><span class="Type">static</span> List *<span class="linkable">ParallelApplyWorkerPool</span> = NIL;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Information shared between leader apply worker and parallel apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L239">&#x200c;</a></span>ParallelApplyWorkerShared *<span class="linkable">MyParallelShared</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is there a message sent by a parallel apply worker that the leader apply<br/></li>
<li></span><span class="Comment"> * worker needs to receive?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L245">&#x200c;</a></span><span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">ParallelApplyMessagePending</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache the parallel apply worker information required for applying the<br/></li>
<li></span><span class="Comment"> * current streaming transaction. It is used to save the cost of searching the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table when applying the changes between STREAM_START and STREAM_STOP.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L252">&#x200c;</a></span><span class="Type">static</span> ParallelApplyWorkerInfo *<span class="linkable">stream_apply_worker</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* A list to maintain subtransactions, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li><a id="L255">&#x200c;</a></span><span class="Type">static</span> List *<span class="linkable">subxactlist</span> = NIL;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L595" title="replication/logical/applyparallelworker.c:595">pa_free_worker_info</a>(ParallelApplyWorkerInfo *winfo);<br/></li>
<li><span class="Type">static</span> ParallelTransState <a href="#L1319" title="replication/logical/applyparallelworker.c:1319">pa_get_xact_state</a>(ParallelApplyWorkerShared *wshared);<br/></li>
<li><span class="Type">static</span> PartialFileSetState <a href="#L1518" title="replication/logical/applyparallelworker.c:1518">pa_get_fileset_state</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if it is OK to start a parallel apply worker, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L265">&#x200c;</a></span><span class="linkable">pa_can_start</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only leader apply workers can start parallel apply workers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!am_leader_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is good to check for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> change in the subscription parameter to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid the case where for a very long time the change doesn't get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reflected. This can happen when there is a constant flow of streaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions that are handled by parallel apply workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is better to do it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the below checks so that the latest <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of subscription can be used for the checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="worker.c.html#L3862" title="replication/logical/worker.c:3862">maybe_reread_subscription</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't start a new parallel apply worker if the subscription is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using parallel streaming mode, or if the publisher does not support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel apply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;parallel_apply)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't start a new parallel worker if user has set skiplsn as it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible that they want to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the streaming transaction. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming transactions, we need to serialize the transaction to a file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that we can get the last LSN of the transaction to judge whether to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting to apply the change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * One might think that we could allow parallelism if the first lsn of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction is greater than skiplsn, but we don't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * STREAM START message, and it doesn't seem worth sending the extra eight<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bytes with the STREAM START to enable parallelism for this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;skiplsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For streaming transactions that are being applied using a parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply worker, we cannot decide whether to apply the change for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation that is not in the READY state (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="worker.c.html#L468" title="replication/logical/worker.c:468">should_apply_changes_for_rel</a>) as we won't know <a href="worker.c.html#L304" title="replication/logical/worker.c:304">remote_final_lsn</a> by that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time. So, we don't start the new parallel apply worker in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="tablesync.c.html#L1731" title="replication/logical/tablesync.c:1731">AllTablesyncsReady</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up a dynamic shared memory segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set up a control region that contains a fixed-size worker info<br/></li>
<li></span><span class="Comment"> * (ParallelApplyWorkerShared), a message queue, and an error queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L327">&#x200c;</a></span><span class="linkable">pa_setup_dsm</span>(ParallelApplyWorkerInfo *winfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimator e;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; segsize;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a>&nbsp; &nbsp; *toc;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerShared *shared;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; queue_size = <a href="#L187" title="replication/logical/applyparallelworker.c:187">DSM_QUEUE_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; error_queue_size = <a href="#L195" title="replication/logical/applyparallelworker.c:195">DSM_ERROR_QUEUE_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate how much shared memory we need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because the TOC machinery may choose to insert padding of oddly-sized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requests, we must estimate each chunk separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need one key to register the location of the header, and two other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys to track the locations of the message queue and the error message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_initialize_estimator(&amp;e);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;e, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelApplyWorkerShared));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;e, queue_size);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;e, error_queue_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;e, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; segsize = <a href="../../storage/ipc/shm_toc.c.html#L263" title="storage/ipc/shm_toc.c:263">shm_toc_estimate</a>(&amp;e);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the shared memory segment and establish a table of contents. */<br/></li>
<li></span>&nbsp; &nbsp; seg = <a href="../../storage/ipc/dsm.c.html#L516" title="storage/ipc/dsm.c:516">dsm_create</a>(<a href="../../storage/ipc/shm_toc.c.html#L263" title="storage/ipc/shm_toc.c:263">shm_toc_estimate</a>(&amp;e), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!seg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; toc = <a href="../../storage/ipc/shm_toc.c.html#L40" title="storage/ipc/shm_toc.c:40">shm_toc_create</a>(<a href="#L175" title="replication/logical/applyparallelworker.c:175">PG_LOGICAL_APPLY_SHM_MAGIC</a>, <a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(seg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the header region. */<br/></li>
<li></span>&nbsp; &nbsp; shared = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(toc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelApplyWorkerShared));<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;shared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shared-&gt;xact_state = PARALLEL_TRANS_UNKNOWN;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u32(&amp;(shared-&gt;pending_stream_count), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; shared-&gt;last_commit_end = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; shared-&gt;fileset_state = FS_EMPTY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(toc, <a href="#L182" title="replication/logical/applyparallelworker.c:182">PARALLEL_APPLY_KEY_SHARED</a>, shared);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up message queue for the worker. */<br/></li>
<li></span>&nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_mq.c.html#L177" title="storage/ipc/shm_mq.c:177">shm_mq_create</a>(<a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(toc, queue_size), queue_size);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(toc, <a href="#L183" title="replication/logical/applyparallelworker.c:183">PARALLEL_APPLY_KEY_MQ</a>, mq);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L224" title="storage/ipc/shm_mq.c:224">shm_mq_set_sender</a>(mq, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach the queue. */<br/></li>
<li></span>&nbsp; &nbsp; winfo-&gt;mq_handle = <a href="../../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, seg, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up error queue for the worker. */<br/></li>
<li></span>&nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_mq.c.html#L177" title="storage/ipc/shm_mq.c:177">shm_mq_create</a>(<a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(toc, error_queue_size),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; error_queue_size);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(toc, <a href="#L184" title="replication/logical/applyparallelworker.c:184">PARALLEL_APPLY_KEY_ERROR_QUEUE</a>, mq);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L206" title="storage/ipc/shm_mq.c:206">shm_mq_set_receiver</a>(mq, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach the queue. */<br/></li>
<li></span>&nbsp; &nbsp; winfo-&gt;error_mq_handle = <a href="../../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, seg, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return results to caller. */<br/></li>
<li></span>&nbsp; &nbsp; winfo-&gt;dsm_seg = seg;<br/></li>
<li>&nbsp; &nbsp; winfo-&gt;shared = shared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to get a parallel apply worker from the pool. If <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> is available then<br/></li>
<li></span><span class="Comment"> * start a new one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ParallelApplyWorkerInfo *<br/></li>
<li><a id="L404">&#x200c;</a><span class="linkable">pa_launch_parallel_worker</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; launched;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to get an available parallel apply worker from the worker pool. */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, <a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winfo = (ParallelApplyWorkerInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!winfo-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> winfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start a new parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The worker info can be used for the lifetime of the worker process, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create it in a permanent context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="worker.c.html#L291" title="replication/logical/worker.c:291">ApplyContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; winfo = (ParallelApplyWorkerInfo *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelApplyWorkerInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L327" title="replication/logical/applyparallelworker.c:327">pa_setup_dsm</a>(winfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(winfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; launched = <a href="launcher.c.html#L300" title="replication/logical/launcher.c:300">logicalrep_worker_launch</a>(WORKERTYPE_PARALLEL_APPLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;dbid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>(winfo-&gt;dsm_seg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (launched)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>, winfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L595" title="replication/logical/applyparallelworker.c:595">pa_free_worker_info</a>(winfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> winfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a parallel apply worker that will be used for the specified xid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We first try to get an available worker from the pool, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> and then try<br/></li>
<li></span><span class="Comment"> * to launch a new worker. On successful allocation, remember the worker<br/></li>
<li></span><span class="Comment"> * information in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table so that we can get it later for processing the<br/></li>
<li></span><span class="Comment"> * streaming changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L470">&#x200c;</a></span><span class="linkable">pa_allocate_worker</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L215" title="replication/logical/applyparallelworker.c:215">ParallelApplyWorkerEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L265" title="replication/logical/applyparallelworker.c:265">pa_can_start</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; winfo = <a href="#L404" title="replication/logical/applyparallelworker.c:404">pa_launch_parallel_worker</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!winfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First time through, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> parallel apply worker state hashtable. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L225" title="replication/logical/applyparallelworker.c:225">ParallelApplyTxnHash</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;ctl, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ctl));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L215" title="replication/logical/applyparallelworker.c:215">ParallelApplyWorkerEntry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.hcxt = <a href="worker.c.html#L291" title="replication/logical/worker.c:291">ApplyContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L225" title="replication/logical/applyparallelworker.c:225">ParallelApplyTxnHash</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;logical replication parallel apply workers <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">16</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create an entry for the requested transaction. */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L225" title="replication/logical/applyparallelworker.c:225">ParallelApplyTxnHash</a>, &amp;xid, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the transaction information in shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;winfo-&gt;shared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; winfo-&gt;shared-&gt;xact_state = PARALLEL_TRANS_UNKNOWN;<br/></li>
<li>&nbsp; &nbsp; winfo-&gt;shared-&gt;xid = xid;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;winfo-&gt;shared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; winfo-&gt;in_use = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; winfo-&gt;serialize_changes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;winfo = winfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the assigned worker for the given transaction, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParallelApplyWorkerInfo *<br/></li>
<li><a id="L518">&#x200c;</a><span class="linkable">pa_find_worker</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <a href="#L215" title="replication/logical/applyparallelworker.c:215">ParallelApplyWorkerEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L225" title="replication/logical/applyparallelworker.c:225">ParallelApplyTxnHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the cached parallel apply worker if valid. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L252" title="replication/logical/applyparallelworker.c:252">stream_apply_worker</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L252" title="replication/logical/applyparallelworker.c:252">stream_apply_worker</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find an entry for the requested transaction. */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L225" title="replication/logical/applyparallelworker.c:225">ParallelApplyTxnHash</a>, &amp;xid, HASH_FIND, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The worker must not have exited.&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(entry-&gt;winfo-&gt;in_use);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry-&gt;winfo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Makes the worker available for reuse.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This removes the parallel apply worker entry from the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table so that it<br/></li>
<li></span><span class="Comment"> * can't be used. If there are enough workers in the pool, it stops the worker<br/></li>
<li></span><span class="Comment"> * and frees the corresponding info. Otherwise it just marks the worker as<br/></li>
<li></span><span class="Comment"> * available for reuse.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For more information about the worker pool, see comments atop this file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L556">&#x200c;</a></span><span class="linkable">pa_free_worker</span>(ParallelApplyWorkerInfo *winfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!am_parallel_apply_worker());<br/></li>
<li>&nbsp; &nbsp; Assert(winfo-&gt;in_use);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1319" title="replication/logical/applyparallelworker.c:1319">pa_get_xact_state</a>(winfo-&gt;shared) == PARALLEL_TRANS_FINISHED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L225" title="replication/logical/applyparallelworker.c:225">ParallelApplyTxnHash</a>, &amp;winfo-&gt;shared-&gt;xid, HASH_REMOVE, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stop the worker if there are enough workers in the pool.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Additionally, we also stop the worker if the leader apply worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serialize part of the transaction data due to a <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> timeout. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the message could be partially written to the queue and there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is no way to clean the queue other than resending the message until it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * succeeds. Instead of trying to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the data which anyway would have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been serialized and then letting the parallel apply worker deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the spurious message, we stop the worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winfo-&gt;serialize_changes ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list_length(<a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>) &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="launcher.c.html#L52" title="replication/logical/launcher.c:52">max_parallel_apply_workers_per_subscription</a> / <span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L633" title="replication/logical/launcher.c:633">logicalrep_pa_worker_stop</a>(winfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L595" title="replication/logical/applyparallelworker.c:595">pa_free_worker_info</a>(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; winfo-&gt;in_use = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; winfo-&gt;serialize_changes = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free the parallel apply worker information and unlink the files with<br/></li>
<li></span><span class="Comment"> * serialized changes if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L595">&#x200c;</a></span><span class="linkable">pa_free_worker_info</span>(ParallelApplyWorkerInfo *winfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winfo-&gt;mq_handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(winfo-&gt;mq_handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winfo-&gt;error_mq_handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(winfo-&gt;error_mq_handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlink the files with serialized changes. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winfo-&gt;serialize_changes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="worker.c.html#L4205" title="replication/logical/worker.c:4205">stream_cleanup_files</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, winfo-&gt;shared-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (winfo-&gt;dsm_seg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(winfo-&gt;dsm_seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove from the worker pool. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a> = <a href="../../nodes/list.c.html#L872" title="nodes/list.c:872">list_delete_ptr</a>(<a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>, winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(winfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach the error queue for all parallel apply workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L622">&#x200c;</a></span><span class="linkable">pa_detach_all_error_mq</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParallelApplyWorkerInfo *winfo = (ParallelApplyWorkerInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (winfo-&gt;error_mq_handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(winfo-&gt;error_mq_handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winfo-&gt;error_mq_handle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending spooled messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L642">&#x200c;</a></span><span class="linkable">pa_has_spooled_message_pending</span>()<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartialFileSetState fileset_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fileset_state = <a href="#L1518" title="replication/logical/applyparallelworker.c:1518">pa_get_fileset_state</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (fileset_state != FS_EMPTY);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replay the spooled messages once the leader apply worker has finished<br/></li>
<li></span><span class="Comment"> * serializing changes to the file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if there aren't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending spooled messages, true otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L658">&#x200c;</a></span><span class="linkable">pa_process_spooled_messages_if_required</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartialFileSetState fileset_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fileset_state = <a href="#L1518" title="replication/logical/applyparallelworker.c:1518">pa_get_fileset_state</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fileset_state == FS_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the leader apply worker is busy serializing the partial changes then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquire the stream lock <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and wait for the leader worker to finish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serializing the changes. Otherwise, the parallel apply worker won't get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a chance to receive a STREAM_STOP (and acquire the stream lock) until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the leader had serialized all changes which can lead to undetected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the fileset state can be FS_SERIALIZE_DONE once the leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker has finished serializing the changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fileset_state == FS_SERIALIZE_IN_PROGRESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1540" title="replication/logical/applyparallelworker.c:1540">pa_lock_stream</a>(<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;xid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="replication/logical/applyparallelworker.c:1547">pa_unlock_stream</a>(<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;xid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fileset_state = <a href="#L1518" title="replication/logical/applyparallelworker.c:1518">pa_get_fileset_state</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot read the file immediately after the leader has serialized all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes to the file because there may still be messages in the memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queue. We will apply all spooled messages the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time we call this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function and that will ensure there are no messages left in the memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fileset_state == FS_SERIALIZE_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1498" title="replication/logical/applyparallelworker.c:1498">pa_set_fileset_state</a>(<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>, FS_READY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fileset_state == FS_READY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="worker.c.html#L2001" title="replication/logical/worker.c:2001">apply_spooled_messages</a>(&amp;<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;fileset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1498" title="replication/logical/applyparallelworker.c:1498">pa_set_fileset_state</a>(<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>, FS_EMPTY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interrupt handler for <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop of parallel apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L712">&#x200c;</a></span><span class="linkable">ProcessParallelApplyInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication parallel apply worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has finished&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Parallel apply worker <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L734">&#x200c;</a></span><span class="linkable">LogicalParallelApplyLoop</span>(<a href="../../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; shm_mq_result shmq_res;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Init the <a href="worker.c.html#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a> which we clean up after each replication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protocol message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="worker.c.html#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a> = AllocSetContextCreate(<a href="worker.c.html#L291" title="replication/logical/worker.c:291">ApplyContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="worker.c.html#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Push apply error context callback. Fields will be filled while applying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="worker.c.html#L4893" title="replication/logical/worker.c:4893">apply_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L712" title="replication/logical/applyparallelworker.c:712">ProcessParallelApplyInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure we are reading the data into our memory context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="worker.c.html#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shmq_res = <a href="../../storage/ipc/shm_mq.c.html#L572" title="storage/ipc/shm_mq.c:572">shm_mq_receive</a>(mqh, &amp;len, &amp;data, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shmq_res == SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid message length&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;s, data, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first byte of messages sent from leader apply worker to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel apply workers can only be 'w'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c != <span class="Constant">'w'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected message </span><span class="Special">\&quot;%c\&quot;</span><span class="Constant">&quot;</span>, c);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore statistics fields that have been updated by the leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> We can avoid sending the statistics fields from the leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * apply worker but for that, it needs to rebuild the entire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message by removing these fields which could be more work than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simply ignoring these fields in the parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.cursor += <a href="#L203" title="replication/logical/applyparallelworker.c:203">SIZE_STATS_MESSAGE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="worker.c.html#L3272" title="replication/logical/worker.c:3272">apply_dispatch</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (shmq_res == SHM_MQ_WOULD_BLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replay the changes from the file, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L658" title="replication/logical/applyparallelworker.c:658">pa_process_spooled_messages_if_required</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for more work. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1000L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_LOGICAL_PARALLEL_APPLY_MAIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(shmq_res == SHM_MQ_DETACHED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lost connection to the logical replication apply worker&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="worker.c.html#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure the leader apply worker tries to read from our error queue one more<br/></li>
<li></span><span class="Comment"> * time. This guards against the case where we exit uncleanly without sending<br/></li>
<li></span><span class="Comment"> * an ErrorResponse, for example because some code calls <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> directly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also explicitly detach from dsm segment to invoke <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a> callbacks,<br/></li>
<li></span><span class="Comment"> * if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. See <a href="../../access/transam/parallel.c.html#L1567" title="access/transam/parallel.c:1567">ParallelWorkerShutdown</a> for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L844">&#x200c;</a></span><span class="linkable">pa_shutdown</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;leader_pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCSIG_PARALLEL_APPLY_MESSAGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>((<a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *) DatumGetPointer(arg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parallel apply worker entry point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L857">&#x200c;</a></span><span class="linkable">ParallelApplyWorkerMain</span>(Datum main_arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerShared *shared;<br/></li>
<li>&nbsp; &nbsp; dsm_handle&nbsp; &nbsp; handle;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a>&nbsp; &nbsp; *toc;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *error_mqh;<br/></li>
<li>&nbsp; &nbsp; RepOriginId originid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker_slot = DatumGetInt32(main_arg);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; originname[NAMEDATALEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="worker.c.html#L318" title="replication/logical/worker.c:318">InitializingApplyWorker</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup signal handling. */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="../../postmaster/interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="../../postmaster/interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L4229" title="postmaster/postmaster.c:4229">BackgroundWorkerUnblockSignals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach to the dynamic shared memory segment for the parallel apply, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> its table of contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Like parallel query, we don't need resource owner by this time. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/parallel.c.html#L1271" title="access/transam/parallel.c:1271">ParallelWorkerMain</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(&amp;handle, <a href="../../postmaster/postmaster.c.html#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a>-&gt;bgw_extra, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsm_handle));<br/></li>
<li>&nbsp; &nbsp; seg = <a href="../../storage/ipc/dsm.c.html#L665" title="storage/ipc/dsm.c:665">dsm_attach</a>(handle);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!seg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not map dynamic shared memory segment&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; toc = <a href="../../storage/ipc/shm_toc.c.html#L64" title="storage/ipc/shm_toc.c:64">shm_toc_attach</a>(<a href="#L175" title="replication/logical/applyparallelworker.c:175">PG_LOGICAL_APPLY_SHM_MAGIC</a>, <a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(seg));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!toc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid magic number in dynamic shared memory segment&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the shared information. */<br/></li>
<li></span>&nbsp; &nbsp; shared = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L182" title="replication/logical/applyparallelworker.c:182">PARALLEL_APPLY_KEY_SHARED</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a> = shared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach to the message queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L183" title="replication/logical/applyparallelworker.c:183">PARALLEL_APPLY_KEY_MQ</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L206" title="storage/ipc/shm_mq.c:206">shm_mq_set_receiver</a>(mq, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; mqh = <a href="../../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, seg, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Primary initialization is complete. Now, we can attach to our slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is to ensure that the leader apply worker does not write data to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the uninitialized memory queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="launcher.c.html#L707" title="replication/logical/launcher.c:707">logicalrep_worker_attach</a>(worker_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register the shutdown callback after we are attached to the worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot. This is to ensure that <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a> remains valid when this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callback is invoked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L844" title="replication/logical/applyparallelworker.c:844">pa_shutdown</a>, PointerGetDatum(seg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;logicalrep_worker_generation = <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;generation;<br/></li>
<li>&nbsp; &nbsp; <a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;logicalrep_worker_slot_no = worker_slot;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach to the error queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L184" title="replication/logical/applyparallelworker.c:184">PARALLEL_APPLY_KEY_ERROR_QUEUE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L224" title="storage/ipc/shm_mq.c:224">shm_mq_set_sender</a>(mq, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; error_mqh = <a href="../../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, seg, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqmq.c.html#L53" title="libpq/pqmq.c:53">pq_redirect_to_shm_mq</a>(seg, error_mqh);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqmq.c.html#L78" title="libpq/pqmq.c:78">pq_set_parallel_leader</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;leader_pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;last_send_time = <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;last_recv_time =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;reply_time = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="worker.c.html#L4561" title="replication/logical/worker.c:4561">InitializeLogRepWorker</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="worker.c.html#L318" title="replication/logical/worker.c:318">InitializingApplyWorker</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup replication origin tracking. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="worker.c.html#L428" title="replication/logical/worker.c:428">ReplicationOriginNameForLogicalRep</a>(<a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; originname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(originname));<br/></li>
<li>&nbsp; &nbsp; originid = <a href="origin.c.html#L221" title="replication/logical/origin.c:221">replorigin_by_name</a>(originname, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parallel apply worker doesn't need to monopolize this replication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * origin which was already acquired by its leader process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="origin.c.html#L1097" title="replication/logical/origin.c:1097">replorigin_session_setup</a>(originid, <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;leader_pid);<br/></li>
<li>&nbsp; &nbsp; <a href="origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> = originid;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup callback for syscache so that we know when something changes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the subscription relation state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(SUBSCRIPTIONRELMAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tablesync.c.html#L281" title="replication/logical/tablesync.c:281">invalidate_syncing_table_states</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="worker.c.html#L5035" title="replication/logical/worker.c:5035">set_apply_error_context_origin</a>(originname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L734" title="replication/logical/applyparallelworker.c:734">LogicalParallelApplyLoop</a>(mqh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parallel apply worker must not get here because the parallel apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker will only stop when it receives a SIGTERM or SIGINT from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader, or when there is an error. None of these cases will allow the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code to reach here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle receipt of an interrupt indicating a parallel apply worker message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is called within a signal handler! All we can do is set a flag<br/></li>
<li></span><span class="Comment"> * that will cause the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> CHECK_FOR_INTERRUPTS() to invoke<br/></li>
<li></span><span class="Comment"> * <a href="#L1063" title="replication/logical/applyparallelworker.c:1063">HandleParallelApplyMessages</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L989">&#x200c;</a></span><span class="linkable">HandleParallelApplyMessageInterrupt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L245" title="replication/logical/applyparallelworker.c:245">ParallelApplyMessagePending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle a single protocol message received from a single parallel apply<br/></li>
<li></span><span class="Comment"> * worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1001">&#x200c;</a></span><span class="linkable">HandleParallelApplyMessage</span>(StringInfo msg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msgtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; msgtype = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (msgtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'E'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ErrorResponse */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorData&nbsp; &nbsp; edata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse ErrorResponse. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqmq.c.html#L216" title="libpq/pqmq.c:216">pq_parse_errornotice</a>(msg, &amp;edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If desired, add a context line to show that this is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message propagated from a parallel apply worker. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it can sometimes be confusing to understand what actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata.context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata.context = psprintf(<span class="Constant">&quot;</span><span class="Special">%s\n%s</span><span class="Constant">&quot;</span>, edata.context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;logical replication parallel apply worker&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata.context = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;logical replication parallel apply worker&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Context beyond that should use the error context callbacks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that were in effect in <a href="worker.c.html#L3478" title="replication/logical/worker.c:3478">LogicalRepApplyLoop</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <a href="worker.c.html#L288" title="replication/logical/worker.c:288">apply_error_context_stack</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The actual error must have been reported by the parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication parallel apply worker exited due to error&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errcontext(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, edata.context)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't need to do anything about NoticeResponse and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NotifyResponse as the logical replication worker doesn't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> messages to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'N'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'A'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized message type received from logical replication parallel apply worker: </span><span class="Special">%c</span><span class="Constant"> (message length </span><span class="Special">%d</span><span class="Constant"> bytes)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msgtype, msg-&gt;len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> queued protocol messages received from parallel apply workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1063">&#x200c;</a></span><span class="linkable">HandleParallelApplyMessages</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> MemoryContext hpam_context = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is invoked from <a href="../../tcop/postgres.c.html#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>(), and since some of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> it calls contain CHECK_FOR_INTERRUPTS(), there is a potential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for recursive calls if more signals are received while this runs. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unclear that recursive entry would be safe, and it doesn't seem useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even if it is safe, so let's block interrupts until done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Moreover, <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> might be pointing almost anywhere. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want to risk leaking data into long-lived contexts, so let's do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our work here in a private context that we can reset on each use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!hpam_context)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first time through? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hpam_context = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L1063" title="replication/logical/applyparallelworker.c:1063">HandleParallelApplyMessages</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(hpam_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(hpam_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L245" title="replication/logical/applyparallelworker.c:245">ParallelApplyMessagePending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="#L234" title="replication/logical/applyparallelworker.c:234">ParallelApplyWorkerPool</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_mq_result res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParallelApplyWorkerInfo *winfo = (ParallelApplyWorkerInfo *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The leader will detach from the error queue and set it to NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> preparing to stop all parallel apply workers, so we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to handle error messages anymore. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="launcher.c.html#L744" title="replication/logical/launcher.c:744">logicalrep_worker_detach</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!winfo-&gt;error_mq_handle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../storage/ipc/shm_mq.c.html#L572" title="storage/ipc/shm_mq.c:572">shm_mq_receive</a>(winfo-&gt;error_mq_handle, &amp;nbytes, &amp;data, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == SHM_MQ_WOULD_BLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (res == SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;msg, data, nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1001" title="replication/logical/applyparallelworker.c:1001">HandleParallelApplyMessage</a>(&amp;msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(msg.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lost connection to the logical replication parallel apply worker&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Might as well clear the context on our way out */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(hpam_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send the data to the specified parallel apply worker via shared-memory<br/></li>
<li></span><span class="Comment"> * queue.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if the attempt to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data via shared memory times out, true<br/></li>
<li></span><span class="Comment"> * otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1146">&#x200c;</a></span><span class="linkable">pa_send_data</span>(ParallelApplyWorkerInfo *winfo, Size nbytes, <span class="Type">const</span> <span class="Type">void</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; shm_mq_result result;<br/></li>
<li>&nbsp; &nbsp; TimestampTz startTime = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li>&nbsp; &nbsp; Assert(!winfo-&gt;serialize_changes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't try to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data to parallel worker for 'immediate' mode. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is primarily used for testing purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(<a href="reorderbuffer.c.html#L216" title="replication/logical/reorderbuffer.c:216">debug_logical_replication_streaming</a> == DEBUG_LOGICAL_REP_STREAMING_IMMEDIATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This timeout is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> arbitrary but testing revealed that it is sufficient<br/></li>
<li></span><span class="Comment"> * to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the message unless the parallel apply worker is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on some<br/></li>
<li></span><span class="Comment"> * lock or there is a serious resource crunch. See the comments atop this file<br/></li>
<li></span><span class="Comment"> * to know why we are using a non-blocking way to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1168">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SHM_SEND_RETRY_INTERVAL_MS</span> </span><span class="Constant">1000<br/></li>
<li><a id="L1169">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SHM_SEND_TIMEOUT_MS</span>&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">10000</span><span class="PreProc"> - <a href="#L1168" title="replication/logical/applyparallelworker.c:1168">SHM_SEND_RETRY_INTERVAL_MS</a>)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../storage/ipc/shm_mq.c.html#L329" title="storage/ipc/shm_mq.c:329">shm_mq_send</a>(winfo-&gt;mq_handle, nbytes, data, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result == SHM_MQ_DETACHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data to shared-memory queue&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result == SHM_MQ_WOULD_BLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> retrying. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1168" title="replication/logical/applyparallelworker.c:1168">SHM_SEND_RETRY_INTERVAL_MS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_LOGICAL_APPLY_SEND_DATA);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startTime == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startTime = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(startTime, <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1169" title="replication/logical/applyparallelworker.c:1169">SHM_SEND_TIMEOUT_MS</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Switch to PARTIAL_SERIALIZE mode for the current transaction -- this means<br/></li>
<li></span><span class="Comment"> * that the current data and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent data for this transaction will be<br/></li>
<li></span><span class="Comment"> * serialized to a file. This is done to prevent possible deadlocks with<br/></li>
<li></span><span class="Comment"> * another parallel apply worker (refer to the comments atop this file).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1211">&#x200c;</a></span><span class="linkable">pa_switch_to_partial_serialize</span>(ParallelApplyWorkerInfo *winfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> stream_locked)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication apply worker will serialize the remaining changes of remote transaction </span><span class="Special">%u</span><span class="Constant"> to a file&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; winfo-&gt;shared-&gt;xid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parallel apply worker could be stuck for some reason (say <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on some lock by other backend), so stop trying to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data directly to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it and start serializing data to the file instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; winfo-&gt;serialize_changes = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the stream fileset. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="worker.c.html#L1429" title="replication/logical/worker.c:1429">stream_start_internal</a>(winfo-&gt;shared-&gt;xid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquires the stream lock if not already to make sure that the parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply worker will wait for the leader to release the stream lock until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end of the transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!stream_locked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1540" title="replication/logical/applyparallelworker.c:1540">pa_lock_stream</a>(winfo-&gt;shared-&gt;xid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1498" title="replication/logical/applyparallelworker.c:1498">pa_set_fileset_state</a>(winfo-&gt;shared, FS_SERIALIZE_IN_PROGRESS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait until the parallel apply worker's transaction state has reached or<br/></li>
<li></span><span class="Comment"> * exceeded the given xact_state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1244">&#x200c;</a></span><span class="linkable">pa_wait_for_xact_state</span>(ParallelApplyWorkerInfo *winfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelTransState xact_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Stop if the transaction state has reached or exceeded the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xact_state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1319" title="replication/logical/applyparallelworker.c:1319">pa_get_xact_state</a>(winfo-&gt;shared) &gt;= xact_state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait to be signalled. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">10L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_LOGICAL_PARALLEL_APPLY_STATE_CHANGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the latch so we don't spin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* An interrupt may have occurred while we were <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait until the parallel apply worker's transaction finishes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1274">&#x200c;</a></span><span class="linkable">pa_wait_for_xact_finish</span>(ParallelApplyWorkerInfo *winfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait until the parallel apply worker set the state to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PARALLEL_TRANS_STARTED which means it has acquired the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock. This is to prevent leader apply worker from acquiring the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction lock earlier than the parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1244" title="replication/logical/applyparallelworker.c:1244">pa_wait_for_xact_state</a>(winfo, PARALLEL_TRANS_STARTED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for the transaction lock to be released. This is required to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect deadlock among leader and parallel apply workers. Refer to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments atop this file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1573" title="replication/logical/applyparallelworker.c:1573">pa_lock_transaction</a>(winfo-&gt;shared-&gt;xid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1580" title="replication/logical/applyparallelworker.c:1580">pa_unlock_transaction</a>(winfo-&gt;shared-&gt;xid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the state becomes PARALLEL_TRANS_FINISHED in case the parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply worker failed while applying changes causing the lock to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1319" title="replication/logical/applyparallelworker.c:1319">pa_get_xact_state</a>(winfo-&gt;shared) != PARALLEL_TRANS_FINISHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lost connection to the logical replication parallel apply worker&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the transaction state for a given parallel apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1307">&#x200c;</a></span><span class="linkable">pa_set_xact_state</span>(ParallelApplyWorkerShared *wshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelTransState xact_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;wshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; wshared-&gt;xact_state = xact_state;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;wshared-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the transaction state for a given parallel apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ParallelTransState<br/></li>
<li><a id="L1319">&#x200c;</a><span class="linkable">pa_get_xact_state</span>(ParallelApplyWorkerShared *wshared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelTransState xact_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;wshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; xact_state = wshared-&gt;xact_state;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;wshared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xact_state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache the parallel apply worker information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1334">&#x200c;</a></span><span class="linkable">pa_set_stream_apply_worker</span>(ParallelApplyWorkerInfo *winfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L252" title="replication/logical/applyparallelworker.c:252">stream_apply_worker</a> = winfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form a unique savepoint name for the streaming transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that different subscriptions for publications on different nodes can<br/></li>
<li></span><span class="Comment"> * receive same remote xid, so we need to use subscription id along with it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the name in the supplied buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1348">&#x200c;</a></span><span class="linkable">pa_savepoint_name</span>(Oid suboid, TransactionId xid, <span class="Type">char</span> *spname, Size szsp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; snprintf(spname, szsp, <span class="Constant">&quot;pg_sp_</span><span class="Special">%u</span><span class="Constant"><a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%u</span><span class="Constant">&quot;</span>, suboid, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Define a savepoint for a subxact in parallel apply worker if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The parallel apply worker can figure out if a new subtransaction was<br/></li>
<li></span><span class="Comment"> * started by checking if the new change arrived with a different xid. In that<br/></li>
<li></span><span class="Comment"> * case define a named savepoint, so that we are able to rollback to it<br/></li>
<li></span><span class="Comment"> * if required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1362">&#x200c;</a></span><span class="linkable">pa_start_subtrans</span>(TransactionId current_xid, TransactionId top_xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (current_xid != top_xid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/list.c.html#L742" title="nodes/list.c:742">list_member_xid</a>(<a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a>, current_xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; spname[NAMEDATALEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1348" title="replication/logical/applyparallelworker.c:1348">pa_savepoint_name</a>(<a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, current_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(spname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;defining savepoint </span><span class="Special">%s</span><span class="Constant"> in logical replication parallel apply worker&quot;</span>, spname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must be in transaction block to define the SAVEPOINT. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3873" title="access/transam/xact.c:3873">BeginTransactionBlock</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a>(spname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> is needed to start a subtransaction after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * issuing a SAVEPOINT inside a transaction block (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a> = <a href="../../nodes/list.c.html#L393" title="nodes/list.c:393">lappend_xid</a>(<a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a>, current_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Reset the list that maintains subtransactions. */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1402">&#x200c;</a></span><span class="linkable">pa_reset_subtrans</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to free this explicitly as the allocated memory will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freed at the transaction end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a> = NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle STREAM ABORT message when the transaction was applied in a parallel<br/></li>
<li></span><span class="Comment"> * apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1416">&#x200c;</a></span><span class="linkable">pa_stream_abort</span>(LogicalRepStreamAbortData *abort_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = abort_data-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; TransactionId subxid = abort_data-&gt;subxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update origin state so we can restart streaming from correct position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case of crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = abort_data-&gt;abort_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = abort_data-&gt;abort_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the two XIDs are the same, it's in fact abort of toplevel xact, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just free the <a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subxid == xid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1307" title="replication/logical/applyparallelworker.c:1307">pa_set_xact_state</a>(<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>, PARALLEL_TRANS_FINISHED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release the lock as we might be processing an empty streaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction in which case the lock won't be released during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction rollback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that it's ok to release the transaction lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> aborting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the transaction because even if the parallel apply worker dies due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to crash or some other reason, such a transaction would still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * considered aborted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1580" title="replication/logical/applyparallelworker.c:1580">pa_unlock_transaction</a>(xid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1402" title="replication/logical/applyparallelworker.c:1402">pa_reset_subtrans</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, so it's a subxact. Rollback to the savepoint. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; spname[NAMEDATALEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1348" title="replication/logical/applyparallelworker.c:1348">pa_savepoint_name</a>(<a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, subxid, spname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(spname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;rolling back to savepoint </span><span class="Special">%s</span><span class="Constant"> in logical replication parallel apply worker&quot;</span>, spname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Search the <a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a>, determine the offset tracked for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subxact, and truncate the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that for an empty sub-transaction we won't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the subxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = list_length(<a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a>) - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid_tmp = lfirst_xid(list_nth_cell(<a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a>, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xid_tmp == subxid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4516" title="access/transam/xact.c:4516">RollbackToSavepoint</a>(spname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a> = <a href="../../nodes/list.c.html#L631" title="nodes/list.c:631">list_truncate</a>(<a href="#L255" title="replication/logical/applyparallelworker.c:255">subxactlist</a>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the fileset state for a particular parallel apply worker. The fileset<br/></li>
<li></span><span class="Comment"> * will be set once the leader worker serialized all changes to the file<br/></li>
<li></span><span class="Comment"> * so that it can be used by parallel apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1498">&#x200c;</a></span><span class="linkable">pa_set_fileset_state</span>(ParallelApplyWorkerShared *wshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PartialFileSetState fileset_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;wshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; wshared-&gt;fileset_state = fileset_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fileset_state == FS_SERIALIZE_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(am_leader_apply_worker());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wshared-&gt;fileset = *<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;wshared-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the fileset state for the current parallel apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PartialFileSetState<br/></li>
<li><a id="L1518">&#x200c;</a><span class="linkable">pa_get_fileset_state</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartialFileSetState fileset_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(am_parallel_apply_worker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; fileset_state = <a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;fileset_state;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fileset_state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to acquire and release a lock for each stream block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set locktag_field4 to <a href="#L209" title="replication/logical/applyparallelworker.c:209">PARALLEL_APPLY_LOCK_STREAM</a> to indicate that it's a<br/></li>
<li></span><span class="Comment"> * stream lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Refer to the comments atop this file to see how the stream lock is used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1540">&#x200c;</a></span><span class="linkable">pa_lock_stream</span>(TransactionId xid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1203" title="storage/lmgr/lmgr.c:1203">LockApplyTransactionForSession</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L209" title="replication/logical/applyparallelworker.c:209">PARALLEL_APPLY_LOCK_STREAM</a>, lockmode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1547">&#x200c;</a></span><span class="linkable">pa_unlock_stream</span>(TransactionId xid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1221" title="storage/lmgr/lmgr.c:1221">UnlockApplyTransactionForSession</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L209" title="replication/logical/applyparallelworker.c:209">PARALLEL_APPLY_LOCK_STREAM</a>, lockmode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to acquire and release a lock for each local transaction<br/></li>
<li></span><span class="Comment"> * apply.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set locktag_field4 to <a href="#L210" title="replication/logical/applyparallelworker.c:210">PARALLEL_APPLY_LOCK_XACT</a> to indicate that it's a<br/></li>
<li></span><span class="Comment"> * transaction lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that all the callers must pass a remote transaction ID instead of a<br/></li>
<li></span><span class="Comment"> * local transaction ID as xid. This is because the local transaction ID will<br/></li>
<li></span><span class="Comment"> * only be assigned while applying the first change in the parallel apply but<br/></li>
<li></span><span class="Comment"> * it's possible that the first change in the parallel apply worker is blocked<br/></li>
<li></span><span class="Comment"> * by a concurrently executing transaction in another parallel apply worker. We<br/></li>
<li></span><span class="Comment"> * can only communicate the local transaction id to the leader after applying<br/></li>
<li></span><span class="Comment"> * the first change so it won't be able to wait after sending the xact finish<br/></li>
<li></span><span class="Comment"> * command using this lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Refer to the comments atop this file to see how the transaction lock is<br/></li>
<li></span><span class="Comment"> * used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1573">&#x200c;</a></span><span class="linkable">pa_lock_transaction</span>(TransactionId xid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1203" title="storage/lmgr/lmgr.c:1203">LockApplyTransactionForSession</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L210" title="replication/logical/applyparallelworker.c:210">PARALLEL_APPLY_LOCK_XACT</a>, lockmode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1580">&#x200c;</a></span><span class="linkable">pa_unlock_transaction</span>(TransactionId xid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1221" title="storage/lmgr/lmgr.c:1221">UnlockApplyTransactionForSession</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L210" title="replication/logical/applyparallelworker.c:210">PARALLEL_APPLY_LOCK_XACT</a>, lockmode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decrement the number of pending streaming blocks and wait on the stream lock<br/></li>
<li></span><span class="Comment"> * if there is no pending block available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1591">&#x200c;</a></span><span class="linkable">pa_decr_and_wait_stream_block</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(am_parallel_apply_worker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is only possible to not have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending stream chunks when we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applying spooled messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_read_u32(&amp;<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;pending_stream_count) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L642" title="replication/logical/applyparallelworker.c:642">pa_has_spooled_message_pending</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid pending streaming chunk 0&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_sub_fetch_u32(&amp;<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;pending_stream_count, <span class="Constant">1</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1540" title="replication/logical/applyparallelworker.c:1540">pa_lock_stream</a>(<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;xid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1547" title="replication/logical/applyparallelworker.c:1547">pa_unlock_stream</a>(<a href="#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;xid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish processing the streaming transaction in the leader apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1618">&#x200c;</a></span><span class="linkable">pa_xact_finish</span>(ParallelApplyWorkerInfo *winfo, XLogRecPtr remote_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(am_leader_apply_worker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlock the shared object lock so that parallel apply worker can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continue to receive and apply changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1547" title="replication/logical/applyparallelworker.c:1547">pa_unlock_stream</a>(winfo-&gt;shared-&gt;xid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for that worker to finish. This is necessary to maintain commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order which avoids failures due to transaction dependencies and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1274" title="replication/logical/applyparallelworker.c:1274">pa_wait_for_xact_finish</a>(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(remote_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="worker.c.html#L3436" title="replication/logical/worker.c:3436">store_flush_position</a>(remote_lsn, winfo-&gt;shared-&gt;last_commit_end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L556" title="replication/logical/applyparallelworker.c:556">pa_free_worker</a>(winfo);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
