<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/origin.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/origin.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L166">replication_states</a></li>
<li><a href="#L171">replication_states_ctl</a></li>
<li><a href="#L155">replorigin_session_origin</a></li>
<li><a href="#L156">replorigin_session_origin_lsn</a></li>
<li><a href="#L157">replorigin_session_origin_timestamp</a></li>
<li><a href="#L179">session_replication_state</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L101">ReplicationState</a></li>
<li><a href="#L134">ReplicationState</a></li>
<li><a href="#L146">ReplicationStateCtl</a></li>
<li><a href="#L152">ReplicationStateCtl</a></li>
<li><a href="#L139">ReplicationStateOnDisk</a></li>
<li><a href="#L143">ReplicationStateOnDisk</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L573">CheckPointReplicationOrigin</a></li>
<li><a href="#L204">IsReservedOriginName</a></li>
<li><a href="#L1055">ReplicationOriginExitCleanup</a></li>
<li><a href="#L526">ReplicationOriginShmemInit</a></li>
<li><a href="#L506">ReplicationOriginShmemSize</a></li>
<li><a href="#L699">StartupReplicationOrigin</a></li>
<li><a href="#L1456">pg_replication_origin_advance</a></li>
<li><a href="#L1269">pg_replication_origin_create</a></li>
<li><a href="#L1310">pg_replication_origin_drop</a></li>
<li><a href="#L1329">pg_replication_origin_oid</a></li>
<li><a href="#L1491">pg_replication_origin_progress</a></li>
<li><a href="#L1389">pg_replication_origin_session_is_setup</a></li>
<li><a href="#L1405">pg_replication_origin_session_progress</a></li>
<li><a href="#L1372">pg_replication_origin_session_reset</a></li>
<li><a href="#L1350">pg_replication_origin_session_setup</a></li>
<li><a href="#L1444">pg_replication_origin_xact_reset</a></li>
<li><a href="#L1426">pg_replication_origin_xact_setup</a></li>
<li><a href="#L1516">pg_show_replication_origin_status</a></li>
<li><a href="#L888">replorigin_advance</a></li>
<li><a href="#L221">replorigin_by_name</a></li>
<li><a href="#L465">replorigin_by_oid</a></li>
<li><a href="#L185">replorigin_check_prerequisites</a></li>
<li><a href="#L252">replorigin_create</a></li>
<li><a href="#L411">replorigin_drop_by_name</a></li>
<li><a href="#L1014">replorigin_get_progress</a></li>
<li><a href="#L827">replorigin_redo</a></li>
<li><a href="#L1219">replorigin_session_advance</a></li>
<li><a href="#L1237">replorigin_session_get_progress</a></li>
<li><a href="#L1190">replorigin_session_reset</a></li>
<li><a href="#L1097">replorigin_session_setup</a></li>
<li><a href="#L341">replorigin_state_clear</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1520">REPLICATION_ORIGIN_PROGRESS_COLS</a></li>
<li><a href="#L1581">REPLICATION_ORIGIN_PROGRESS_COLS</a></li>
<li><a href="#L182">REPLICATION_STATE_MAGIC</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * origin.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Logical replication progress tracking support.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2013-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/origin.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file provides the following:<br/></li>
<li></span><span class="Comment"> * * An infrastructure to name nodes in a replication setup<br/></li>
<li></span><span class="Comment"> * * A facility to efficiently store and persist replication progress in an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; efficient and durable manner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Replication origin consist out of a descriptive, user defined, external<br/></li>
<li></span><span class="Comment"> * name and a short, thus space efficient, <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> 2 byte one. This split<br/></li>
<li></span><span class="Comment"> * exists because replication origin have to be stored in WAL and shared<br/></li>
<li></span><span class="Comment"> * memory and long descriptors would be inefficient.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> only use 2 bytes<br/></li>
<li></span><span class="Comment"> * for the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> id of a replication origin as it seems unlikely that there<br/></li>
<li></span><span class="Comment"> * soon will be more than 65k nodes in one replication setup; and using only<br/></li>
<li></span><span class="Comment"> * two bytes allow us to be more space efficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Replication progress is tracked in a shared memory table<br/></li>
<li></span><span class="Comment"> * (<a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a>) that's dumped to disk every checkpoint. Entries<br/></li>
<li></span><span class="Comment"> * ('slots') in this table are identified by the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> id. That's the case<br/></li>
<li></span><span class="Comment"> * because it allows to increase replication progress during crash<br/></li>
<li></span><span class="Comment"> * recovery. To allow doing so we store the original LSN (from the originating<br/></li>
<li></span><span class="Comment"> * system) of a transaction in the commit record. That allows to recover the<br/></li>
<li></span><span class="Comment"> * precise replayed state after crash recovery; without requiring synchronous<br/></li>
<li></span><span class="Comment"> * commits. Allowing logical replication to use asynchronous commit is<br/></li>
<li></span><span class="Comment"> * generally good for performance, but especially important as it allows a<br/></li>
<li></span><span class="Comment"> * single threaded replay process to keep up with a source that has multiple<br/></li>
<li></span><span class="Comment"> * backends generating changes concurrently.&nbsp; For efficiency and simplicity<br/></li>
<li></span><span class="Comment"> * reasons a backend can setup one replication origin that's from then used as<br/></li>
<li></span><span class="Comment"> * the source of changes produced by the backend, until reset again.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This infrastructure is intended to be used in cooperation with logical<br/></li>
<li></span><span class="Comment"> * decoding. When replaying from a remote system the configured origin is<br/></li>
<li></span><span class="Comment"> * provided to output plugins, allowing prevention of replication loops and<br/></li>
<li></span><span class="Comment"> * other filtering.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are several levels of locking at work:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * To create and drop replication origins an exclusive lock on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; pg_replication_slot is required for the duration. That allows us to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; safely and conflict free assign new origins using a dirty snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * When creating an in-memory replication progress slot the ReplicationOrigin<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; LWLock has to be held exclusively; when iterating over the replication<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; progress a shared lock has to be held, the same when advancing the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; replication progress of an individual backend that has not setup as the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; session's replication origin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * When manipulating or looking at the remote_lsn and local_lsn fields of a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; replication progress slot that slot's lwlock has to be held. That's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; primarily because we do not assume 8 byte writes (the LSN) is atomic on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; all our platforms, but it also simplifies memory ordering concerns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; between the remote and local lsn. We use a lwlock instead of a spinlock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; so it's less harmful to hold the lock over a WAL write<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; (cf. AdvanceReplicationProgress).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replay progress of a single remote node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L101">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReplicationState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Local identifier for the remote node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RepOriginId roident;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Location of the latest commit from the remote side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the local lsn of the commit record so we can <a href="../../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>() to it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during a checkpoint so we know the commit record actually is safe on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; local_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PID of backend that's acquired slot, or 0 if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; acquired_by;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Condition variable that's signaled when acquired_by changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ConditionVariable origin_cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock protecting remote_lsn and local_lsn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp; &nbsp; lock;<br/></li>
<li><a id="L134">&#x200c;</a>} <span class="linkable">ReplicationState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On disk version of <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReplicationStateOnDisk</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RepOriginId roident;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_lsn;<br/></li>
<li><a id="L143">&#x200c;</a>} <span class="linkable">ReplicationStateOnDisk</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L146">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReplicationStateCtl</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tranche to use for per-origin LWLocks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tranche_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Array of length <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> states[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L152">&#x200c;</a>} <span class="linkable">ReplicationStateCtl</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* external variables */<br/></li>
<li><a id="L155">&#x200c;</a></span>RepOriginId <span class="linkable">replorigin_session_origin</span> = InvalidRepOriginId; <span class="Comment">/* assumed identity */<br/></li>
<li><a id="L156">&#x200c;</a></span>XLogRecPtr&nbsp; &nbsp; <span class="linkable">replorigin_session_origin_lsn</span> = InvalidXLogRecPtr;<br/></li>
<li><a id="L157">&#x200c;</a>TimestampTz <span class="linkable">replorigin_session_origin_timestamp</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Base address into a shared memory array of replication states of size<br/></li>
<li></span><span class="Comment"> * <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: Should we use a separate variable to size this rather than<br/></li>
<li></span><span class="Comment"> * <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="Type">static</span> <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *<span class="linkable">replication_states</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Actual shared memory block (<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[] is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> part of this).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L171">&#x200c;</a></span><span class="Type">static</span> <a href="#L146" title="replication/logical/origin.c:146">ReplicationStateCtl</a> *<span class="linkable">replication_states_ctl</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We keep a pointer to this backend's <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> to avoid having to<br/></li>
<li></span><span class="Comment"> * search the <a href="#L166" title="replication/logical/origin.c:166">replication_states</a> array in <a href="#L1219" title="replication/logical/origin.c:1219">replorigin_session_advance</a> for each<br/></li>
<li></span><span class="Comment"> * remote commit.&nbsp; (Ownership of a backend's own entry can only be changed by<br/></li>
<li></span><span class="Comment"> * that backend.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L179">&#x200c;</a></span><span class="Type">static</span> <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *<span class="linkable">session_replication_state</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Magic for on disk files. */<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">REPLICATION_STATE_MAGIC</span> ((uint32) </span><span class="Constant">0x1257DADE</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="linkable">replorigin_check_prerequisites</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> check_slots, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recoveryOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (check_slots &amp;&amp; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot query or manipulate replication origin when <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> = 0&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!recoveryOK &amp;&amp; <a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_READ_ONLY_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot manipulate replication origins during recovery&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L204" title="replication/logical/origin.c:204">IsReservedOriginName</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff name is either &quot;<a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>&quot; or &quot;<a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L204">&#x200c;</a></span><span class="linkable">IsReservedOriginName</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((pg_strcasecmp(name, LOGICALREP_ORIGIN_NONE) == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (pg_strcasecmp(name, LOGICALREP_ORIGIN_ANY) == <span class="Constant">0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Functions for working with replication origins themselves.<br/></li>
<li></span><span class="Comment"> * ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check for a persistent replication origin identified by name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if the node isn't known yet and missing_ok is true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RepOriginId<br/></li>
<li><a id="L221">&#x200c;</a><span class="linkable">replorigin_by_name</span>(<span class="Type">const</span> <span class="Type">char</span> *roname, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_replication_origin ident;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roident = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; roname_d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; roname_d = CStringGetTextDatum(roname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(REPLORIGNAME, roname_d);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ident = (Form_pg_replication_origin) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; roident = ident-&gt;roident;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> roident;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a replication origin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needs to be called in a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RepOriginId<br/></li>
<li><a id="L252">&#x200c;</a><span class="linkable">replorigin_create</span>(<span class="Type">const</span> <span class="Type">char</span> *roname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roident;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; roname_d;<br/></li>
<li>&nbsp; &nbsp; SnapshotData SnapshotDirty;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; roname_d = CStringGetTextDatum(roname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the <a href="../../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> replication origin to be 16bit wide, so we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rely on the normal oid allocation. Instead we simply scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_replication_origin for the first unused id. That's not particularly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficient, but this should be a fairly infrequent operation - we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easily spend a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more code on this when it turns out it needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * faster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We handle concurrency by taking an exclusive lock (allowing reads!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over the table for the duration of the search. Because we use a &quot;dirty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot&quot; we can read rows that other in-progress sessions have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written, even though they would be invisible with normal snapshots. Due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the exclusive lock there's no danger that new rows can appear while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InitDirtySnapshot(SnapshotDirty);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ReplicationOriginRelationId, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (roident = InvalidOid + <span class="Constant">1</span>; roident &lt; PG_UINT16_MAX; roident++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Natts_pg_replication_origin];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Natts_pg_replication_origin];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collides;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_replication_origin_roident,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(roident));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(rel, ReplicationOriginIdentIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span> <span class="Comment">/* indexOK */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;SnapshotDirty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, &amp;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collides = HeapTupleIsValid(<a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!collides)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ok, found an unused roident, insert the new row and do a CCI,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so our callers can look it up if they want to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;nulls, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nulls));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_replication_origin_roident - <span class="Constant">1</span>] = ObjectIdGetDatum(roident);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_replication_origin_roname - <span class="Constant">1</span>] = roname_d;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(RelationGetDescr(rel), <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>(rel, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> release lock again,&nbsp; &nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> free replication origin ID&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> roident;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function to drop a replication origin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="linkable">replorigin_state_clear</span>(RepOriginId roident, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up the slot state info, if there is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *state = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;roident == roident)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found our slot, is it busy? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;acquired_by != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConditionVariable *cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_IN_USE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not drop replication origin with ID </span><span class="Special">%d</span><span class="Constant">, in use by PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;roident,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;acquired_by)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must wait and then retry.&nbsp; Since we don't know which CV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to wait on until here, we can't readily use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a> (calling it here would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrong, since we could <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> the signal if we did so); just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use <a href="../../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a> directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cv = &amp;state-&gt;origin_cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(cv, WAIT_EVENT_REPLICATION_ORIGIN_DROP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first make a WAL log entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_replorigin_drop xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.node_id = roident;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlrec));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_REPLORIGIN_ID, XLOG_REPLORIGIN_DROP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* then clear the in-memory slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;roident = InvalidRepOriginId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;remote_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;local_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop replication origin (by name).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needs to be called in a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L411">&#x200c;</a></span><span class="linkable">replorigin_drop_by_name</span>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RepOriginId roident;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ReplicationOriginRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; roident = <a href="#L221" title="replication/logical/origin.c:221">replorigin_by_name</a>(name, missing_ok);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock the origin to prevent concurrent drops. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1083" title="storage/lmgr/lmgr.c:1083">LockSharedObject</a>(ReplicationOriginRelationId, roident, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(REPLORIGIDENT, ObjectIdGetDatum(roident));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for replication origin with ID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; roident);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to retain the locks if the origin is already dropped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1142" title="storage/lmgr/lmgr.c:1142">UnlockSharedObject</a>(ReplicationOriginRelationId, roident, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L341" title="replication/logical/origin.c:341">replorigin_state_clear</a>(roident, nowait);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, we can delete the catalog entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/indexing.c.html#L365" title="catalog/indexing.c:365">CatalogTupleDelete</a>(rel, &amp;tuple-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We keep the lock on pg_replication_origin until commit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lookup replication origin via its oid and return the name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The external name is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the calling context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the origin is known, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L465">&#x200c;</a></span><span class="linkable">replorigin_by_oid</span>(RepOriginId roident, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok, <span class="Type">char</span> **roname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_replication_origin ric;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid((Oid) roident));<br/></li>
<li>&nbsp; &nbsp; Assert(roident != InvalidRepOriginId);<br/></li>
<li>&nbsp; &nbsp; Assert(roident != DoNotReplicateId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(REPLORIGIDENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum((Oid) roident));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ric = (Form_pg_replication_origin) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *roname = <a href="../../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(&amp;ric-&gt;roname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *roname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication origin with ID </span><span class="Special">%d</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roident)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Functions for handling replication progress.<br/></li>
<li></span><span class="Comment"> * ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Size<br/></li>
<li><a id="L506">&#x200c;</a><span class="linkable">ReplicationOriginShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> is arguably the wrong thing to use, as here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we keep the replay state of *remote* transactions. But for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficient to reuse it, rather than introduce a separate GUC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, offsetof(<a href="#L146" title="replication/logical/origin.c:146">ReplicationStateCtl</a>, states));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L526">&#x200c;</a></span><span class="linkable">ReplicationOriginShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L171" title="replication/logical/origin.c:171">replication_states_ctl</a> = (<a href="#L146" title="replication/logical/origin.c:146">ReplicationStateCtl</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;ReplicationOriginState&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L506" title="replication/logical/origin.c:506">ReplicationOriginShmemSize</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="replication/logical/origin.c:166">replication_states</a> = <a href="#L171" title="replication/logical/origin.c:171">replication_states_ctl</a>-&gt;states;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(<a href="#L171" title="replication/logical/origin.c:171">replication_states_ctl</a>, <span class="Constant">0</span>, <a href="#L506" title="replication/logical/origin.c:506">ReplicationOriginShmemSize</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L171" title="replication/logical/origin.c:171">replication_states_ctl</a>-&gt;tranche_id = LWTRANCHE_REPLICATION_ORIGIN_STATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i].lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L171" title="replication/logical/origin.c:171">replication_states_ctl</a>-&gt;tranche_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i].origin_cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Perform a checkpoint of each replication origin's progress with respect to<br/></li>
<li></span><span class="Comment"> * the replayed remote_lsn. Make sure that all transactions we refer to in the<br/></li>
<li></span><span class="Comment"> * checkpoint (local_lsn) are actually on-disk. This might not yet be the case<br/></li>
<li></span><span class="Comment"> * if the transactions were originally committed asynchronously.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We store checkpoints in the following format:<br/></li>
<li></span><span class="Comment"> * +-------+------------------------+------------------+-----+--------+<br/></li>
<li></span><span class="Comment"> * | MAGIC | <a href="#L139" title="replication/logical/origin.c:139">ReplicationStateOnDisk</a> | struct Replic... | ... | CRC32C | EOF<br/></li>
<li></span><span class="Comment"> * +-------+------------------------+------------------+-----+--------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * So its just the magic, followed by the statically sized<br/></li>
<li></span><span class="Comment"> * <a href="#L139" title="replication/logical/origin.c:139">ReplicationStateOnDisk</a> structs. Note that the maximum number of<br/></li>
<li></span><span class="Comment"> * <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> is determined by <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>.<br/></li>
<li></span><span class="Comment"> * ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L573">&#x200c;</a></span><span class="linkable">CheckPointReplicationOrigin</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tmppath = <span class="Constant">&quot;pg_logical/replorigin_checkpoint.tmp&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *path = <span class="Constant">&quot;pg_logical/replorigin_checkpoint&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpfd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; magic = <a href="#L182" title="replication/logical/origin.c:182">REPLICATION_STATE_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; crc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INIT_CRC32C(crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure no old temp file is remaining */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlink(tmppath) &lt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no other backend can perform this at the same time; only one checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can happen at a time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmpfd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(tmppath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; O_CREAT | O_EXCL | O_WRONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tmpfd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write magic */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((write(tmpfd, &amp;magic, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic))) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(crc, &amp;magic, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent concurrent creations/drops */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write actual data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="replication/logical/origin.c:139">ReplicationStateOnDisk</a> disk_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *curstate = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; local_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curstate-&gt;roident == InvalidRepOriginId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* zero, to avoid uninitialized padding bytes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;disk_state, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;curstate-&gt;lock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; disk_state.roident = curstate-&gt;roident;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; disk_state.remote_lsn = curstate-&gt;remote_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_lsn = curstate-&gt;local_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;curstate-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we only write out a commit that's persistent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(local_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((write(tmpfd, &amp;disk_state, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state))) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(crc, &amp;disk_state, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write out the CRC */<br/></li>
<li></span>&nbsp; &nbsp; FIN_CRC32C(crc);<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((write(tmpfd, &amp;crc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(crc))) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(crc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(tmpfd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fsync, rename to permanent file, fsync file and directory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(tmppath, path, PANIC);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recover replication replay status from checkpoint data saved earlier by<br/></li>
<li></span><span class="Comment"> * <a href="#L573" title="replication/logical/origin.c:573">CheckPointReplicationOrigin</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This only needs to be called at startup and *not* during every checkpoint<br/></li>
<li></span><span class="Comment"> * read during recovery (e.g. in HS or PITR from a base backup) afterwards. All<br/></li>
<li></span><span class="Comment"> * state thereafter can be recovered by looking at commit <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L699">&#x200c;</a></span><span class="linkable">StartupReplicationOrigin</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *path = <span class="Constant">&quot;pg_logical/replorigin_checkpoint&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readBytes;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; magic = <a href="#L182" title="replication/logical/origin.c:182">REPLICATION_STATE_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_state = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; file_crc;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; crc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't want to overwrite already existing state */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> already_started = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!already_started);<br/></li>
<li>&nbsp; &nbsp; already_started = <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INIT_CRC32C(crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;starting up replication origin progress state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might have had <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> == 0 last run, or we just brought<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up a standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* verify magic, that is written even if nothing was active */<br/></li>
<li></span>&nbsp; &nbsp; readBytes = read(fd, &amp;magic, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (readBytes != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, readBytes, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(crc, &amp;magic, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(magic));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (magic != <a href="#L182" title="replication/logical/origin.c:182">REPLICATION_STATE_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication checkpoint has wrong magic </span><span class="Special">%u</span><span class="Constant"> instead of </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic, <a href="#L182" title="replication/logical/origin.c:182">REPLICATION_STATE_MAGIC</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> locking here, no other access is possible */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* recover individual states, until there are no more to be found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="replication/logical/origin.c:139">ReplicationStateOnDisk</a> disk_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readBytes = read(fd, &amp;disk_state, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no further data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes == <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(crc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not pretty, but simple ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file_crc = *(pg_crc32c *) &amp;disk_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, readBytes, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(crc, &amp;disk_state, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(disk_state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_state == <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> free replication state, increase <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy data to shared memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[last_state].roident = disk_state.roident;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[last_state].remote_lsn = disk_state.remote_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_state++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovered replication state of node </span><span class="Special">%d</span><span class="Constant"> to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disk_state.roident,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(disk_state.remote_lsn))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> check checksum */<br/></li>
<li></span>&nbsp; &nbsp; FIN_CRC32C(crc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file_crc != crc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication slot checkpoint has wrong checksum </span><span class="Special">%u</span><span class="Constant">, expected </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; crc, file_crc)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L827">&#x200c;</a></span><span class="linkable">replorigin_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_REPLORIGIN_SET:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_replorigin_set *xlrec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xl_replorigin_set *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L888" title="replication/logical/origin.c:888">replorigin_advance</a>(xlrec-&gt;node_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;remote_lsn, record-&gt;EndRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;force <span class="Comment">/* backward */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span> <span class="Comment">/* WAL log */</span> );<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_REPLORIGIN_DROP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_replorigin_drop *xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec = (xl_replorigin_drop *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *state = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found our slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;roident == xlrec-&gt;node_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;roident = InvalidRepOriginId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;remote_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;local_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L827" title="replication/logical/origin.c:827">replorigin_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tell the replication origin progress machinery that a commit from 'node'<br/></li>
<li></span><span class="Comment"> * that originated at the LSN remote_commit on the remote node was replayed<br/></li>
<li></span><span class="Comment"> * successfully and that we don't need to do so again. In combination with<br/></li>
<li></span><span class="Comment"> * setting up <a href="#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> and <a href="#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a><br/></li>
<li></span><span class="Comment"> * that ensures we won't lose knowledge about that after a crash if the<br/></li>
<li></span><span class="Comment"> * transaction had a persistent effect (think of asynchronous commits).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * local_commit needs to be a local LSN of the commit so that we can make sure<br/></li>
<li></span><span class="Comment"> * upon a checkpoint that enough WAL has been persisted to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needs to be called with a RowExclusiveLock on pg_replication_origin,<br/></li>
<li></span><span class="Comment"> * unless running in recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L888">&#x200c;</a></span><span class="linkable">replorigin_advance</span>(RepOriginId node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr remote_commit, XLogRecPtr local_commit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> go_backward, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wal_log)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *replication_state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *free_state = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(node != InvalidRepOriginId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't track DoNotReplicateId */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node == DoNotReplicateId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: For the case where this is called by WAL replay, it'd be more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficient to restore into a backend local hashtable and only <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shmem after recovery is finished. Let's wait with implementing that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * till it's shown to be a measurable expense<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock exclusively, as we may have to create a new table entry. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search for either an existing slot for the origin, or a free one we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *curstate = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember where to insert if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curstate-&gt;roident == InvalidRepOriginId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_state = curstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not our slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curstate-&gt;roident != node)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, found slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; replication_state = curstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;replication_state-&gt;lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure it's not used by somebody else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (replication_state-&gt;acquired_by != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_IN_USE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication origin with ID </span><span class="Special">%d</span><span class="Constant"> is already active for PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replication_state-&gt;roident,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replication_state-&gt;acquired_by)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replication_state == <span class="Constant">NULL</span> &amp;&amp; free_state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> free replication state slot for replication origin with ID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Increase <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> and try again.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replication_state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> new slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;free_state-&gt;lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replication_state = free_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(replication_state-&gt;remote_lsn == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(replication_state-&gt;local_lsn == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replication_state-&gt;roident = node;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(replication_state-&gt;roident != InvalidRepOriginId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If somebody &quot;forcefully&quot; sets this slot, WAL log it, so it's durable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the standby gets the message. Primarily this will be called during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL replay (of commit <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>) where no WAL logging is necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wal_log)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_replorigin_set xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.remote_lsn = remote_commit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.node_id = node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.force = go_backward;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlrec));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_REPLORIGIN_ID, XLOG_REPLORIGIN_SET);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Due to - harmless - race conditions during a checkpoint we could see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> here that are older than the ones we already have in memory. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could also see older <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for prepared transactions when the prepare<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is sent at a later point of time along with commit prepared and there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are other transactions commits between prepare and commit prepared. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="reorderbuffer.c.html#L2817" title="replication/logical/reorderbuffer.c:2817">ReorderBufferFinishPrepared</a>. Don't overwrite those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (go_backward || replication_state-&gt;remote_lsn &lt; remote_commit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replication_state-&gt;remote_lsn = remote_commit;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (local_commit != InvalidXLogRecPtr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (go_backward || replication_state-&gt;local_lsn &lt; local_commit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replication_state-&gt;local_lsn = local_commit;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;replication_state-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release *after* changing the LSNs, slot isn't acquired and thus could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise be dropped anytime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>XLogRecPtr<br/></li>
<li><a id="L1014">&#x200c;</a><span class="linkable">replorigin_get_progress</span>(RepOriginId node, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> flush)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; local_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_lsn = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent slots from being concurrently dropped */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;roident == node)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;state-&gt;lock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_lsn = state-&gt;remote_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_lsn = state-&gt;local_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;state-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flush &amp;&amp; local_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(local_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> remote_lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tear down a (possibly) configured session replication origin during process<br/></li>
<li></span><span class="Comment"> * exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1055">&#x200c;</a></span><span class="linkable">ReplicationOriginExitCleanup</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ConditionVariable *cv = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;acquired_by == <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cv = &amp;<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;origin_cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;acquired_by = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cv)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Setup a replication origin in the shared memory struct if it doesn't<br/></li>
<li></span><span class="Comment"> * already exist and cache access to the specific ReplicationSlot so the<br/></li>
<li></span><span class="Comment"> * array doesn't have to be searched when calling<br/></li>
<li></span><span class="Comment"> * <a href="#L1219" title="replication/logical/origin.c:1219">replorigin_session_advance</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normally only one such cached origin can exist per process so the cached<br/></li>
<li></span><span class="Comment"> * value can only be set again after the previous value is torn down with<br/></li>
<li></span><span class="Comment"> * <a href="#L1190" title="replication/logical/origin.c:1190">replorigin_session_reset</a>(). For this normal case pass acquired_by = 0<br/></li>
<li></span><span class="Comment"> * (meaning the slot is not allowed to be already acquired by another process).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, sometimes multiple processes can safely re-use the same origin slot<br/></li>
<li></span><span class="Comment"> * (for example, multiple parallel apply processes can safely use the same<br/></li>
<li></span><span class="Comment"> * origin, provided they maintain commit order by allowing only one process to<br/></li>
<li></span><span class="Comment"> * commit at a time). For this case the first process must pass acquired_by =<br/></li>
<li></span><span class="Comment"> * 0, and then the other processes sharing that same origin can pass<br/></li>
<li></span><span class="Comment"> * acquired_by = PID of the first process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1097">&#x200c;</a></span><span class="linkable">replorigin_session_setup</span>(RepOriginId node, <span class="Type">int</span> acquired_by)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> registered_cleanup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_slot = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!registered_cleanup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L1055" title="replication/logical/origin.c:1055">ReplicationOriginExitCleanup</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; registered_cleanup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot setup replication origin when one is already setup&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock exclusively, as we may have to create a new table entry. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search for either an existing slot for the origin, or a free one we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *curstate = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember where to insert if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curstate-&gt;roident == InvalidRepOriginId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_slot == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_slot = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not our slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curstate-&gt;roident != node)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (curstate-&gt;acquired_by != <span class="Constant">0</span> &amp;&amp; acquired_by == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_IN_USE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication origin with ID </span><span class="Special">%d</span><span class="Constant"> is already active for PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curstate-&gt;roident, curstate-&gt;acquired_by)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, found slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> = curstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> == <span class="Constant">NULL</span> &amp;&amp; free_slot == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> free replication state slot for replication origin with ID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Increase <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> and try again.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> new slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[free_slot];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;remote_lsn == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;local_lsn == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;roident = node;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;roident != InvalidRepOriginId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (acquired_by == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;acquired_by = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;acquired_by != acquired_by)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> replication state slot for replication origin with OID </span><span class="Special">%u</span><span class="Constant"> which was acquired by </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; node, acquired_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* probably this one is pointless */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;origin_cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset replay state previously setup in this session.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function may only be called if an origin was setup with<br/></li>
<li></span><span class="Comment"> * <a href="#L1097" title="replication/logical/origin.c:1097">replorigin_session_setup</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1190">&#x200c;</a></span><span class="linkable">replorigin_session_reset</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ConditionVariable *cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no replication origin is configured&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;acquired_by = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; cv = &amp;<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;origin_cv;<br/></li>
<li>&nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do the same work <a href="#L888" title="replication/logical/origin.c:888">replorigin_advance</a>() does, just on the session's<br/></li>
<li></span><span class="Comment"> * configured origin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is noticeably cheaper than using <a href="#L888" title="replication/logical/origin.c:888">replorigin_advance</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1219">&#x200c;</a></span><span class="linkable">replorigin_session_advance</span>(XLogRecPtr remote_commit, XLogRecPtr local_commit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;roident != InvalidRepOriginId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;local_lsn &lt; local_commit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;local_lsn = local_commit;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;remote_lsn &lt; remote_commit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;remote_lsn = remote_commit;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ask the machinery about the point up to which we successfully replayed<br/></li>
<li></span><span class="Comment"> * changes from an already setup replication origin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L1237">&#x200c;</a><span class="linkable">replorigin_session_get_progress</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> flush)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; local_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;lock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; remote_lsn = <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;remote_lsn;<br/></li>
<li>&nbsp; &nbsp; local_lsn = <a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;local_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a>-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flush &amp;&amp; local_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(local_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> remote_lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * SQL <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for working with replication origin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These mostly should be fairly short wrappers around more generic <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> * ---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create replication origin for the passed in name, and return the assigned<br/></li>
<li></span><span class="Comment"> * oid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1269">&#x200c;</a><span class="linkable">pg_replication_origin_create</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; RepOriginId roident;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = <a href="../../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) DatumGetPointer(PG_GETARG_DATUM(<span class="Constant">0</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replication origins &quot;<a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> and &quot;<a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>&quot; are reserved for system options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The origins &quot;pg_xxx&quot; are reserved for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L217" title="catalog/catalog.c:217">IsReservedName</a>(name) || <a href="#L204" title="replication/logical/origin.c:204">IsReservedOriginName</a>(name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_RESERVED_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication origin name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is reserved&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Origin names </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, and names starting with </span><span class="Special">\&quot;</span><span class="Constant">pg_</span><span class="Special">\&quot;</span><span class="Constant"> are reserved.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOGICALREP_ORIGIN_ANY, LOGICALREP_ORIGIN_NONE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If built with appropriate switch, whine when regression-testing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conventions for replication origin names are violated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef ENFORCE_REGRESSION_TEST_NAME_RESTRICTIONS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strncmp(name, <span class="Constant">&quot;regress_&quot;</span>, <span class="Constant">8</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;replication origins created by regression test cases should have names starting with </span><span class="Special">\&quot;</span><span class="Constant">regress_</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; roident = <a href="#L252" title="replication/logical/origin.c:252">replorigin_create</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(roident);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop replication origin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1310">&#x200c;</a><span class="linkable">pg_replication_origin_drop</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = <a href="../../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) DatumGetPointer(PG_GETARG_DATUM(<span class="Constant">0</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L411" title="replication/logical/origin.c:411">replorigin_drop_by_name</a>(name, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return oid of a replication origin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1329">&#x200c;</a><span class="linkable">pg_replication_origin_oid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; RepOriginId roident;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = <a href="../../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) DatumGetPointer(PG_GETARG_DATUM(<span class="Constant">0</span>)));<br/></li>
<li>&nbsp; &nbsp; roident = <a href="#L221" title="replication/logical/origin.c:221">replorigin_by_name</a>(name, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(roident))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_OID(roident);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Setup a replication origin for this session.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1350">&#x200c;</a><span class="linkable">pg_replication_origin_session_setup</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; RepOriginId origin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = <a href="../../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) DatumGetPointer(PG_GETARG_DATUM(<span class="Constant">0</span>)));<br/></li>
<li>&nbsp; &nbsp; origin = <a href="#L221" title="replication/logical/origin.c:221">replorigin_by_name</a>(name, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1097" title="replication/logical/origin.c:1097">replorigin_session_setup</a>(origin, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> = origin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset previously setup origin in this session<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1372">&#x200c;</a><span class="linkable">pg_replication_origin_session_reset</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1190" title="replication/logical/origin.c:1190">replorigin_session_reset</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> = InvalidRepOriginId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Has a replication origin been setup for this session.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1389">&#x200c;</a><span class="linkable">pg_replication_origin_session_is_setup</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the replication progress for origin setup in the current session.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'flush' is set to true it is ensured that the returned value corresponds<br/></li>
<li></span><span class="Comment"> * to a local transaction that has been flushed. This is useful if asynchronous<br/></li>
<li></span><span class="Comment"> * commits are used when replaying replicated transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1405">&#x200c;</a><span class="linkable">pg_replication_origin_session_progress</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; flush = PG_GETARG_BOOL(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no replication origin is configured&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remote_lsn = <a href="#L1237" title="replication/logical/origin.c:1237">replorigin_session_get_progress</a>(flush);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remote_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LSN(remote_lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1426">&#x200c;</a><span class="linkable">pg_replication_origin_xact_setup</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; location = PG_GETARG_LSN(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L179" title="replication/logical/origin.c:179">session_replication_state</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no replication origin is configured&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = location;<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = PG_GETARG_TIMESTAMPTZ(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1444">&#x200c;</a><span class="linkable">pg_replication_origin_xact_reset</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1456">&#x200c;</a><span class="linkable">pg_replication_origin_advance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *name = PG_GETARG_TEXT_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_commit = PG_GETARG_LSN(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; RepOriginId node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock to prevent the replication origin from vanishing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L108" title="storage/lmgr/lmgr.c:108">LockRelationOid</a>(ReplicationOriginRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = <a href="#L221" title="replication/logical/origin.c:221">replorigin_by_name</a>(<a href="../../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>(name), <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't sensibly pass a local commit to be flushed at checkpoint - this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact hasn't committed yet. This is why this function should be used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set up the initial replication state, but not for replay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L888" title="replication/logical/origin.c:888">replorigin_advance</a>(node, remote_commit, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span> <span class="Comment">/* go backward */</span> , <span class="Constant">true</span> <span class="Comment">/* WAL log */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(ReplicationOriginRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the replication progress for an individual replication origin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'flush' is set to true it is ensured that the returned value corresponds<br/></li>
<li></span><span class="Comment"> * to a local transaction that has been flushed. This is useful if asynchronous<br/></li>
<li></span><span class="Comment"> * commits are used when replaying replicated transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1491">&#x200c;</a><span class="linkable">pg_replication_origin_progress</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; flush;<br/></li>
<li>&nbsp; &nbsp; RepOriginId roident;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_lsn = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; name = <a href="../../utils/adt/varlena.c.html#L217" title="utils/adt/varlena.c:217">text_to_cstring</a>((text *) DatumGetPointer(PG_GETARG_DATUM(<span class="Constant">0</span>)));<br/></li>
<li>&nbsp; &nbsp; flush = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; roident = <a href="#L221" title="replication/logical/origin.c:221">replorigin_by_name</a>(name, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(roident));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remote_lsn = <a href="#L1014" title="replication/logical/origin.c:1014">replorigin_get_progress</a>(roident, flush);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remote_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_LSN(remote_lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1516">&#x200c;</a><span class="linkable">pg_show_replication_origin_status</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><a id="L1520">&#x200c;</a><span class="PreProc">#define <span class="linkable">REPLICATION_ORIGIN_PROGRESS_COLS</span> </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we want to return 0 rows if slot is set to zero */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L185" title="replication/logical/origin.c:185">replorigin_check_prerequisites</a>(<span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prevent slots from being concurrently dropped */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationOriginLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate through all possible <a href="#L166" title="replication/logical/origin.c:166">replication_states</a>, display if they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filled. Note that we do not take <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks, so slightly corrupted/out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of date <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are a possibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/logical/origin.c:101">ReplicationState</a> *state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L1520" title="replication/logical/origin.c:1520">REPLICATION_ORIGIN_PROGRESS_COLS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L1520" title="replication/logical/origin.c:1520">REPLICATION_ORIGIN_PROGRESS_COLS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *roname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = &amp;<a href="#L166" title="replication/logical/origin.c:166">replication_states</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unused slot, nothing to display */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;roident == InvalidRepOriginId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(nulls, <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nulls));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = ObjectIdGetDatum(state-&gt;roident);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're not preventing the origin to be dropped concurrently, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * silently <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> that it might be gone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L465" title="replication/logical/origin.c:465">replorigin_by_oid</a>(state-&gt;roident, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;roname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(roname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;state-&gt;lock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = LSNGetDatum(state-&gt;remote_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = LSNGetDatum(state-&gt;local_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;state-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationOriginLock);<br/></li>
<li><br/></li>
<li><a id="L1581">&#x200c;</a><span class="PreProc">#undef <span class="linkable">REPLICATION_ORIGIN_PROGRESS_COLS</span><br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
