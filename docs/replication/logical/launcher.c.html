<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/launcher.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/launcher.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L69">LogicalRepCtx</a></li>
<li><a href="#L54">MyLogicalRepWorker</a></li>
<li><a href="#L79">dsh_params</a></li>
<li><a href="#L89">last_start_times</a></li>
<li><a href="#L88">last_start_times_dsa</a></li>
<li><a href="#L50">max_logical_replication_workers</a></li>
<li><a href="#L52">max_parallel_apply_workers_per_subscription</a></li>
<li><a href="#L51">max_sync_workers_per_subscription</a></li>
<li><a href="#L91">on_commit_launcher_wakeup</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L72">LauncherLastStartTimesEntry</a></li>
<li><a href="#L76">LauncherLastStartTimesEntry</a></li>
<li><a href="#L56">LogicalRepCtxStruct</a></li>
<li><a href="#L67">LogicalRepCtxStruct</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1075">ApplyLauncherForgetWorkerStartTime</a></li>
<li><a href="#L1049">ApplyLauncherGetWorkerStartTime</a></li>
<li><a href="#L1122">ApplyLauncherMain</a></li>
<li><a href="#L918">ApplyLauncherRegister</a></li>
<li><a href="#L1033">ApplyLauncherSetWorkerStartTime</a></li>
<li><a href="#L954">ApplyLauncherShmemInit</a></li>
<li><a href="#L899">ApplyLauncherShmemSize</a></li>
<li><a href="#L1112">ApplyLauncherWakeup</a></li>
<li><a href="#L1105">ApplyLauncherWakeupAtCommit</a></li>
<li><a href="#L1086">AtEOXact_ApplyLauncher</a></li>
<li><a href="#L1253">GetLeaderApplyWorkerPid</a></li>
<li><a href="#L1243">IsLogicalLauncher</a></li>
<li><a href="#L183">WaitForReplicationWorkerAttach</a></li>
<li><a href="#L112">get_subscription_list</a></li>
<li><a href="#L989">logicalrep_launcher_attach_dshmem</a></li>
<li><a href="#L807">logicalrep_launcher_onexit</a></li>
<li><a href="#L872">logicalrep_pa_worker_count</a></li>
<li><a href="#L633">logicalrep_pa_worker_stop</a></li>
<li><a href="#L848">logicalrep_sync_worker_count</a></li>
<li><a href="#L707">logicalrep_worker_attach</a></li>
<li><a href="#L786">logicalrep_worker_cleanup</a></li>
<li><a href="#L744">logicalrep_worker_detach</a></li>
<li><a href="#L243">logicalrep_worker_find</a></li>
<li><a href="#L300">logicalrep_worker_launch</a></li>
<li><a href="#L818">logicalrep_worker_onexit</a></li>
<li><a href="#L609">logicalrep_worker_stop</a></li>
<li><a href="#L527">logicalrep_worker_stop_internal</a></li>
<li><a href="#L676">logicalrep_worker_wakeup</a></li>
<li><a href="#L696">logicalrep_worker_wakeup_ptr</a></li>
<li><a href="#L275">logicalrep_workers_find</a></li>
<li><a href="#L1280">pg_stat_get_subscription</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L47">DEFAULT_NAPTIME_PER_CYCLE</a></li>
<li><a href="#L1282">PG_STAT_GET_SUBSCRIPTION_COLS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * launcher.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; PostgreSQL logical replication worker launcher process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2016-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/launcher.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This module contains the logical replication worker launcher which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; uses the background worker infrastructure to start the logical<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; replication workers for every enabled subscription.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription_rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/dshash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicallauncher.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/worker_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* max sleep time between cycles (3min) */<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_NAPTIME_PER_CYCLE</span> </span><span class="Constant">180000L<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_logical_replication_workers</span> = <span class="Constant">4</span>;<br/></li>
<li><a id="L51">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_sync_workers_per_subscription</span> = <span class="Constant">2</span>;<br/></li>
<li><a id="L52">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_parallel_apply_workers_per_subscription</span> = <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li><a id="L54">&#x200c;</a>LogicalRepWorker *<span class="linkable">MyLogicalRepWorker</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L56">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LogicalRepCtxStruct</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Supervisor process. */<br/></li>
<li></span>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; launcher_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hash table holding last start times of subscriptions' apply workers. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_handle&nbsp; &nbsp; last_start_dsa;<br/></li>
<li>&nbsp; &nbsp; dshash_table_handle last_start_dsh;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Background workers. */<br/></li>
<li></span>&nbsp; &nbsp; LogicalRepWorker workers[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L67">&#x200c;</a>} <span class="linkable">LogicalRepCtxStruct</span>;<br/></li>
<li><br/></li>
<li><a id="L69">&#x200c;</a><span class="Type">static</span> <a href="#L56" title="replication/logical/launcher.c:56">LogicalRepCtxStruct</a> *<span class="linkable">LogicalRepCtx</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* an entry in the last-start-times shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LauncherLastStartTimesEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of logrep subscription (<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key) */<br/></li>
<li></span>&nbsp; &nbsp; TimestampTz last_start_time;&nbsp; &nbsp; <span class="Comment">/* last time its apply worker was started */<br/></li>
<li><a id="L76">&#x200c;</a></span>} <span class="linkable">LauncherLastStartTimesEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* parameters for the last-start-times shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li><a id="L79">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> dshash_parameters <span class="linkable">dsh_params</span> = {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid),<br/></li>
<li>&nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L72" title="replication/logical/launcher.c:72">LauncherLastStartTimesEntry</a>),<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L572" title="lib/dshash.c:572">dshash_memcmp</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L581" title="lib/dshash.c:581">dshash_memhash</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L590" title="lib/dshash.c:590">dshash_memcpy</a>,<br/></li>
<li>&nbsp; &nbsp; LWTRANCHE_LAUNCHER_HASH<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L88">&#x200c;</a><span class="Type">static</span> <a href="../../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<span class="linkable">last_start_times_dsa</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L89">&#x200c;</a><span class="Type">static</span> <a href="../../lib/dshash.c.html#L103" title="lib/dshash.c:103">dshash_table</a> *<span class="linkable">last_start_times</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">on_commit_launcher_wakeup</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1112" title="replication/logical/launcher.c:1112">ApplyLauncherWakeup</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L807" title="replication/logical/launcher.c:807">logicalrep_launcher_onexit</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L818" title="replication/logical/launcher.c:818">logicalrep_worker_onexit</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L744" title="replication/logical/launcher.c:744">logicalrep_worker_detach</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L786" title="replication/logical/launcher.c:786">logicalrep_worker_cleanup</a>(LogicalRepWorker *worker);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L872" title="replication/logical/launcher.c:872">logicalrep_pa_worker_count</a>(Oid subid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L989" title="replication/logical/launcher.c:989">logicalrep_launcher_attach_dshmem</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1033" title="replication/logical/launcher.c:1033">ApplyLauncherSetWorkerStartTime</a>(Oid subid, TimestampTz start_time);<br/></li>
<li><span class="Type">static</span> TimestampTz <a href="#L1049" title="replication/logical/launcher.c:1049">ApplyLauncherGetWorkerStartTime</a>(Oid subid);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load the list of subscriptions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only the fields interesting for worker start/stop <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are filled for<br/></li>
<li></span><span class="Comment"> * each subscription.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L112">&#x200c;</a><span class="linkable">get_subscription_list</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *res = NIL;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; MemoryContext resultcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is the context that we will allocate our output data in */<br/></li>
<li></span>&nbsp; &nbsp; resultcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start a transaction so we can access pg_database, and get a snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't have a use for the snapshot itself, but we're interested in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the secondary effect that it sets RecentGlobalXmin.&nbsp; (This is critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for anything that reads heap pages, because HOT may decide to prune<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them even if the process doesn't attempt to modify <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">FIXME</span><span class="Comment">: This comment is inaccurate / the code buggy. A snapshot that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not pushed/active does not reliably prevent HOT pruning (-&gt;xmin could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * e.g. be cleared when cache invalidations are processed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(SubscriptionRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(rel, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tup = <a href="../../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(scan, ForwardScanDirection)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_subscription subform = (Form_pg_subscription) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Subscription *sub;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate our results in the caller's context, not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction's. We do this inside the loop, and restore the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context at the end, so that leaky things like <a href="../../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>() are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not called in a potentially long-lived context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(resultcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub = (Subscription *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Subscription));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub-&gt;oid = subform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub-&gt;dbid = subform-&gt;subdbid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub-&gt;owner = subform-&gt;subowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub-&gt;enabled = subform-&gt;subenabled;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub-&gt;name = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(subform-&gt;subname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't fill fields we are not interested in. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(res, sub);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for a background worker to start up and attach to the shmem context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only needed for cleaning up the shared memory in case the worker<br/></li>
<li></span><span class="Comment"> * fails to attach.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns whether the attach was successful.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L183">&#x200c;</a></span><span class="linkable">WaitForReplicationWorkerAttach</span>(LogicalRepWorker *worker,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 generation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BgwHandleStatus status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Worker either died or has started. Return false if died. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!worker-&gt;in_use || worker-&gt;proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> worker-&gt;in_use;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if worker has died <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attaching, and clean up after it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../../postmaster/bgworker.c.html#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(handle, &amp;pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == BGWH_STOPPED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure that this was indeed the worker we waited for. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (generation == worker-&gt;generation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L786" title="replication/logical/launcher.c:786">logicalrep_worker_cleanup</a>(worker);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need timeout because we generally don't get notified via latch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about the worker attach.&nbsp; But we don't expect to have to wait long.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">10L</span>, WAIT_EVENT_BGWORKER_STARTUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Walks the workers array and searches for one that matches given<br/></li>
<li></span><span class="Comment"> * subscription id and relid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are only interested in the leader apply worker or table sync worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalRepWorker *<br/></li>
<li><a id="L243">&#x200c;</a><span class="linkable">logicalrep_worker_find</span>(Oid subid, Oid relid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> only_running)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; LogicalRepWorker *res = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(LogicalRepWorkerLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for attached worker for a given subscription id. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip parallel apply workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isParallelApplyWorker(w))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w-&gt;in_use &amp;&amp; w-&gt;subid == subid &amp;&amp; w-&gt;relid == relid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!only_running || w-&gt;proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = w;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L243" title="replication/logical/launcher.c:243">logicalrep_worker_find</a>(), but returns a list of all workers for<br/></li>
<li></span><span class="Comment"> * the subscription, instead of just one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L275">&#x200c;</a><span class="linkable">logicalrep_workers_find</span>(Oid subid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> only_running)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *res = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(LogicalRepWorkerLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for attached worker for a given subscription id. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w-&gt;in_use &amp;&amp; w-&gt;subid == subid &amp;&amp; (!only_running || w-&gt;proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(res, w);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start new logical replication background worker, if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L300">&#x200c;</a></span><span class="linkable">logicalrep_worker_launch</span>(LogicalRepWorkerType wtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid dbid, Oid subid, <span class="Type">const</span> <span class="Type">char</span> *subname, Oid userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid relid, dsm_handle subworker_dsm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BackgroundWorker bgw;<br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/bgworker.c.html#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *bgw_handle;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; generation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; LogicalRepWorker *worker = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsyncworkers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparallelapplyworkers;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_tablesync_worker = (wtype == WORKERTYPE_TABLESYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_parallel_apply_worker = (wtype == WORKERTYPE_PARALLEL_APPLY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sanity checks:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - must be valid worker type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - tablesync workers are only ones to have relid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - parallel apply worker is the only kind of subworker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(wtype != WORKERTYPE_UNKNOWN);<br/></li>
<li>&nbsp; &nbsp; Assert(is_tablesync_worker == OidIsValid(relid));<br/></li>
<li>&nbsp; &nbsp; Assert(is_parallel_apply_worker == (subworker_dsm != DSM_HANDLE_INVALID));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;starting logical replication worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report this after the initial starting message for consistency. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot start logical replication workers when <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a> = 0&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to do the modification of the shared memory under lock so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have consistent view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Find unused worker slot. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!w-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker = w;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nsyncworkers = <a href="#L848" title="replication/logical/launcher.c:848">logicalrep_sync_worker_count</a>(subid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a free slot, try to do garbage collection.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reason we do this is because if some worker failed to start up and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent has crashed while <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, the in_use state was never cleared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (worker == <span class="Constant">NULL</span> || nsyncworkers &gt;= <a href="#L51" title="replication/logical/launcher.c:51">max_sync_workers_per_subscription</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; did_cleanup = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the worker was marked in use but didn't manage to attach in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time, clean it up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w-&gt;in_use &amp;&amp; !w-&gt;proc &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(w-&gt;launch_time, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../walreceiver.c.html#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication worker for subscription </span><span class="Special">%u</span><span class="Constant"> took too long to start; canceled&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; w-&gt;subid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L786" title="replication/logical/launcher.c:786">logicalrep_worker_cleanup</a>(w);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; did_cleanup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (did_cleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't allow to invoke more sync workers once we have reached the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sync worker limit per subscription. So, just return silently as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might get here because of an otherwise harmless race condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_tablesync_worker &amp;&amp; nsyncworkers &gt;= <a href="#L51" title="replication/logical/launcher.c:51">max_sync_workers_per_subscription</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nparallelapplyworkers = <a href="#L872" title="replication/logical/launcher.c:872">logicalrep_pa_worker_count</a>(subid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return false if the number of parallel apply workers reached the limit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per subscription.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_parallel_apply_worker &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nparallelapplyworkers &gt;= <a href="#L52" title="replication/logical/launcher.c:52">max_parallel_apply_workers_per_subscription</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However if there are no more free worker slots, inform user about it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (worker == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of logical replication worker slots&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;<a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare the worker slot. */<br/></li>
<li></span>&nbsp; &nbsp; worker-&gt;type = wtype;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;launch_time = <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;in_use = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;generation++;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;proc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;dbid = dbid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;userid = userid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;subid = subid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;relid = relid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;relstate = SUBREL_STATE_UNKNOWN;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;relstate_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;stream_fileset = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;leader_pid = is_parallel_apply_worker ? <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> : InvalidPid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;parallel_apply = is_parallel_apply_worker;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;last_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; TIMESTAMP_NOBEGIN(worker-&gt;last_send_time);<br/></li>
<li>&nbsp; &nbsp; TIMESTAMP_NOBEGIN(worker-&gt;last_recv_time);<br/></li>
<li>&nbsp; &nbsp; worker-&gt;reply_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; TIMESTAMP_NOBEGIN(worker-&gt;reply_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Before releasing lock, remember generation for future identification. */<br/></li>
<li></span>&nbsp; &nbsp; generation = worker-&gt;generation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register the new dynamic worker. */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;bgw, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(bgw));<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_flags = BGWORKER_SHMEM_ACCESS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BGWORKER_BACKEND_DATABASE_CONNECTION;<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_start_time = BgWorkerStart_RecoveryFinished;<br/></li>
<li>&nbsp; &nbsp; snprintf(bgw.bgw_library_name, MAXPGPATH, <span class="Constant">&quot;postgres&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (worker-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_function_name, BGW_MAXLEN, <span class="Constant">&quot;<a href="worker.c.html#L4685" title="replication/logical/worker.c:4685">ApplyWorkerMain</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_name, BGW_MAXLEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication apply worker for subscription </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_type, BGW_MAXLEN, <span class="Constant">&quot;logical replication apply worker&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_PARALLEL_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_function_name, BGW_MAXLEN, <span class="Constant">&quot;<a href="applyparallelworker.c.html#L857" title="replication/logical/applyparallelworker.c:857">ParallelApplyWorkerMain</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_name, BGW_MAXLEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication parallel apply worker for subscription </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_type, BGW_MAXLEN, <span class="Constant">&quot;logical replication parallel worker&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(bgw.bgw_extra, &amp;subworker_dsm, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsm_handle));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_TABLESYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_function_name, BGW_MAXLEN, <span class="Constant">&quot;<a href="tablesync.c.html#L1711" title="replication/logical/tablesync.c:1711">TablesyncWorkerMain</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_name, BGW_MAXLEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication tablesync worker for subscription </span><span class="Special">%u</span><span class="Constant"> sync </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(bgw.bgw_type, BGW_MAXLEN, <span class="Constant">&quot;logical replication tablesync worker&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never happen. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown worker type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bgw.bgw_restart_time = BGW_NEVER_RESTART;<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_notify_pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_main_arg = Int32GetDatum(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../postmaster/bgworker.c.html#L970" title="postmaster/bgworker.c:970">RegisterDynamicBackgroundWorker</a>(&amp;bgw, &amp;bgw_handle))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to start worker, so clean up the worker slot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(generation == worker-&gt;generation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L786" title="replication/logical/launcher.c:786">logicalrep_worker_cleanup</a>(worker);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of background worker slots&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to increase </span><span class="Special">%s</span><span class="Constant">.&quot;</span>, <span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now wait until it attaches. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L183" title="replication/logical/launcher.c:183">WaitForReplicationWorkerAttach</a>(worker, generation, bgw_handle);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal function to stop the worker and wait until it detaches from the<br/></li>
<li></span><span class="Comment"> * slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L527">&#x200c;</a></span><span class="linkable">logicalrep_worker_stop_internal</span>(LogicalRepWorker *worker, <span class="Type">int</span> signo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; generation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(LogicalRepWorkerLock, LW_SHARED));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember which generation was our worker so we can check if what we see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is still the same one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; generation = worker-&gt;generation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found a worker but it does not have proc set then it is still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting up; wait for it to finish starting and then kill it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (worker-&gt;in_use &amp;&amp; !worker-&gt;proc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> --- we don't expect to have to wait long. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">10L</span>, WAIT_EVENT_BGWORKER_STARTUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recheck worker status. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether the worker slot is no longer used, which would mean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the worker has exited, or whether the worker generation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different, meaning that a different worker has taken the slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!worker-&gt;in_use || worker-&gt;generation != generation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Worker has assigned proc, so it has started. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now terminate the worker ... */<br/></li>
<li></span>&nbsp; &nbsp; kill(worker-&gt;proc-&gt;pid, signo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and wait for it to <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is it gone? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!worker-&gt;proc || worker-&gt;generation != generation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> --- we don't expect to have to wait long. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">10L</span>, WAIT_EVENT_BGWORKER_SHUTDOWN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stop the logical replication worker for subid/relid, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L609">&#x200c;</a></span><span class="linkable">logicalrep_worker_stop</span>(Oid subid, Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepWorker *worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; worker = <a href="#L243" title="replication/logical/launcher.c:243">logicalrep_worker_find</a>(subid, relid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (worker)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isParallelApplyWorker(worker));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L527" title="replication/logical/launcher.c:527">logicalrep_worker_stop_internal</a>(worker, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stop the given logical replication parallel apply worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Node that the function sends SIGINT instead of SIGTERM to the parallel apply<br/></li>
<li></span><span class="Comment"> * worker so that the worker exits cleanly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L633">&#x200c;</a></span><span class="linkable">logicalrep_pa_worker_stop</span>(ParallelApplyWorkerInfo *winfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_no;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; generation;<br/></li>
<li>&nbsp; &nbsp; LogicalRepWorker *worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;winfo-&gt;shared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; generation = winfo-&gt;shared-&gt;logicalrep_worker_generation;<br/></li>
<li>&nbsp; &nbsp; slot_no = winfo-&gt;shared-&gt;logicalrep_worker_slot_no;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;winfo-&gt;shared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot_no &gt;= <span class="Constant">0</span> &amp;&amp; slot_no &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detach from the error_mq_handle for the parallel apply worker <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stopping it. This prevents the leader apply worker from trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receive the message from the error queue that might already be detached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (winfo-&gt;error_mq_handle)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(winfo-&gt;error_mq_handle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; winfo-&gt;error_mq_handle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; worker = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[slot_no];<br/></li>
<li>&nbsp; &nbsp; Assert(isParallelApplyWorker(worker));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only stop the worker if the generation matches and the worker is alive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;generation == generation &amp;&amp; worker-&gt;proc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L527" title="replication/logical/launcher.c:527">logicalrep_worker_stop_internal</a>(worker, <span class="Constant">SIGINT</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up (using latch) <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> logical replication worker for specified sub/rel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L676">&#x200c;</a></span><span class="linkable">logicalrep_worker_wakeup</span>(Oid subid, Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepWorker *worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; worker = <a href="#L243" title="replication/logical/launcher.c:243">logicalrep_worker_find</a>(subid, relid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (worker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L696" title="replication/logical/launcher.c:696">logicalrep_worker_wakeup_ptr</a>(worker);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up (using latch) the specified logical replication worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold lock, else worker-&gt;proc could change under us.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L696">&#x200c;</a></span><span class="linkable">logicalrep_worker_wakeup_ptr</span>(LogicalRepWorker *worker)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(LogicalRepWorkerLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;worker-&gt;proc-&gt;procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to a slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L707">&#x200c;</a></span><span class="linkable">logicalrep_worker_attach</span>(<span class="Type">int</span> slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Block concurrent access. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot &gt;= <span class="Constant">0</span> &amp;&amp; slot &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a> = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[slot];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker slot </span><span class="Special">%d</span><span class="Constant"> is empty, cannot attach&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;proc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker slot </span><span class="Special">%d</span><span class="Constant"> is already used by &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;another worker, cannot attach&quot;</span>, slot)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;proc = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L818" title="replication/logical/launcher.c:818">logicalrep_worker_onexit</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stop the parallel apply workers if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and detach the leader apply worker<br/></li>
<li></span><span class="Comment"> * (cleans up the worker info).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L744">&#x200c;</a></span><span class="linkable">logicalrep_worker_detach</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Stop the parallel apply workers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (am_leader_apply_worker())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Detach from the error_mq_handle for all parallel apply workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> terminating them. This prevents the leader apply worker from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * receiving the worker termination message and sending it to logs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the same is already done by the parallel worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L622" title="replication/logical/applyparallelworker.c:622">pa_detach_all_error_mq</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workers = <a href="#L275" title="replication/logical/launcher.c:275">logicalrep_workers_find</a>(<a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, workers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = (LogicalRepWorker *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isParallelApplyWorker(w))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L527" title="replication/logical/launcher.c:527">logicalrep_worker_stop_internal</a>(w, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Block concurrent access. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L786" title="replication/logical/launcher.c:786">logicalrep_worker_cleanup</a>(<a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up worker info.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L786">&#x200c;</a></span><span class="linkable">logicalrep_worker_cleanup</span>(LogicalRepWorker *worker)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(LogicalRepWorkerLock, LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; worker-&gt;type = WORKERTYPE_UNKNOWN;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;in_use = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;proc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;dbid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;userid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;subid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;relid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;leader_pid = InvalidPid;<br/></li>
<li>&nbsp; &nbsp; worker-&gt;parallel_apply = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup function for logical replication launcher.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called on logical replication launcher exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L807">&#x200c;</a></span><span class="linkable">logicalrep_launcher_onexit</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;launcher_pid = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called on logical replication worker exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L818">&#x200c;</a></span><span class="linkable">logicalrep_worker_onexit</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disconnect gracefully from the remote side. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="worker.c.html#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walrcv_disconnect(<a href="worker.c.html#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="replication/logical/launcher.c:744">logicalrep_worker_detach</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup fileset used for streaming transactions. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fileset.c.html#L150" title="storage/file/fileset.c:150">FileSetDeleteAll</a>(<a href="#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Session level locks may be acquired outside of a transaction in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel apply mode and will not be released when the worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * terminates, so manually release all locks <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the worker exits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The locks will be acquired once the worker is initialized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="worker.c.html#L318" title="replication/logical/worker.c:318">InitializingApplyWorker</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lock.c.html#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>(DEFAULT_LOCKMETHOD, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1112" title="replication/logical/launcher.c:1112">ApplyLauncherWakeup</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Count the number of registered (not necessarily running) sync workers<br/></li>
<li></span><span class="Comment"> * for a subscription.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L848">&#x200c;</a></span><span class="linkable">logicalrep_sync_worker_count</span>(Oid subid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(LogicalRepWorkerLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for attached worker for a given subscription id. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isTablesyncWorker(w) &amp;&amp; w-&gt;subid == subid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Count the number of registered (but not necessarily running) parallel apply<br/></li>
<li></span><span class="Comment"> * workers for a subscription.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L872">&#x200c;</a></span><span class="linkable">logicalrep_pa_worker_count</span>(Oid subid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(LogicalRepWorkerLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan all attached parallel apply workers, only counting those which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have the given subscription id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isParallelApplyWorker(w) &amp;&amp; w-&gt;subid == subid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L899" title="replication/logical/launcher.c:899">ApplyLauncherShmemSize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute space needed for replication launcher shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L899">&#x200c;</a><span class="linkable">ApplyLauncherShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need the fixed struct and the array of LogicalRepWorker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L56" title="replication/logical/launcher.c:56">LogicalRepCtxStruct</a>);<br/></li>
<li>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepWorker)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L918" title="replication/logical/launcher.c:918">ApplyLauncherRegister</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register a background worker running the logical replication launcher.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L918">&#x200c;</a></span><span class="linkable">ApplyLauncherRegister</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BackgroundWorker bgw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The logical replication launcher is disabled during binary upgrades, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent logical replication workers from running on the source <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That could cause replication origins to move forward after having been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copied to the target <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>, potentially creating conflicts with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copied data files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a> == <span class="Constant">0</span> || <a href="../../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;bgw, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(bgw));<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_flags = BGWORKER_SHMEM_ACCESS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BGWORKER_BACKEND_DATABASE_CONNECTION;<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_start_time = BgWorkerStart_RecoveryFinished;<br/></li>
<li>&nbsp; &nbsp; snprintf(bgw.bgw_library_name, MAXPGPATH, <span class="Constant">&quot;postgres&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; snprintf(bgw.bgw_function_name, BGW_MAXLEN, <span class="Constant">&quot;<a href="#L1122" title="replication/logical/launcher.c:1122">ApplyLauncherMain</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; snprintf(bgw.bgw_name, BGW_MAXLEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication launcher&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; snprintf(bgw.bgw_type, BGW_MAXLEN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication launcher&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_restart_time = <span class="Constant">5</span>;<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_notify_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; bgw.bgw_main_arg = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/bgworker.c.html#L862" title="postmaster/bgworker.c:862">RegisterBackgroundWorker</a>(&amp;bgw);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L954" title="replication/logical/launcher.c:954">ApplyLauncherShmemInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> replication launcher shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L954">&#x200c;</a></span><span class="linkable">ApplyLauncherShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a> = (<a href="#L56" title="replication/logical/launcher.c:56">LogicalRepCtxStruct</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Logical Replication Launcher Data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L899" title="replication/logical/launcher.c:899">ApplyLauncherShmemSize</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>, <span class="Constant">0</span>, <a href="#L899" title="replication/logical/launcher.c:899">ApplyLauncherShmemSize</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsa = DSA_HANDLE_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsh = DSHASH_HANDLE_INVALID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize memory and spin locks for each worker slot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (slot = <span class="Constant">0</span>; slot &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; slot++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *worker = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[slot];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(worker, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepWorker));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockInit(&amp;worker-&gt;relmutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize or attach to the dynamic shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table that stores the<br/></li>
<li></span><span class="Comment"> * last-start times, if not already done.<br/></li>
<li></span><span class="Comment"> * This must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> accessing the table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L989">&#x200c;</a></span><span class="linkable">logicalrep_launcher_attach_dshmem</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if we already did this. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsh != DSHASH_HANDLE_INVALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, use a lock to ensure only one process creates the table. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be sure <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> local memory allocated by DSA routines is persistent. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsh == DSHASH_HANDLE_INVALID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize dynamic shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for last-start times. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a> = dsa_create(LWTRANCHE_LAUNCHER_DSA);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L975" title="utils/mmgr/dsa.c:975">dsa_pin</a>(<a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L635" title="utils/mmgr/dsa.c:635">dsa_pin_mapping</a>(<a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a> = <a href="../../lib/dshash.c.html#L206" title="lib/dshash.c:206">dshash_create</a>(<a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a>, &amp;<a href="../../storage/ipc/dsm_registry.c.html#L50" title="storage/ipc/dsm_registry.c:50">dsh_params</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store handles in shared memory for other backends to use. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsa = <a href="../../utils/mmgr/dsa.c.html#L498" title="utils/mmgr/dsa.c:498">dsa_get_handle</a>(<a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsh = <a href="../../lib/dshash.c.html#L367" title="lib/dshash.c:367">dshash_get_hash_table_handle</a>(<a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Attach to existing dynamic shared <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a> = <a href="../../utils/mmgr/dsa.c.html#L510" title="utils/mmgr/dsa.c:510">dsa_attach</a>(<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsa);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L635" title="utils/mmgr/dsa.c:635">dsa_pin_mapping</a>(<a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a> = <a href="../../lib/dshash.c.html#L270" title="lib/dshash.c:270">dshash_attach</a>(<a href="#L88" title="replication/logical/launcher.c:88">last_start_times_dsa</a>, &amp;<a href="../../storage/ipc/dsm_registry.c.html#L50" title="storage/ipc/dsm_registry.c:50">dsh_params</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;last_start_dsh, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the last-start time for the subscription.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1033">&#x200c;</a></span><span class="linkable">ApplyLauncherSetWorkerStartTime</span>(Oid subid, TimestampTz start_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="replication/logical/launcher.c:72">LauncherLastStartTimesEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L989" title="replication/logical/launcher.c:989">logicalrep_launcher_attach_dshmem</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = <a href="../../lib/dshash.c.html#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>(<a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a>, &amp;subid, &amp;found);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;last_start_time = start_time;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a>, entry);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the last-start time for the subscription, or 0 if there isn't one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TimestampTz<br/></li>
<li><a id="L1049">&#x200c;</a><span class="linkable">ApplyLauncherGetWorkerStartTime</span>(Oid subid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="replication/logical/launcher.c:72">LauncherLastStartTimesEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; TimestampTz ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L989" title="replication/logical/launcher.c:989">logicalrep_launcher_attach_dshmem</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = <a href="../../lib/dshash.c.html#L390" title="lib/dshash.c:390">dshash_find</a>(<a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a>, &amp;subid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = entry-&gt;last_start_time;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/dshash.c.html#L558" title="lib/dshash.c:558">dshash_release_lock</a>(<a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a>, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the last-start-time entry for the subscription, if one exists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has two use-cases: to remove the entry related to a subscription<br/></li>
<li></span><span class="Comment"> * that's been deleted or disabled (just to avoid leaking shared memory),<br/></li>
<li></span><span class="Comment"> * and to allow immediate restart of an apply worker that has exited<br/></li>
<li></span><span class="Comment"> * due to subscription parameter changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1075">&#x200c;</a></span><span class="linkable">ApplyLauncherForgetWorkerStartTime</span>(Oid subid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L989" title="replication/logical/launcher.c:989">logicalrep_launcher_attach_dshmem</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../lib/dshash.c.html#L503" title="lib/dshash.c:503">dshash_delete_key</a>(<a href="#L89" title="replication/logical/launcher.c:89">last_start_times</a>, &amp;subid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wakeup the launcher on commit if requested.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1086">&#x200c;</a></span><span class="linkable">AtEOXact_ApplyLauncher</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L91" title="replication/logical/launcher.c:91">on_commit_launcher_wakeup</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1112" title="replication/logical/launcher.c:1112">ApplyLauncherWakeup</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="replication/logical/launcher.c:91">on_commit_launcher_wakeup</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Request <a href="../walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> of the launcher on commit of the transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> launcher signal to stop sleeping and process the<br/></li>
<li></span><span class="Comment"> * subscriptions when current transaction commits. Should be used when new<br/></li>
<li></span><span class="Comment"> * tuple was added to the pg_subscription catalog.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1105">&#x200c;</a></span><span class="linkable">ApplyLauncherWakeupAtCommit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L91" title="replication/logical/launcher.c:91">on_commit_launcher_wakeup</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="replication/logical/launcher.c:91">on_commit_launcher_wakeup</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1112">&#x200c;</a></span><span class="linkable">ApplyLauncherWakeup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;launcher_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kill(<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;launcher_pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main loop for the apply launcher process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1122">&#x200c;</a></span><span class="linkable">ApplyLauncherMain</span>(Datum main_arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;logical replication launcher started&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L807" title="replication/logical/launcher.c:807">logicalrep_launcher_onexit</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;launcher_pid == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;launcher_pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Establish signal handlers. */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="../../postmaster/interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L4229" title="postmaster/postmaster.c:4229">BackgroundWorkerUnblockSignals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Establish connection to nailed catalogs (we only ever access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_subscription).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L4155" title="postmaster/postmaster.c:4155">BackgroundWorkerInitializeConnection</a>(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enter <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext subctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; wait_time = <a href="#L47" title="replication/logical/launcher.c:47">DEFAULT_NAPTIME_PER_CYCLE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use temporary context to avoid leaking memory across cycles. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subctx = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Logical Replication Launcher sublist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(subctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing workers for enabled subscriptions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="#L112" title="replication/logical/launcher.c:112">get_subscription_list</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Subscription *sub = (Subscription *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz last_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; elapsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sub-&gt;enabled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = <a href="#L243" title="replication/logical/launcher.c:243">logicalrep_worker_find</a>(sub-&gt;oid, InvalidOid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* worker is running already */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the worker is eligible to start <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, launch it.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjust wait_time so that we'll wake up as soon as it can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * started.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Each subscription's apply worker can only be restarted once per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a>, so that errors do not cause us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * repeatedly restart the worker as fast as possible.&nbsp; In cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where a restart is expected (e.g., subscription parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes), another process should remove the last-start entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the subscription so that the worker can be restarted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for <a href="../../access/transam/xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a> to elapse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_start = <a href="#L1049" title="replication/logical/launcher.c:1049">ApplyLauncherGetWorkerStartTime</a>(sub-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_start == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (elapsed = <a href="../../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(last_start, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)) &gt;= <a href="../../access/transam/xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1033" title="replication/logical/launcher.c:1033">ApplyLauncherSetWorkerStartTime</a>(sub-&gt;oid, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="replication/logical/launcher.c:300">logicalrep_worker_launch</a>(WORKERTYPE_APPLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub-&gt;dbid, sub-&gt;oid, sub-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sub-&gt;owner, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DSM_HANDLE_INVALID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_time = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(wait_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a> - elapsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Switch back to original memory context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clean the temporary memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(subctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for more work. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wait_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_LOGICAL_LAUNCHER_MAIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not reachable */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is current process the logical replication launcher?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1243">&#x200c;</a></span><span class="linkable">IsLogicalLauncher</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;launcher_pid == <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the pid of the leader apply worker if the given pid is the pid of a<br/></li>
<li></span><span class="Comment"> * parallel apply worker, otherwise, return InvalidPid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pid_t<br/></li>
<li><a id="L1253">&#x200c;</a><span class="linkable">GetLeaderApplyWorkerPid</span>(pid_t pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leader_pid = InvalidPid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *w = &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isParallelApplyWorker(w) &amp;&amp; w-&gt;proc &amp;&amp; pid == w-&gt;proc-&gt;pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leader_pid = w-&gt;leader_pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> leader_pid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns state of the subscriptions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1280">&#x200c;</a><span class="linkable">pg_stat_get_subscription</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><a id="L1282">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_STAT_GET_SUBSCRIPTION_COLS</span>&nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subid = PG_ARGISNULL(<span class="Constant">0</span>) ? InvalidOid : PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we get consistent view of the workers. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L50" title="replication/logical/launcher.c:50">max_logical_replication_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for each row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L1282" title="replication/logical/launcher.c:1282">PG_STAT_GET_SUBSCRIPTION_COLS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L1282" title="replication/logical/launcher.c:1282">PG_STAT_GET_SUBSCRIPTION_COLS</a>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker_pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;worker, &amp;<a href="#L69" title="replication/logical/launcher.c:69">LogicalRepCtx</a>-&gt;workers[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepWorker));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!worker.proc || !<a href="../../storage/ipc/procarray.c.html#L3278" title="storage/ipc/procarray.c:3278">IsBackendPid</a>(worker.proc-&gt;pid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(subid) &amp;&amp; worker.subid != subid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; worker_pid = worker.proc-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = ObjectIdGetDatum(worker.subid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isTablesyncWorker(&amp;worker))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = ObjectIdGetDatum(worker.relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = Int32GetDatum(worker_pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isParallelApplyWorker(&amp;worker))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = Int32GetDatum(worker.leader_pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(worker.last_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = LSNGetDatum(worker.last_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker.last_send_time == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = TimestampTzGetDatum(worker.last_send_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker.last_recv_time == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">6</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] = TimestampTzGetDatum(worker.last_recv_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(worker.reply_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">7</span>] = LSNGetDatum(worker.reply_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker.reply_time == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>] = TimestampTzGetDatum(worker.reply_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (worker.type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = CStringGetTextDatum(<span class="Constant">&quot;apply&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_PARALLEL_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = CStringGetTextDatum(<span class="Constant">&quot;parallel apply&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_TABLESYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = CStringGetTextDatum(<span class="Constant">&quot;table synchronization&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never happen. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unknown worker type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If only a single subscription was requested, and we found it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * break.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(subid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
