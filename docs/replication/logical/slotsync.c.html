<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/slotsync.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/slotsync.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L106">SlotSyncCtx</a></li>
<li><a href="#L119">sleep_ms</a></li>
<li><a href="#L109">sync_replication_slots</a></li>
<li><a href="#L129">syncing_slots</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L135">RemoteSlot</a></li>
<li><a href="#L148">RemoteSlot</a></li>
<li><a href="#L97">SlotSyncCtxStruct</a></li>
<li><a href="#L104">SlotSyncCtxStruct</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1013">CheckAndGetDbnameFromConninfo</a></li>
<li><a href="#L1650">IsSyncingReplicationSlots</a></li>
<li><a href="#L1155">ProcessSlotSyncInterrupts</a></li>
<li><a href="#L1331">ReplSlotSyncWorkerMain</a></li>
<li><a href="#L1562">ShutDownSlotSync</a></li>
<li><a href="#L1668">SlotSyncShmemInit</a></li>
<li><a href="#L1659">SlotSyncShmemSize</a></li>
<li><a href="#L1630">SlotSyncWorkerCanRestart</a></li>
<li><a href="#L1725">SyncReplicationSlots</a></li>
<li><a href="#L1039">ValidateSlotSyncParams</a></li>
<li><a href="#L1271">check_and_set_sync_info</a></li>
<li><a href="#L417">drop_local_obsolete_slots</a></li>
<li><a href="#L333">get_local_synced_slots</a></li>
<li><a href="#L364">local_sync_slot_required</a></li>
<li><a href="#L474">reserve_wal_for_local_slot</a></li>
<li><a href="#L1315">reset_syncing_flag</a></li>
<li><a href="#L1688">slotsync_failure_callback</a></li>
<li><a href="#L1106">slotsync_reread_config</a></li>
<li><a href="#L1177">slotsync_worker_disconnect</a></li>
<li><a href="#L1190">slotsync_worker_onexit</a></li>
<li><a href="#L609">synchronize_one_slot</a></li>
<li><a href="#L791">synchronize_slots</a></li>
<li><a href="#L545">update_and_persist_local_synced_slot</a></li>
<li><a href="#L168">update_local_synced_slot</a></li>
<li><a href="#L1510">update_synced_slots_inactive_since</a></li>
<li><a href="#L934">validate_remote_info</a></li>
<li><a href="#L1236">wait_for_slot_activity</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L117">MAX_SLOTSYNC_WORKER_NAPTIME_MS</a></li>
<li><a href="#L116">MIN_SLOTSYNC_WORKER_NAPTIME_MS</a></li>
<li><a href="#L936">PRIMARY_INFO_OUTPUT_COL_COUNT</a></li>
<li><a href="#L793">SLOTSYNC_COLUMN_COUNT</a></li>
<li><a href="#L122">SLOTSYNC_RESTART_INTERVAL_SEC</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * slotsync.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Functionality for synchronizing slots to a standby server from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; primary server.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/slotsync.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains the code for slot synchronization on a physical standby<br/></li>
<li></span><span class="Comment"> * to fetch logical failover slots information from the primary server, create<br/></li>
<li></span><span class="Comment"> * the slots on the standby and synchronize them periodically.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Slot synchronization can be performed either automatically by enabling slot<br/></li>
<li></span><span class="Comment"> * sync worker or manually by calling SQL function <a href="../slotfuncs.c.html#L866" title="replication/slotfuncs.c:866">pg_sync_replication_slots</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the WAL corresponding to the remote's restart_lsn is not available on the<br/></li>
<li></span><span class="Comment"> * physical standby or the remote's catalog_xmin precedes the oldest xid for<br/></li>
<li></span><span class="Comment"> * which it is guaranteed that rows wouldn't have been removed then we cannot<br/></li>
<li></span><span class="Comment"> * create the local standby slot because that would mean moving the local slot<br/></li>
<li></span><span class="Comment"> * backward and decoding won't be possible via such a slot. In this case, the<br/></li>
<li></span><span class="Comment"> * slot will be marked as RS_TEMPORARY. Once the primary server catches up,<br/></li>
<li></span><span class="Comment"> * the slot will be marked as RS_PERSISTENT (which means sync-ready) after<br/></li>
<li></span><span class="Comment"> * which slot sync worker can perform the sync periodically or user can call<br/></li>
<li></span><span class="Comment"> * <a href="../slotfuncs.c.html#L866" title="replication/slotfuncs.c:866">pg_sync_replication_slots</a>() periodically to perform the syncs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If synchronized slots fail to build a consistent snapshot from the<br/></li>
<li></span><span class="Comment"> * restart_lsn <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching confirmed_flush_lsn, they would become<br/></li>
<li></span><span class="Comment"> * unreliable after promotion due to potential data loss from changes<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching a consistent point. This can happen because the slots can<br/></li>
<li></span><span class="Comment"> * be synced at some random time and we may not reach the consistent point<br/></li>
<li></span><span class="Comment"> * at the same WAL location as the primary. So, we mark such slots as<br/></li>
<li></span><span class="Comment"> * RS_TEMPORARY. Once the decoding from corresponding LSNs can reach a<br/></li>
<li></span><span class="Comment"> * consistent point, they will be marked as RS_PERSISTENT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The slot sync worker waits for some time <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> synchronization,<br/></li>
<li></span><span class="Comment"> * with the duration varying based on whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slots were updated during<br/></li>
<li></span><span class="Comment"> * the last cycle. Refer to the comments above <a href="#L1236" title="replication/logical/slotsync.c:1236">wait_for_slot_activity</a>() for<br/></li>
<li></span><span class="Comment"> * more details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any standby synchronized slots will be dropped if they no longer need<br/></li>
<li></span><span class="Comment"> * to be synchronized. See comment atop <a href="#L417" title="replication/logical/slotsync.c:417">drop_local_obsolete_slots</a>() for more<br/></li>
<li></span><span class="Comment"> * details.<br/></li>
<li></span><span class="Comment"> *---------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/<a href="../../postmaster/fork_process.c.html#L32" title="postmaster/fork_process.c:32">fork_process</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/snapbuild.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct for sharing information to control slot synchronization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The slot sync worker's pid is needed by the startup process to shut it<br/></li>
<li></span><span class="Comment"> * down during promotion. The startup process shuts down the slot sync worker<br/></li>
<li></span><span class="Comment"> * and also sets stopSignaled=true to handle the race condition when the<br/></li>
<li></span><span class="Comment"> * postmaster has not noticed the promotion yet and thus may end up restarting<br/></li>
<li></span><span class="Comment"> * the slot sync worker. If stopSignaled is set, the worker will exit in such a<br/></li>
<li></span><span class="Comment"> * case. The SQL function <a href="../slotfuncs.c.html#L866" title="replication/slotfuncs.c:866">pg_sync_replication_slots</a>() will also error out if<br/></li>
<li></span><span class="Comment"> * this flag is set. Note that we don't need to reset this variable as after<br/></li>
<li></span><span class="Comment"> * promotion the slot sync worker won't be restarted because the <a href="../../postmaster/postmaster.c.html#L331" title="postmaster/postmaster.c:331">pmState</a><br/></li>
<li></span><span class="Comment"> * changes to PM_RUN from PM_HOT_STANDBY and we don't support demoting<br/></li>
<li></span><span class="Comment"> * primary without restarting the server. See <a href="../../postmaster/postmaster.c.html#L4089" title="postmaster/postmaster.c:4089">MaybeStartSlotSyncWorker</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The 'syncing' flag is needed to prevent concurrent slot syncs to avoid slot<br/></li>
<li></span><span class="Comment"> * overwrites.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The 'last_start_time' is needed by postmaster to start the slot sync worker<br/></li>
<li></span><span class="Comment"> * once per <a href="#L122" title="replication/logical/slotsync.c:122">SLOTSYNC_RESTART_INTERVAL_SEC</a>. In cases where an immediate restart<br/></li>
<li></span><span class="Comment"> * is expected (e.g., slot sync GUCs change), slot sync worker will reset<br/></li>
<li></span><span class="Comment"> * last_start_time <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting, so that postmaster can start the worker<br/></li>
<li></span><span class="Comment"> * without <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for <a href="#L122" title="replication/logical/slotsync.c:122">SLOTSYNC_RESTART_INTERVAL_SEC</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SlotSyncCtxStruct</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; stopSignaled;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; syncing;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; last_start_time;<br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mutex;<br/></li>
<li><a id="L104">&#x200c;</a>} <span class="linkable">SlotSyncCtxStruct</span>;<br/></li>
<li><br/></li>
<li><a id="L106">&#x200c;</a><a href="#L97" title="replication/logical/slotsync.c:97">SlotSyncCtxStruct</a> *<span class="linkable">SlotSyncCtx</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variable */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">sync_replication_slots</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The sleep time (ms) between slot-sync cycles varies dynamically<br/></li>
<li></span><span class="Comment"> * (within a MIN/MAX <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) according to slot activity. See<br/></li>
<li></span><span class="Comment"> * <a href="#L1236" title="replication/logical/slotsync.c:1236">wait_for_slot_activity</a>() for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MIN_SLOTSYNC_WORKER_NAPTIME_MS</span>&nbsp; </span><span class="Constant">200<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_SLOTSYNC_WORKER_NAPTIME_MS</span>&nbsp; </span><span class="Constant">30000</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* 30s */<br/></li>
<li></span><br/></li>
<li><a id="L119">&#x200c;</a><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">sleep_ms</span> = <a href="#L116" title="replication/logical/slotsync.c:116">MIN_SLOTSYNC_WORKER_NAPTIME_MS</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The restart interval for slot sync work used by postmaster */<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SLOTSYNC_RESTART_INTERVAL_SEC</span> </span><span class="Constant">10<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag to tell if we are syncing replication slots. Unlike the 'syncing' flag<br/></li>
<li></span><span class="Comment"> * in <a href="#L97" title="replication/logical/slotsync.c:97">SlotSyncCtxStruct</a>, this flag is true only if the current process is<br/></li>
<li></span><span class="Comment"> * performing slot synchronization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">syncing_slots</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Structure to hold information fetched from the primary server about a logical<br/></li>
<li></span><span class="Comment"> * replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RemoteSlot</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *plugin;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *database;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; two_phase;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failover;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; restart_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; confirmed_lsn;<br/></li>
<li>&nbsp; &nbsp; TransactionId catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* RS_INVAL_NONE if valid, or the reason of invalidation */<br/></li>
<li></span>&nbsp; &nbsp; ReplicationSlotInvalidationCause invalidated;<br/></li>
<li><a id="L148">&#x200c;</a>} <span class="linkable">RemoteSlot</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1688" title="replication/logical/slotsync.c:1688">slotsync_failure_callback</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1510" title="replication/logical/slotsync.c:1510">update_synced_slots_inactive_since</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If necessary, update the local synced slot's metadata based on the data<br/></li>
<li></span><span class="Comment"> * from the remote slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no update was needed (the data of the remote slot is the same as the<br/></li>
<li></span><span class="Comment"> * local slot) return false, otherwise true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *found_consistent_snapshot will be true iff the remote slot's LSN or xmin is<br/></li>
<li></span><span class="Comment"> * modified, and decoding from the corresponding LSN's can reach a<br/></li>
<li></span><span class="Comment"> * consistent snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *remote_slot_precedes will be true if the remote slot's LSN or xmin<br/></li>
<li></span><span class="Comment"> * precedes locally reserved position.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L168">&#x200c;</a></span><span class="linkable">update_local_synced_slot</span>(<a href="#L135" title="replication/logical/slotsync.c:135">RemoteSlot</a> *remote_slot, Oid remote_dbid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *found_consistent_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *remote_slot_precedes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_xmin_or_lsn = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_config = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;data.invalidated == RS_INVAL_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found_consistent_snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *found_consistent_snapshot = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remote_slot_precedes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *remote_slot_precedes = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't overwrite if we already have a newer catalog_xmin and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart_lsn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (remote_slot-&gt;restart_lsn &lt; slot-&gt;data.restart_lsn ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(remote_slot-&gt;catalog_xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.catalog_xmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This can happen in following situations:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the slot is temporary, it means either the initial WAL location<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reserved for the local slot is ahead of the remote slot's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart_lsn or the initial xmin_horizon computed for the local slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is ahead of the remote slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the slot is persistent, restart_lsn of the synced slot could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still be ahead of the remote slot. Since we use slot advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * functionality to keep snapbuild/slot updated, it is possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the restart_lsn is advanced to a later position than it has on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary. This can happen when slot advancing machinery finds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running xacts record after reaching the consistent state at a later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point than the primary where it serializes the snapshot and updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the restart_lsn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We LOG the message if the slot is temporary as it can <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to understand why the slot is not sync-ready. In the case of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * persistent slot, it would be a more common case and won't directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * impact the users, so we used DEBUG1 level to log the message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(slot-&gt;data.persistency == RS_TEMPORARY ? LOG : DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not sync slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as remote slot precedes local slot&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_slot-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Remote slot has LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> and catalog xmin </span><span class="Special">%u</span><span class="Constant">, but local slot has LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> and catalog xmin </span><span class="Special">%u</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(remote_slot-&gt;restart_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;catalog_xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(slot-&gt;data.restart_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.catalog_xmin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remote_slot_precedes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *remote_slot_precedes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attempt to sync LSNs and xmins only if remote slot is ahead of local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (remote_slot-&gt;confirmed_lsn &gt; slot-&gt;data.confirmed_flush ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_slot-&gt;restart_lsn &gt; slot-&gt;data.restart_lsn ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(remote_slot-&gt;catalog_xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.catalog_xmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't directly copy the remote slot's LSN or xmin unless there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exists a consistent snapshot at that point. Otherwise, after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * promotion, the slots may not reach a consistent point <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confirmed_flush_lsn which can lead to a data loss. To avoid data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loss, we let slot machinery advance the slot which ensures that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapbuilder/slot statuses are updated properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="snapbuild.c.html#L2142" title="replication/logical/snapbuild.c:2142">SnapBuildSnapshotExists</a>(remote_slot-&gt;restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the slot info directly if there is a serialized snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at the restart_lsn, as the slot can quickly reach consistency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at restart_lsn by restoring the snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.restart_lsn = remote_slot-&gt;restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.confirmed_flush = remote_slot-&gt;confirmed_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.catalog_xmin = remote_slot-&gt;catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_consistent_snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *found_consistent_snapshot = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="logical.c.html#L2060" title="replication/logical/logical.c:2060">LogicalSlotAdvanceAndCheckSnapState</a>(remote_slot-&gt;confirmed_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_consistent_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.confirmed_flush != remote_slot-&gt;confirmed_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;synchronized confirmed_flush for slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> differs from remote slot&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Remote slot has LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> but local slot has LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(remote_slot-&gt;confirmed_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(slot-&gt;data.confirmed_flush)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; updated_xmin_or_lsn = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remote_dbid != slot-&gt;data.database ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;two_phase != slot-&gt;data.two_phase ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;failover != slot-&gt;data.failover ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(remote_slot-&gt;plugin, NameStr(slot-&gt;data.plugin)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NameData&nbsp; &nbsp; plugin_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoid expensive operations while holding a spinlock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;plugin_name, remote_slot-&gt;plugin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.plugin = plugin_name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.database = remote_dbid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.two_phase = remote_slot-&gt;two_phase;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.failover = remote_slot-&gt;failover;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; updated_config = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to write the changed xmin to disk *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* we change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-memory value, otherwise after a crash we wouldn't know that some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog tuples might have been removed already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updated_config || updated_xmin_or_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now the new xmin is safely on disk, we can let the global value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance. We do not take ProcArrayLock or similar since we only advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmin here and there's not much harm done by a concurrent computation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * missing that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updated_xmin_or_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;effective_catalog_xmin = remote_slot-&gt;catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1049" title="replication/slot.c:1049">ReplicationSlotsComputeRequiredXmin</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1105" title="replication/slot.c:1105">ReplicationSlotsComputeRequiredLSN</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> updated_config || updated_xmin_or_lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the list of local logical slots that are synchronized from the<br/></li>
<li></span><span class="Comment"> * primary server.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L333">&#x200c;</a><span class="linkable">get_local_synced_slots</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *local_slots = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationSlotControlLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlot *s = &amp;<a href="../slot.c.html#L135" title="replication/slot.c:135">ReplicationSlotCtl</a>-&gt;replication_slots[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if it is a synchronized slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;in_use &amp;&amp; s-&gt;data.synced)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(SlotIsLogical(s));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; local_slots = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(local_slots, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationSlotControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> local_slots;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function to check if local_slot is required to be retained.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return false either if local_slot does not exist in the remote_slots list<br/></li>
<li></span><span class="Comment"> * or is invalidated while the corresponding remote slot is still valid,<br/></li>
<li></span><span class="Comment"> * otherwise true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">local_sync_slot_required</span>(ReplicationSlot *local_slot, List *remote_slots)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; remote_exists = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locally_invalidated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach_ptr(<a href="#L135" title="replication/logical/slotsync.c:135">RemoteSlot</a>, remote_slot, remote_slots)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(remote_slot-&gt;name, NameStr(local_slot-&gt;data.name)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_exists = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If remote slot is not invalidated but local slot is marked as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidated, then set locally_invalidated flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;local_slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locally_invalidated =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (remote_slot-&gt;invalidated == RS_INVAL_NONE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (local_slot-&gt;data.invalidated != RS_INVAL_NONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;local_slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (remote_exists &amp;&amp; !locally_invalidated);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop local obsolete slots.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Drop the local slots that no longer need to be synced i.e. these either do<br/></li>
<li></span><span class="Comment"> * not exist on the primary or are no longer enabled for failover.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Additionally, drop <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slots that are valid on the primary but got<br/></li>
<li></span><span class="Comment"> * invalidated on the standby. This situation may occur due to the following<br/></li>
<li></span><span class="Comment"> * reasons:<br/></li>
<li></span><span class="Comment"> * - The 'max_slot_wal_keep_size' on the standby is insufficient to retain WAL<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> from the restart_lsn of the slot.<br/></li>
<li></span><span class="Comment"> * - 'primary_slot_name' is temporarily reset to null and the physical slot is<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; removed.<br/></li>
<li></span><span class="Comment"> * These dropped slots will get recreated in <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> sync-cycle and it is okay to<br/></li>
<li></span><span class="Comment"> * drop and recreate such slots as long as these are not consumable on the<br/></li>
<li></span><span class="Comment"> * standby (which is the case currently).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Change of '<a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>' on the primary server to a level <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than<br/></li>
<li></span><span class="Comment"> * logical may also result in slot invalidation and removal on the standby.<br/></li>
<li></span><span class="Comment"> * This is because such '<a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>' change is only possible if the logical<br/></li>
<li></span><span class="Comment"> * slots are removed on the primary server, so it's expected to see the<br/></li>
<li></span><span class="Comment"> * slots being invalidated and removed on the standby too (and re-created<br/></li>
<li></span><span class="Comment"> * if they are re-created on the primary server).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L417">&#x200c;</a></span><span class="linkable">drop_local_obsolete_slots</span>(List *remote_slot_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *local_slots = <a href="#L333" title="replication/logical/slotsync.c:333">get_local_synced_slots</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach_ptr(ReplicationSlot, local_slot, local_slots)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Drop the local slot if it is not required to be retained. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L364" title="replication/logical/slotsync.c:364">local_sync_slot_required</a>(local_slot, remote_slot_list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; synced_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use shared lock to prevent a conflict with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../slot.c.html#L1270" title="replication/slot.c:1270">ReplicationSlotsDropDBSlots</a>(), trying to drop the same slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during a drop-database operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1083" title="storage/lmgr/lmgr.c:1083">LockSharedObject</a>(DatabaseRelationId, local_slot-&gt;data.database,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the small window between getting the slot to drop and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locking the database, there is a possibility of a parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * database drop by the startup process and the creation of a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot by the user. This new user-created slot may end up using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same shared memory as that of 'local_slot'. Thus check if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local_slot is still the synced one <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * drop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;local_slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; synced_slot = local_slot-&gt;in_use &amp;&amp; local_slot-&gt;data.synced;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;local_slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (synced_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L540" title="replication/slot.c:540">ReplicationSlotAcquire</a>(NameStr(local_slot-&gt;data.name), <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L868" title="replication/slot.c:868">ReplicationSlotDropAcquired</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1142" title="storage/lmgr/lmgr.c:1142">UnlockSharedObject</a>(DatabaseRelationId, local_slot-&gt;data.database,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;dropped replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of dbid </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(local_slot-&gt;data.name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; local_slot-&gt;data.database));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reserve WAL for the currently active local slot using the specified WAL<br/></li>
<li></span><span class="Comment"> * location (restart_lsn).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the given WAL location has been removed, reserve WAL using the oldest<br/></li>
<li></span><span class="Comment"> * existing WAL segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L474">&#x200c;</a></span><span class="linkable">reserve_wal_for_local_slot</span>(XLogRecPtr restart_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; oldest_segno;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(XLogRecPtrIsInvalid(slot-&gt;data.restart_lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.restart_lsn = restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent WAL removal as fast as possible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1105" title="replication/slot.c:1105">ReplicationSlotsComputeRequiredLSN</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(slot-&gt;data.restart_lsn, segno, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the oldest existing WAL segment file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally, we can determine it by using the last removed segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number. However, if no WAL segment files have been removed by a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint since startup, we need to search for the oldest segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file from the current timeline existing in XLOGDIR.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Currently, we are searching for the oldest segment in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current timeline as there is less chance of the slot's restart_lsn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from being some prior timeline, and even if it happens, in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worst case, we will wait to sync till the slot's restart_lsn moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the current timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldest_segno = <a href="../../access/transam/xlog.c.html#L3747" title="access/transam/xlog.c:3747">XLogGetLastRemovedSegno</a>() + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_segno == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; cur_timeline;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiverfuncs.c.html#L331" title="replication/walreceiverfuncs.c:331">GetWalRcvFlushRecPtr</a>(<span class="Constant">NULL</span>, &amp;cur_timeline);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_segno = <a href="../../access/transam/xlog.c.html#L3763" title="access/transam/xlog.c:3763">XLogGetOldestSegno</a>(cur_timeline);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;segno: &quot;</span> UINT64_FORMAT <span class="Constant">&quot; of purposed restart_lsn for the synced slot, oldest_segno: &quot;</span> UINT64_FORMAT <span class="Constant">&quot; available&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; segno, oldest_segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If all required WAL is still there, great, otherwise retry. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot should prevent further removal of WAL, unless there's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrent <a href="../slot.c.html#L1105" title="replication/slot.c:1105">ReplicationSlotsComputeRequiredLSN</a>() after we've written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new restart_lsn above, so normally we should never need to loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than twice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segno &gt;= oldest_segno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Retry using the location of the oldest wal segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNoOffsetToRecPtr(oldest_segno, <span class="Constant">0</span>, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, restart_lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the remote restart_lsn and catalog_xmin have caught up with the<br/></li>
<li></span><span class="Comment"> * local ones, then update the LSNs and persist the local synced slot for<br/></li>
<li></span><span class="Comment"> * future synchronization; otherwise, do nothing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true if the slot is marked as RS_PERSISTENT (sync-ready), otherwise<br/></li>
<li></span><span class="Comment"> * false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L545">&#x200c;</a></span><span class="linkable">update_and_persist_local_synced_slot</span>(<a href="#L135" title="replication/logical/slotsync.c:135">RemoteSlot</a> *remote_slot, Oid remote_dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_consistent_snapshot = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot_precedes = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L168" title="replication/logical/slotsync.c:168">update_local_synced_slot</a>(remote_slot, remote_dbid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found_consistent_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;remote_slot_precedes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the primary server has caught up. Refer to the comment atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the file for details on this check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (remote_slot_precedes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The remote slot didn't catch up to locally reserved position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not drop the slot because the restart_lsn can be ahead of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current location when recreating the slot in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> cycle. It may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * take more time to create such a slot. Therefore, we keep this slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and attempt the synchronization in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't persist the slot if it cannot reach the consistent point from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart_lsn. See comments atop this file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found_consistent_snapshot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not sync slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, remote_slot-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Logical decoding cannot <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> consistent point from local slot's LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(slot-&gt;data.restart_lsn)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../slot.c.html#L1027" title="replication/slot.c:1027">ReplicationSlotPersist</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;newly created slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is sync-ready <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_slot-&gt;name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Synchronize a single slot to the given position.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This creates a new slot if there is no existing one and updates the<br/></li>
<li></span><span class="Comment"> * metadata of the slot as per the data received from the primary server.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The slot is created as a temporary slot and stays in the same state until the<br/></li>
<li></span><span class="Comment"> * remote_slot catches up with locally reserved position and local slot is<br/></li>
<li></span><span class="Comment"> * updated. The slot is then persisted and is considered as sync-ready for<br/></li>
<li></span><span class="Comment"> * periodic syncs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns TRUE if the local slot is updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L609">&#x200c;</a></span><span class="linkable">synchronize_one_slot</span>(<a href="#L135" title="replication/logical/slotsync.c:135">RemoteSlot</a> *remote_slot, Oid remote_dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; latestFlushPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; slot_updated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that concerned WAL is received and flushed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> syncing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot to target lsn received from the primary server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; latestFlushPtr = <a href="../walsender.c.html#L3504" title="replication/walsender.c:3504">GetStandbyFlushRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remote_slot-&gt;confirmed_lsn &gt; latestFlushPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can get here only if GUC '<a href="../slot.c.html#L148" title="replication/slot.c:148">standby_slot_names</a>' on the primary server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was not configured correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(AmLogicalSlotSyncWorkerProcess() ? LOG : ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;skipping slot synchronization as the received slot sync&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> for slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is ahead of the standby position </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(remote_slot-&gt;confirmed_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_slot-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(latestFlushPtr)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for the named slot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((slot = <a href="../slot.c.html#L464" title="replication/slot.c:464">SearchNamedReplicationSlot</a>(remote_slot-&gt;name, <span class="Constant">true</span>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; synced;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; synced = slot-&gt;data.synced;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* User-created slot with the same name exists, raise ERROR. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!synced)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;exiting from slot synchronization because same&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; name slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists on the standby&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remote_slot-&gt;name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The slot has been synchronized <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is important to acquire the slot here <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidation. If we don't acquire the slot first, there could be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * race condition that the local slot could be invalidated just after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking the 'invalidated' flag here and we could end up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwriting 'invalidated' flag to remote_slot's value. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../slot.c.html#L1543" title="replication/slot.c:1543">InvalidatePossiblyObsoleteSlot</a>() where it invalidates slot directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the slot is not acquired by other processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: If it ever turns out that slot acquire/release is costly for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases when <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the slot properties is changed then we can do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pre-check to ensure that at least one of the slot properties is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring the slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L540" title="replication/slot.c:540">ReplicationSlotAcquire</a>(remote_slot-&gt;name, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(slot == <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the invalidation cause from remote only if local slot is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidated locally, we don't want to overwrite existing one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.invalidated == RS_INVAL_NONE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;invalidated != RS_INVAL_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.invalidated = remote_slot-&gt;invalidated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure the invalidated state persists across server restart */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_updated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip the sync of an invalidated slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.invalidated != RS_INVAL_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slot_updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Slot not ready yet, let's attempt to make it sync-ready <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.persistency == RS_TEMPORARY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_updated = <a href="#L545" title="replication/logical/slotsync.c:545">update_and_persist_local_synced_slot</a>(remote_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_dbid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Slot ready for sync, so sync it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sanity check: As long as the invalidations are handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriately as above, this should never happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to check restart_lsn here. See the comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L168" title="replication/logical/slotsync.c:168">update_local_synced_slot</a>() for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remote_slot-&gt;confirmed_lsn &lt; slot-&gt;data.confirmed_flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;cannot synchronize local slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Local slot's start streaming location LSN(</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">) is ahead of remote slot's LSN(</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(slot-&gt;data.confirmed_flush),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(remote_slot-&gt;confirmed_lsn)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_updated = <a href="#L168" title="replication/logical/slotsync.c:168">update_local_synced_slot</a>(remote_slot, remote_dbid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise create the slot first. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NameData&nbsp; &nbsp; plugin_name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmin_horizon = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip creating the local slot if remote_slot is invalidated already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remote_slot-&gt;invalidated != RS_INVAL_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We create temporary slots instead of ephemeral slots here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we want the slots to survive after releasing them. This is done to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid dropping and re-creating the slots in each synchronization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cycle if the restart_lsn or catalog_xmin of the remote slot has not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caught up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L309" title="replication/slot.c:309">ReplicationSlotCreate</a>(remote_slot-&gt;name, <span class="Constant">true</span>, RS_TEMPORARY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;two_phase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;failover,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For shorter lines. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoid expensive operations while holding a spinlock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;plugin_name, remote_slot-&gt;plugin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.database = remote_dbid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.plugin = plugin_name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L474" title="replication/logical/slotsync.c:474">reserve_wal_for_local_slot</a>(remote_slot-&gt;restart_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmin_horizon = <a href="../../storage/ipc/procarray.c.html#L2932" title="storage/ipc/procarray.c:2932">GetOldestSafeDecodingTransactionId</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;effective_catalog_xmin = xmin_horizon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.catalog_xmin = xmin_horizon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1049" title="replication/slot.c:1049">ReplicationSlotsComputeRequiredXmin</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L545" title="replication/logical/slotsync.c:545">update_and_persist_local_synced_slot</a>(remote_slot, remote_dbid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_updated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slot_updated;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Synchronize slots.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Gets the failover logical slots info from the primary server and updates<br/></li>
<li></span><span class="Comment"> * the slots locally. Creates the slots if not present on the standby.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns TRUE if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the slots gets updated in this sync-cycle.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L791">&#x200c;</a></span><span class="linkable">synchronize_slots</span>(<a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>)<br/></li>
<li>{<br/></li>
<li><a id="L793">&#x200c;</a><span class="PreProc">#define <span class="linkable">SLOTSYNC_COLUMN_COUNT</span> </span><span class="Constant">9<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotRow[<a href="#L793" title="replication/logical/slotsync.c:793">SLOTSYNC_COLUMN_COUNT</a>] = {TEXTOID, TEXTOID, LSNOID,<br/></li>
<li>&nbsp; &nbsp; LSNOID, XIDOID, BOOLOID, BOOLOID, TEXTOID, TEXTOID};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; WalRcvExecResult *res;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *tupslot;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *remote_slot_list = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; some_slot_updated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query = <span class="Constant">&quot;SELECT slot_name, plugin, confirmed_flush_lsn,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; restart_lsn, catalog_xmin, two_phase, failover,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; database, invalidation_reason&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; FROM pg_catalog.pg_replication_slots&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; WHERE failover and NOT temporary&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The syscache access in walrcv_exec() needs a transaction env. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Execute the query */<br/></li>
<li></span>&nbsp; &nbsp; res = walrcv_exec(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>, query, <a href="#L793" title="replication/logical/slotsync.c:793">SLOTSYNC_COLUMN_COUNT</a>, slotRow);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res-&gt;status != WALRCV_OK_TUPLES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fetch failover logical slots info from the primary server: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; res-&gt;err));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct the remote_slot tuple and synchronize each slot locally */<br/></li>
<li></span>&nbsp; &nbsp; tupslot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(res-&gt;tupledesc, &amp;<a href="../../executor/execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(res-&gt;tuplestore, <span class="Constant">true</span>, <span class="Constant">false</span>, tupslot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="replication/logical/slotsync.c:135">RemoteSlot</a> *remote_slot = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L135" title="replication/logical/slotsync.c:135">RemoteSlot</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;name = TextDatumGetCString(slot_getattr(tupslot, ++col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;plugin = TextDatumGetCString(slot_getattr(tupslot, ++col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible to get null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for LSN and Xmin if slot is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidated on the primary server, so handle accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; d = slot_getattr(tupslot, ++col, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;confirmed_lsn = isnull ? InvalidXLogRecPtr :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetLSN(d);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d = slot_getattr(tupslot, ++col, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;restart_lsn = isnull ? InvalidXLogRecPtr : DatumGetLSN(d);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d = slot_getattr(tupslot, ++col, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;catalog_xmin = isnull ? InvalidTransactionId :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetTransactionId(d);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;two_phase = DatumGetBool(slot_getattr(tupslot, ++col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;failover = DatumGetBool(slot_getattr(tupslot, ++col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;database = TextDatumGetCString(slot_getattr(tupslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ++col, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; d = slot_getattr(tupslot, ++col, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;invalidated = isnull ? RS_INVAL_NONE :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L2394" title="replication/slot.c:2394">GetSlotInvalidationCause</a>(TextDatumGetCString(d));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(col == <a href="#L793" title="replication/logical/slotsync.c:793">SLOTSYNC_COLUMN_COUNT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If restart_lsn, confirmed_lsn or catalog_xmin is invalid but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot is valid, that means we have fetched the remote_slot in its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RS_EPHEMERAL state. In such a case, don't sync it; we can always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sync it in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> sync cycle when the remote_slot is persisted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and has valid lsn(s) and xmin <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: In future, if we plan to expose 'slot-&gt;data.persistency' in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_replication_slots view, then we can avoid fetching RS_EPHEMERAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slots in the first place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((XLogRecPtrIsInvalid(remote_slot-&gt;restart_lsn) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtrIsInvalid(remote_slot-&gt;confirmed_lsn) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !TransactionIdIsValid(remote_slot-&gt;catalog_xmin)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot-&gt;invalidated == RS_INVAL_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(remote_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create list of remote slots */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_slot_list = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(remote_slot_list, remote_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(tupslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Drop local slots that no longer need to be synced. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L417" title="replication/logical/slotsync.c:417">drop_local_obsolete_slots</a>(remote_slot_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now sync the slots locally */<br/></li>
<li></span>&nbsp; &nbsp; foreach_ptr(<a href="#L135" title="replication/logical/slotsync.c:135">RemoteSlot</a>, remote_slot, remote_slot_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_dbid = <a href="../../commands/dbcommands.c.html#L3106" title="commands/dbcommands.c:3106">get_database_oid</a>(remote_slot-&gt;database, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use shared lock to prevent a conflict with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../slot.c.html#L1270" title="replication/slot.c:1270">ReplicationSlotsDropDBSlots</a>(), trying to drop the same slot during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a drop-database operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1083" title="storage/lmgr/lmgr.c:1083">LockSharedObject</a>(DatabaseRelationId, remote_dbid, <span class="Constant">0</span>, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; some_slot_updated |= <a href="#L609" title="replication/logical/slotsync.c:609">synchronize_one_slot</a>(remote_slot, remote_dbid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1142" title="storage/lmgr/lmgr.c:1142">UnlockSharedObject</a>(DatabaseRelationId, remote_dbid, <span class="Constant">0</span>, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We are done, free remote_slot_list elements */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(remote_slot_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walrcv_clear_result(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (started_tx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> some_slot_updated;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Checks the remote server info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We ensure that the 'primary_slot_name' exists on the remote server and the<br/></li>
<li></span><span class="Comment"> * remote server is not a standby node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L934">&#x200c;</a></span><span class="linkable">validate_remote_info</span>(<a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>)<br/></li>
<li>{<br/></li>
<li><a id="L936">&#x200c;</a><span class="PreProc">#define <span class="linkable">PRIMARY_INFO_OUTPUT_COL_COUNT</span> </span><span class="Constant">2<br/></li>
<li></span>&nbsp; &nbsp; WalRcvExecResult *res;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotRow[<a href="#L936" title="replication/logical/slotsync.c:936">PRIMARY_INFO_OUTPUT_COL_COUNT</a>] = {BOOLOID, BOOLOID};<br/></li>
<li>&nbsp; &nbsp; StringInfoData cmd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *tupslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; remote_in_recovery;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; primary_slot_valid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;cmd);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;cmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SELECT <a href="../../access/transam/xlogfuncs.c.html#L642" title="access/transam/xlogfuncs.c:642">pg_is_in_recovery</a>(), count(*) = 1&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; FROM pg_catalog.pg_replication_slots&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; WHERE slot_type='physical' AND slot_name=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/adt/quote.c.html#L103" title="utils/adt/quote.c:103">quote_literal_cstr</a>(<a href="../../access/transam/xlogrecovery.c.html#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The syscache access in walrcv_exec() needs a transaction env. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = walrcv_exec(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>, cmd.data, <a href="#L936" title="replication/logical/slotsync.c:936">PRIMARY_INFO_OUTPUT_COL_COUNT</a>, slotRow);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cmd.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res-&gt;status != WALRCV_OK_TUPLES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fetch primary_slot_name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> info from the primary server: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/xlogrecovery.c.html#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a>, res-&gt;err),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check if primary_slot_name is configured correctly.&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupslot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(res-&gt;tupledesc, &amp;<a href="../../executor/execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(res-&gt;tuplestore, <span class="Constant">true</span>, <span class="Constant">false</span>, tupslot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;failed to fetch tuple for the primary server slot specified by primary_slot_name&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remote_in_recovery = DatumGetBool(slot_getattr(tupslot, <span class="Constant">1</span>, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Slot sync is currently not supported on a cascading standby. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because if we allow it, the primary server needs to wait for all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cascading standbys, otherwise, logical subscribers can still be ahead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of one of the cascading standbys which we plan to promote. Thus, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid this additional complexity, we restrict it for the time being.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (remote_in_recovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot synchronize replication slots from a standby server&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; primary_slot_valid = DatumGetBool(slot_getattr(tupslot, <span class="Constant">2</span>, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!primary_slot_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot synchronization requires valid primary_slot_name&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: second %s is a GUC variable name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> specified by </span><span class="Special">%s</span><span class="Constant"> does not exist on the primary server.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogrecovery.c.html#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a>, <span class="Constant">&quot;primary_slot_name&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(tupslot);<br/></li>
<li>&nbsp; &nbsp; walrcv_clear_result(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (started_tx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Checks if dbname is specified in 'primary_conninfo'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Error out if not specified otherwise return it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1013">&#x200c;</a><span class="linkable">CheckAndGetDbnameFromConninfo</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The slot synchronization needs a database connection for walrcv_exec to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dbname = walrcv_get_dbname_from_conninfo(<a href="../../access/transam/xlogrecovery.c.html#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dbname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * translator: dbname is a specific option; %s is a GUC variable name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot synchronization requires dbname to be specified in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;primary_conninfo&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dbname;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true if all necessary GUCs for slot synchronization are set<br/></li>
<li></span><span class="Comment"> * appropriately, otherwise, return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1039">&#x200c;</a></span><span class="linkable">ValidateSlotSyncParams</span>(<span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Logical slot sync/creation requires <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= logical.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sincle altering the <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> requires a server restart, so error out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in this case regardless of elevel provided by caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &lt; WAL_LEVEL_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot synchronization requires <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= </span><span class="Special">\&quot;</span><span class="Constant">logical</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A physical replication slot(primary_slot_name) is required on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * primary to ensure that the rows needed by the standby are not removed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after restarting, so that the synchronized slot on the standby will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be invalidated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogrecovery.c.html#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a> == <span class="Constant">NULL</span> || *<a href="../../access/transam/xlogrecovery.c.html#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a> == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a GUC variable name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot synchronization requires </span><span class="Special">%s</span><span class="Constant"> to be defined&quot;</span>, <span class="Constant">&quot;primary_slot_name&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a> must be enabled to cooperate with the physical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication slot, which allows informing the primary about the xmin and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog_xmin <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> on the standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a GUC variable name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot synchronization requires </span><span class="Special">%s</span><span class="Constant"> to be enabled&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="../walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The primary_conninfo is required to make connection to primary for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * getting slots information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlogrecovery.c.html#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a> == <span class="Constant">NULL</span> || *<a href="../../access/transam/xlogrecovery.c.html#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a> == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a GUC variable name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot synchronization requires </span><span class="Special">%s</span><span class="Constant"> to be defined&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;primary_conninfo&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-read the config file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Exit if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the slot sync GUCs have changed. The postmaster will<br/></li>
<li></span><span class="Comment"> * restart it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1106">&#x200c;</a></span><span class="linkable">slotsync_reread_config</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *old_primary_conninfo = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../access/transam/xlogrecovery.c.html#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *old_primary_slotname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../access/transam/xlogrecovery.c.html#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_sync_replication_slots = <a href="#L109" title="replication/logical/slotsync.c:109">sync_replication_slots</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_hot_standby_feedback = <a href="../walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; conninfo_changed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; primary_slotname_changed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L109" title="replication/logical/slotsync.c:109">sync_replication_slots</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conninfo_changed = strcmp(old_primary_conninfo, <a href="../../access/transam/xlogrecovery.c.html#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; primary_slotname_changed = strcmp(old_primary_slotname, <a href="../../access/transam/xlogrecovery.c.html#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a>) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(old_primary_conninfo);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(old_primary_slotname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (old_sync_replication_slots != <a href="#L109" title="replication/logical/slotsync.c:109">sync_replication_slots</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a GUC variable name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot sync worker will shutdown because </span><span class="Special">%s</span><span class="Constant"> is disabled&quot;</span>, <span class="Constant">&quot;<a href="#L109" title="replication/logical/slotsync.c:109">sync_replication_slots</a>&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (conninfo_changed ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; primary_slotname_changed ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (old_hot_standby_feedback != <a href="../walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot sync worker will restart because of a parameter change&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the last-start time for this worker so that the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can restart it without <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for <a href="#L122" title="replication/logical/slotsync.c:122">SLOTSYNC_RESTART_INTERVAL_SEC</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;last_start_time = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interrupt handler for <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop of slot sync worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1155">&#x200c;</a></span><span class="linkable">ProcessSlotSyncInterrupts</span>(<a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot sync worker is shutting down on receiving SIGINT&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1106" title="replication/logical/slotsync.c:1106">slotsync_reread_config</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Connection <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> function for slotsync worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called on slotsync worker exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1177">&#x200c;</a></span><span class="linkable">slotsync_worker_disconnect</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a> = (<a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *) DatumGetPointer(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walrcv_disconnect(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup function for slotsync worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called on slotsync worker exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1190">&#x200c;</a></span><span class="linkable">slotsync_worker_onexit</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to do slots <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> here just like <a href="../walsender.c.html#L327" title="replication/walsender.c:327">WalSndErrorCleanup</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The startup process during promotion invokes <a href="#L1562" title="replication/logical/slotsync.c:1562">ShutDownSlotSync</a>() which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * waits for slot sync to finish and it does that by checking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'syncing' flag. Thus the slot sync worker must be done with slots'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release and <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> to avoid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dangling temporary slots or active<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slots <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it marks itself as finished syncing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure active replication slots are released */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> the temporary slots. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../slot.c.html#L745" title="replication/slot.c:745">ReplicationSlotCleanup</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;pid = InvalidPid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a> is true, it indicates that the process errored out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without resetting the flag. So, we need to clean up shared memory and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reset the flag here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;syncing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sleep for long enough that we believe it's likely that the slots on primary<br/></li>
<li></span><span class="Comment"> * get updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is no slot activity the wait time between sync-cycles will double<br/></li>
<li></span><span class="Comment"> * (to a maximum of 30s). If there is some slot activity the wait time between<br/></li>
<li></span><span class="Comment"> * sync-cycles is reset to the minimum (200ms).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1236">&#x200c;</a></span><span class="linkable">wait_for_slot_activity</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> some_slot_updated)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!some_slot_updated)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No slots were updated, so double the sleep time, but not beyond the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maximum allowable value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="replication/logical/slotsync.c:119">sleep_ms</a> = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L119" title="replication/logical/slotsync.c:119">sleep_ms</a> * <span class="Constant">2</span>, <a href="#L117" title="replication/logical/slotsync.c:117">MAX_SLOTSYNC_WORKER_NAPTIME_MS</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some slots were updated since the last sleep, so reset the sleep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="replication/logical/slotsync.c:119">sleep_ms</a> = <a href="#L116" title="replication/logical/slotsync.c:116">MIN_SLOTSYNC_WORKER_NAPTIME_MS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L119" title="replication/logical/slotsync.c:119">sleep_ms</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_REPLICATION_SLOTSYNC_MAIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Emit an error if a promotion or a concurrent sync call is in progress.<br/></li>
<li></span><span class="Comment"> * Otherwise, advertise that a sync is in progress.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1271">&#x200c;</a></span><span class="linkable">check_and_set_sync_info</span>(pid_t worker_pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The worker pid must not be already assigned in <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(worker_pid == InvalidPid || <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;pid == InvalidPid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit an error if startup process signaled the slot sync machinery to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stop. See comments atop <a href="#L97" title="replication/logical/slotsync.c:97">SlotSyncCtxStruct</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;stopSignaled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot synchronize replication slots when standby promotion is ongoing&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;syncing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot synchronize replication slots concurrently&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;syncing = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advertise the required PID so that the startup process can kill the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot sync worker on promotion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;pid = worker_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset syncing flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1315">&#x200c;</a></span><span class="linkable">reset_syncing_flag</span>()<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;syncing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a> = <span class="Constant">false</span>;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop of our worker process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It connects to the primary server, fetches logical failover slots<br/></li>
<li></span><span class="Comment"> * information periodically in order to create and sync the slots.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1331">&#x200c;</a></span><span class="linkable">ReplSlotSyncWorkerMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *err;<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li>&nbsp; &nbsp; StringInfoData app_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_SLOTSYNC_WORKER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/misc/ps_status.c.html#L267" title="utils/misc/ps_status.c:267">init_ps_display</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(InitProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a per-backend PGPROC struct in shared memory.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we access <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Early initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/postinit.c.html#L645" title="utils/init/postinit.c:645">BaseInit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an exception is encountered, processing resumes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We just need to clean up, report the error, and go away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we do not have this handling here, then since this worker process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operates at the bottom of the exception stack, ERRORs turn into FATALs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Therefore, we create our own exception handler to catch ERRORs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevents interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the server log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> go away.&nbsp; Note that because we called <a href="../../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callback was registered to do <a href="../../storage/lmgr/proc.c.html#L834" title="storage/lmgr/proc.c:834">ProcKill</a>, which will clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle ereport(ERROR) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup signal handling */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="../../postmaster/interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="../../postmaster/interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGFPE</span>, <a href="../../tcop/postgres.c.html#L3019" title="tcop/postgres.c:3019">FloatExceptionHandler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1271" title="replication/logical/slotsync.c:1271">check_and_set_sync_info</a>(<a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG, <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;slot sync worker started&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Register it as soon as <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;pid is initialized. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L1190" title="replication/logical/slotsync.c:1190">slotsync_worker_onexit</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Establishes SIGALRM handler and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> timeout module. It is needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by <a href="../../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> to register different timeouts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the libpq-specific <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/fmgr/dfmgr.c.html#L144" title="utils/fmgr/dfmgr.c:144">load_file</a>(<span class="Constant">&quot;libpqwalreceiver&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unblock signals (they were blocked when the postmaster forked us)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set always-secure search path, so malicious users can't redirect user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code (e.g. operators).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's not strictly necessary since we won't be scanning or writing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user table locally, but it's good to retain it here for added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * precaution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;search_path&quot;</span>, <span class="Constant">&quot;&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbname = <a href="#L1013" title="replication/logical/slotsync.c:1013">CheckAndGetDbnameFromConninfo</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Connect to the database specified by the user in primary_conninfo. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need a database connection for walrcv_exec to work which we use to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch slot information from the remote node. See comments atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../libpqwalreceiver/libpqwalreceiver.c.html#L1235" title="replication/libpqwalreceiver/libpqwalreceiver.c:1235">libpqrcv_exec</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not specify a specific user here since the slot sync worker will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operate as a <a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>. This is safe because the slot sync worker does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not interact with user tables, eliminating the risk of executing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arbitrary code within triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>(dbname, InvalidOid, <span class="Constant">NULL</span>, InvalidOid, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(NormalProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;app_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L540" title="utils/misc/guc_tables.c:540">cluster_name</a>[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;app_name, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"><a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../utils/misc/guc_tables.c.html#L540" title="utils/misc/guc_tables.c:540">cluster_name</a>, <span class="Constant">&quot;slotsync worker&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;app_name, <span class="Constant">&quot;slotsync worker&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Establish the connection to the primary server for slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * synchronization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a> = walrcv_connect(<a href="../../access/transam/xlogrecovery.c.html#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app_name.data, &amp;err);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(app_name.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the primary server: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, err));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register the disconnection callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: This can be combined with previous <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> registration of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1190" title="replication/logical/slotsync.c:1190">slotsync_worker_onexit</a>() but that will need the connection to be made<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * global and we want to avoid introducing global for this purpose.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L1177" title="replication/logical/slotsync.c:1177">slotsync_worker_disconnect</a>, PointerGetDatum(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Using the specified primary server connection, check that we are not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cascading standby and slot configured in 'primary_slot_name' exists on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the primary server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L934" title="replication/logical/slotsync.c:934">validate_remote_info</a>(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Main loop to synchronize slots */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; some_slot_updated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1155" title="replication/logical/slotsync.c:1155">ProcessSlotSyncInterrupts</a>(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; some_slot_updated = <a href="#L791" title="replication/logical/slotsync.c:791">synchronize_slots</a>(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1236" title="replication/logical/slotsync.c:1236">wait_for_slot_activity</a>(some_slot_updated);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The slot sync worker can't get here because it will only stop when it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receives a SIGINT from the startup process, or when there is an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the inactive_since property for synced slots.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this function is currently called when we shutdown the slot<br/></li>
<li></span><span class="Comment"> * sync machinery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1510">&#x200c;</a></span><span class="linkable">update_synced_slots_inactive_since</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to update inactive_since only when we are promoting standby to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correctly interpret the inactive_since if the standby gets promoted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a restart. We don't want the slots to appear inactive for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long time after promotion if they haven't been synchronized recently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whoever acquires the slot i.e.makes the slot active will reset it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xlogrecovery.c.html#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The slot sync worker or SQL function mustn't be running by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;pid == InvalidPid) &amp;&amp; !<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;syncing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationSlotControlLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="../slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlot *s = &amp;<a href="../slot.c.html#L135" title="replication/slot.c:135">ReplicationSlotCtl</a>-&gt;replication_slots[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if it is a synchronized slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;in_use &amp;&amp; s-&gt;data.synced)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(SlotIsLogical(s));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The slot must not be acquired by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s-&gt;active_pid == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the same inactive_since time for all the slots. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;s-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;inactive_since = <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;s-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationSlotControlLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Shut down the slot sync worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function sends signal to shutdown slot sync worker, if required. It<br/></li>
<li></span><span class="Comment"> * also waits till the slot sync worker has exited or<br/></li>
<li></span><span class="Comment"> * <a href="../slotfuncs.c.html#L866" title="replication/slotfuncs.c:866">pg_sync_replication_slots</a>() has finished.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1562">&#x200c;</a></span><span class="linkable">ShutDownSlotSync</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; worker_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;stopSignaled = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return if neither the slot sync worker is running nor the function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../slotfuncs.c.html#L866" title="replication/slotfuncs.c:866">pg_sync_replication_slots</a>() is executing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;syncing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1510" title="replication/logical/slotsync.c:1510">update_synced_slots_inactive_since</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; worker_pid = <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (worker_pid != InvalidPid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kill(worker_pid, <span class="Constant">SIGINT</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wait for slot sync to end */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, we don't expect to have to wait long */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">10L</span>, WAIT_EVENT_REPLICATION_SLOTSYNC_SHUTDOWN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure that no process is syncing the slots. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;syncing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1510" title="replication/logical/slotsync.c:1510">update_synced_slots_inactive_since</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1630" title="replication/logical/slotsync.c:1630">SlotSyncWorkerCanRestart</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if enough time (<a href="#L122" title="replication/logical/slotsync.c:122">SLOTSYNC_RESTART_INTERVAL_SEC</a>) has passed<br/></li>
<li></span><span class="Comment"> * since it was launched last. Otherwise returns false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a safety valve to protect against continuous respawn attempts if the<br/></li>
<li></span><span class="Comment"> * worker is dying immediately at launch. Note that since we will retry to<br/></li>
<li></span><span class="Comment"> * launch the worker from the postmaster <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, we will get another<br/></li>
<li></span><span class="Comment"> * chance later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1630">&#x200c;</a></span><span class="linkable">SlotSyncWorkerCanRestart</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; curtime = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return false if too soon since last start. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">unsigned</span> <span class="Type">int</span>) (curtime - <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;last_start_time) &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) <a href="#L122" title="replication/logical/slotsync.c:122">SLOTSYNC_RESTART_INTERVAL_SEC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;last_start_time = curtime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is current process syncing replication slots?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Could be either backend executing SQL function or slot sync worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1650">&#x200c;</a></span><span class="linkable">IsSyncingReplicationSlots</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Amount of shared memory required for slot synchronization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1659">&#x200c;</a><span class="linkable">SlotSyncShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L97" title="replication/logical/slotsync.c:97">SlotSyncCtxStruct</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the shared memory of slot synchronization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1668">&#x200c;</a></span><span class="linkable">SlotSyncShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="#L1659" title="replication/logical/slotsync.c:1659">SlotSyncShmemSize</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a> = (<a href="#L97" title="replication/logical/slotsync.c:97">SlotSyncCtxStruct</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Slot Sync Data&quot;</span>, size, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>, <span class="Constant">0</span>, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;pid = InvalidPid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockInit(&amp;<a href="#L106" title="replication/logical/slotsync.c:106">SlotSyncCtx</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> callback for slot sync SQL function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1688">&#x200c;</a></span><span class="linkable">slotsync_failure_callback</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a> = (<a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *) DatumGetPointer(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to do slots <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> here just like <a href="../walsender.c.html#L327" title="replication/walsender.c:327">WalSndErrorCleanup</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The startup process during promotion invokes <a href="#L1562" title="replication/logical/slotsync.c:1562">ShutDownSlotSync</a>() which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * waits for slot sync to finish and it does that by checking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'syncing' flag. Thus the SQL function must be done with slots' release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> to avoid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dangling temporary slots or active slots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it marks itself as finished syncing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure active replication slots are released */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> the synced temporary slots. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../slot.c.html#L745" title="replication/slot.c:745">ReplicationSlotCleanup</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The set <a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a> indicates that the process errored out without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resetting the flag. So, we need to clean up shared memory and reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="replication/logical/slotsync.c:129">syncing_slots</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1315" title="replication/logical/slotsync.c:1315">reset_syncing_flag</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walrcv_disconnect(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Synchronize the failover enabled replication slots using the specified<br/></li>
<li></span><span class="Comment"> * primary server connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1725">&#x200c;</a></span><span class="linkable">SyncReplicationSlots</span>(<a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_ENSURE_ERROR_CLEANUP(<a href="#L1688" title="replication/logical/slotsync.c:1688">slotsync_failure_callback</a>, PointerGetDatum(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>));<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1271" title="replication/logical/slotsync.c:1271">check_and_set_sync_info</a>(InvalidPid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L934" title="replication/logical/slotsync.c:934">validate_remote_info</a>(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L791" title="replication/logical/slotsync.c:791">synchronize_slots</a>(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cleanup the synced temporary slots */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L745" title="replication/slot.c:745">ReplicationSlotCleanup</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We are done with sync, so reset sync flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1315" title="replication/logical/slotsync.c:1315">reset_syncing_flag</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_ENSURE_ERROR_CLEANUP(<a href="#L1688" title="replication/logical/slotsync.c:1688">slotsync_failure_callback</a>, PointerGetDatum(<a href="../walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
