<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/proto.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/proto.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L50">column_in_column_list</a></li>
<li><a href="#L1217">logicalrep_message_type</a></li>
<li><a href="#L993">logicalrep_read_attrs</a></li>
<li><a href="#L74">logicalrep_read_begin</a></li>
<li><a href="#L145">logicalrep_read_begin_prepare</a></li>
<li><a href="#L109">logicalrep_read_commit</a></li>
<li><a href="#L278">logicalrep_read_commit_prepared</a></li>
<li><a href="#L564">logicalrep_read_delete</a></li>
<li><a href="#L436">logicalrep_read_insert</a></li>
<li><a href="#L1055">logicalrep_read_namespace</a></li>
<li><a href="#L401">logicalrep_read_origin</a></li>
<li><a href="#L239">logicalrep_read_prepare</a></li>
<li><a href="#L210">logicalrep_read_prepare_common</a></li>
<li><a href="#L700">logicalrep_read_rel</a></li>
<li><a href="#L336">logicalrep_read_rollback_prepared</a></li>
<li><a href="#L1192">logicalrep_read_stream_abort</a></li>
<li><a href="#L1137">logicalrep_read_stream_commit</a></li>
<li><a href="#L376">logicalrep_read_stream_prepare</a></li>
<li><a href="#L1087">logicalrep_read_stream_start</a></li>
<li><a href="#L618">logicalrep_read_truncate</a></li>
<li><a href="#L866">logicalrep_read_tuple</a></li>
<li><a href="#L756">logicalrep_read_typ</a></li>
<li><a href="#L492">logicalrep_read_update</a></li>
<li><a href="#L926">logicalrep_write_attrs</a></li>
<li><a href="#L60">logicalrep_write_begin</a></li>
<li><a href="#L127">logicalrep_write_begin_prepare</a></li>
<li><a href="#L89">logicalrep_write_commit</a></li>
<li><a href="#L248">logicalrep_write_commit_prepared</a></li>
<li><a href="#L533">logicalrep_write_delete</a></li>
<li><a href="#L414">logicalrep_write_insert</a></li>
<li><a href="#L643">logicalrep_write_message</a></li>
<li><a href="#L1035">logicalrep_write_namespace</a></li>
<li><a href="#L385">logicalrep_write_origin</a></li>
<li><a href="#L198">logicalrep_write_prepare</a></li>
<li><a href="#L166">logicalrep_write_prepare_common</a></li>
<li><a href="#L670">logicalrep_write_rel</a></li>
<li><a href="#L304">logicalrep_write_rollback_prepared</a></li>
<li><a href="#L1166">logicalrep_write_stream_abort</a></li>
<li><a href="#L1112">logicalrep_write_stream_commit</a></li>
<li><a href="#L364">logicalrep_write_stream_prepare</a></li>
<li><a href="#L1069">logicalrep_write_stream_start</a></li>
<li><a href="#L1103">logicalrep_write_stream_stop</a></li>
<li><a href="#L586">logicalrep_write_truncate</a></li>
<li><a href="#L769">logicalrep_write_tuple</a></li>
<li><a href="#L725">logicalrep_write_typ</a></li>
<li><a href="#L458">logicalrep_write_update</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L26">LOGICALREP_IS_REPLICA_IDENTITY</a></li>
<li><a href="#L28">MESSAGE_TRANSACTIONAL</a></li>
<li><a href="#L29">TRUNCATE_CASCADE</a></li>
<li><a href="#L30">TRUNCATE_RESTART_SEQS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * proto.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; logical replication protocol <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2015-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; src/backend/replication/logical/proto.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalproto.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Protocol message flags.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L26">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LOGICALREP_IS_REPLICA_IDENTITY</span> </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><a id="L28">&#x200c;</a><span class="PreProc">#define <span class="linkable">MESSAGE_TRANSACTIONAL</span> (</span><span class="Constant">1</span><span class="PreProc">&lt;&lt;</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L29">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TRUNCATE_CASCADE</span>&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc">&lt;&lt;</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L30">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TRUNCATE_RESTART_SEQS</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc">&lt;&lt;</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L926" title="replication/logical/proto.c:926">logicalrep_write_attrs</a>(StringInfo out, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *columns);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L769" title="replication/logical/proto.c:769">logicalrep_write_tuple</a>(StringInfo out, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary, Bitmapset *columns);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L993" title="replication/logical/proto.c:993">logicalrep_read_attrs</a>(StringInfo in, LogicalRepRelation *rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L866" title="replication/logical/proto.c:866">logicalrep_read_tuple</a>(StringInfo in, LogicalRepTupleData *tuple);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1035" title="replication/logical/proto.c:1035">logicalrep_write_namespace</a>(StringInfo out, Oid nspid);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L1055" title="replication/logical/proto.c:1055">logicalrep_read_namespace</a>(StringInfo in);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if a column is covered by a column list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Need to be careful about NULL, which is treated as a column list covering<br/></li>
<li></span><span class="Comment"> * all columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L50">&#x200c;</a></span><span class="linkable">column_in_column_list</span>(<span class="Type">int</span> attnum, Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (columns == <span class="Constant">NULL</span> || <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, columns));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write BEGIN to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="linkable">logicalrep_write_begin</span>(StringInfo out, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_BEGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fixed fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;final_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;xact_time.commit_time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, txn-&gt;xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read transaction BEGIN from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="linkable">logicalrep_read_begin</span>(StringInfo in, LogicalRepBeginData *begin_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read fields */<br/></li>
<li></span>&nbsp; &nbsp; begin_data-&gt;final_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (begin_data-&gt;final_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;final_lsn not set in begin message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; begin_data-&gt;committime = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; begin_data-&gt;xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write COMMIT to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="linkable">logicalrep_write_commit</span>(StringInfo out, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_COMMIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the flags field (unused for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(out, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;end_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;xact_time.commit_time);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read transaction COMMIT from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="linkable">logicalrep_read_commit</span>(StringInfo in, LogicalRepCommitData *commit_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read flags (unused for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized flags </span><span class="Special">%u</span><span class="Constant"> in commit message&quot;</span>, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read fields */<br/></li>
<li></span>&nbsp; &nbsp; commit_data-&gt;commit_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; commit_data-&gt;end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; commit_data-&gt;committime = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write BEGIN PREPARE to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="linkable">logicalrep_write_begin_prepare</span>(StringInfo out, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_BEGIN_PREPARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fixed fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;final_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;end_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;xact_time.prepare_time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> gid */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, txn-&gt;gid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read transaction BEGIN PREPARE from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L145">&#x200c;</a></span><span class="linkable">logicalrep_read_begin_prepare</span>(StringInfo in, LogicalRepPreparedTxnData *begin_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read fields */<br/></li>
<li></span>&nbsp; &nbsp; begin_data-&gt;prepare_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (begin_data-&gt;prepare_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;prepare_lsn not set in begin prepare message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; begin_data-&gt;end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (begin_data-&gt;end_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;end_lsn not set in begin prepare message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; begin_data-&gt;prepare_time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; begin_data-&gt;xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read gid (copy it into a pre-allocated buffer) */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(begin_data-&gt;gid, <a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(begin_data-&gt;gid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The core functionality for <a href="#L198" title="replication/logical/proto.c:198">logicalrep_write_prepare</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L364" title="replication/logical/proto.c:364">logicalrep_write_stream_prepare</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="linkable">logicalrep_write_prepare_common</span>(StringInfo out, LogicalRepMsgType type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn, XLogRecPtr prepare_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should only ever happen for two-phase commit transactions, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which case we expect to have a valid GID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(txn-&gt;gid != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(rbtxn_prepared(txn));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(txn-&gt;xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the flags field */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(out, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, prepare_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;end_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;xact_time.prepare_time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> gid */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, txn-&gt;gid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write PREPARE to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L198">&#x200c;</a></span><span class="linkable">logicalrep_write_prepare</span>(StringInfo out, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="replication/logical/proto.c:166">logicalrep_write_prepare_common</a>(out, LOGICAL_REP_MSG_PREPARE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn, prepare_lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The core functionality for <a href="#L239" title="replication/logical/proto.c:239">logicalrep_read_prepare</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L376" title="replication/logical/proto.c:376">logicalrep_read_stream_prepare</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">logicalrep_read_prepare_common</span>(StringInfo in, <span class="Type">char</span> *msgtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepPreparedTxnData *prepare_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read flags */<br/></li>
<li></span>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized flags </span><span class="Special">%u</span><span class="Constant"> in </span><span class="Special">%s</span><span class="Constant"> message&quot;</span>, flags, msgtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read fields */<br/></li>
<li></span>&nbsp; &nbsp; prepare_data-&gt;prepare_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prepare_data-&gt;prepare_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;prepare_lsn is not set in </span><span class="Special">%s</span><span class="Constant"> message&quot;</span>, msgtype);<br/></li>
<li>&nbsp; &nbsp; prepare_data-&gt;end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prepare_data-&gt;end_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;end_lsn is not set in </span><span class="Special">%s</span><span class="Constant"> message&quot;</span>, msgtype);<br/></li>
<li>&nbsp; &nbsp; prepare_data-&gt;prepare_time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; prepare_data-&gt;xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prepare_data-&gt;xid == InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid two-phase transaction ID in </span><span class="Special">%s</span><span class="Constant"> message&quot;</span>, msgtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read gid (copy it into a pre-allocated buffer) */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(prepare_data-&gt;gid, <a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(prepare_data-&gt;gid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read transaction PREPARE from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L239">&#x200c;</a></span><span class="linkable">logicalrep_read_prepare</span>(StringInfo in, LogicalRepPreparedTxnData *prepare_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L210" title="replication/logical/proto.c:210">logicalrep_read_prepare_common</a>(in, <span class="Constant">&quot;prepare&quot;</span>, prepare_data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write COMMIT PREPARED to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L248">&#x200c;</a></span><span class="linkable">logicalrep_write_commit_prepared</span>(StringInfo out, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_COMMIT_PREPARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should only ever happen for two-phase commit transactions, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which case we expect to have a valid GID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(txn-&gt;gid != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the flags field */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(out, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;end_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;xact_time.commit_time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> gid */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, txn-&gt;gid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read transaction COMMIT PREPARED from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L278">&#x200c;</a></span><span class="linkable">logicalrep_read_commit_prepared</span>(StringInfo in, LogicalRepCommitPreparedTxnData *prepare_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read flags */<br/></li>
<li></span>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized flags </span><span class="Special">%u</span><span class="Constant"> in commit prepared message&quot;</span>, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read fields */<br/></li>
<li></span>&nbsp; &nbsp; prepare_data-&gt;commit_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prepare_data-&gt;commit_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;commit_lsn is not set in commit prepared message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; prepare_data-&gt;end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prepare_data-&gt;end_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;end_lsn is not set in commit prepared message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; prepare_data-&gt;commit_time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; prepare_data-&gt;xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read gid (copy it into a pre-allocated buffer) */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(prepare_data-&gt;gid, <a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(prepare_data-&gt;gid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write ROLLBACK PREPARED to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L304">&#x200c;</a></span><span class="linkable">logicalrep_write_rollback_prepared</span>(StringInfo out, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz prepare_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_ROLLBACK_PREPARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should only ever happen for two-phase commit transactions, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which case we expect to have a valid GID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(txn-&gt;gid != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the flags field */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(out, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, prepare_end_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;end_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, prepare_time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;xact_time.commit_time);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> gid */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, txn-&gt;gid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read transaction ROLLBACK PREPARED from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L336">&#x200c;</a></span><span class="linkable">logicalrep_read_rollback_prepared</span>(StringInfo in,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepRollbackPreparedTxnData *rollback_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read flags */<br/></li>
<li></span>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized flags </span><span class="Special">%u</span><span class="Constant"> in rollback prepared message&quot;</span>, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read fields */<br/></li>
<li></span>&nbsp; &nbsp; rollback_data-&gt;prepare_end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rollback_data-&gt;prepare_end_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;prepare_end_lsn is not set in rollback prepared message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; rollback_data-&gt;rollback_end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rollback_data-&gt;rollback_end_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;rollback_end_lsn is not set in rollback prepared message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; rollback_data-&gt;prepare_time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; rollback_data-&gt;rollback_time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; rollback_data-&gt;xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read gid (copy it into a pre-allocated buffer) */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(rollback_data-&gt;gid, <a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(rollback_data-&gt;gid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write STREAM PREPARE to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">logicalrep_write_stream_prepare</span>(StringInfo out,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr prepare_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="replication/logical/proto.c:166">logicalrep_write_prepare_common</a>(out, LOGICAL_REP_MSG_STREAM_PREPARE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn, prepare_lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read STREAM PREPARE from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L376">&#x200c;</a></span><span class="linkable">logicalrep_read_stream_prepare</span>(StringInfo in, LogicalRepPreparedTxnData *prepare_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L210" title="replication/logical/proto.c:210">logicalrep_read_prepare_common</a>(in, <span class="Constant">&quot;stream prepare&quot;</span>, prepare_data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write ORIGIN to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L385">&#x200c;</a></span><span class="linkable">logicalrep_write_origin</span>(StringInfo out, <span class="Type">const</span> <span class="Type">char</span> *origin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr origin_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fixed fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, origin_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* origin string */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, origin);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read ORIGIN from the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L401">&#x200c;</a><span class="linkable">logicalrep_read_origin</span>(StringInfo in, XLogRecPtr *origin_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fixed fields */<br/></li>
<li></span>&nbsp; &nbsp; *origin_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return origin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write INSERT to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L414">&#x200c;</a></span><span class="linkable">logicalrep_write_insert</span>(StringInfo out, TransactionId xid, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *newslot, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary, Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_INSERT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (if not valid, we're not streaming) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use Oid as relation identifier */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, <span class="Constant">'N'</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new tuple follows */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L769" title="replication/logical/proto.c:769">logicalrep_write_tuple</a>(out, rel, newslot, binary, columns);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read INSERT from stream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fills the new tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalRepRelId<br/></li>
<li><a id="L436">&#x200c;</a><span class="linkable">logicalrep_read_insert</span>(StringInfo in, LogicalRepTupleData *newtup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; action;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelId relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read the relation id */<br/></li>
<li></span>&nbsp; &nbsp; relid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; action = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action != <span class="Constant">'N'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected new tuple but got </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L866" title="replication/logical/proto.c:866">logicalrep_read_tuple</a>(in, newtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write UPDATE to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L458">&#x200c;</a></span><span class="linkable">logicalrep_write_update</span>(StringInfo out, TransactionId xid, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot, TupleTableSlot *newslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary, Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_DEFAULT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_INDEX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (if not valid, we're not streaming) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use Oid as relation identifier */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldslot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, <span class="Constant">'O'</span>);&nbsp; &nbsp; <span class="Comment">/* old tuple follows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, <span class="Constant">'K'</span>);&nbsp; &nbsp; <span class="Comment">/* old key follows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L769" title="replication/logical/proto.c:769">logicalrep_write_tuple</a>(out, rel, oldslot, binary, columns);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, <span class="Constant">'N'</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new tuple follows */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L769" title="replication/logical/proto.c:769">logicalrep_write_tuple</a>(out, rel, newslot, binary, columns);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read UPDATE from stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalRepRelId<br/></li>
<li><a id="L492">&#x200c;</a><span class="linkable">logicalrep_read_update</span>(StringInfo in, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *has_oldtuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepTupleData *oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepTupleData *newtup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; action;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelId relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read the relation id */<br/></li>
<li></span>&nbsp; &nbsp; relid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read and verify action */<br/></li>
<li></span>&nbsp; &nbsp; action = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action != <span class="Constant">'K'</span> &amp;&amp; action != <span class="Constant">'O'</span> &amp;&amp; action != <span class="Constant">'N'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected action 'N', 'O' or 'K', got </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for old tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (action == <span class="Constant">'K'</span> || action == <span class="Constant">'O'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L866" title="replication/logical/proto.c:866">logicalrep_read_tuple</a>(in, oldtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *has_oldtuple = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; action = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *has_oldtuple = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for new&nbsp; tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (action != <span class="Constant">'N'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected action 'N', got </span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L866" title="replication/logical/proto.c:866">logicalrep_read_tuple</a>(in, newtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write DELETE to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L533">&#x200c;</a></span><span class="linkable">logicalrep_write_delete</span>(StringInfo out, TransactionId xid, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *oldslot, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_DEFAULT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_INDEX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (if not valid, we're not streaming) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use Oid as relation identifier */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, <span class="Constant">'O'</span>);&nbsp; &nbsp; <span class="Comment">/* old tuple follows */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, <span class="Constant">'K'</span>);&nbsp; &nbsp; <span class="Comment">/* old key follows */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L769" title="replication/logical/proto.c:769">logicalrep_write_tuple</a>(out, rel, oldslot, binary, columns);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read DELETE from stream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fills the old tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalRepRelId<br/></li>
<li><a id="L564">&#x200c;</a><span class="linkable">logicalrep_read_delete</span>(StringInfo in, LogicalRepTupleData *oldtup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; action;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelId relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read the relation id */<br/></li>
<li></span>&nbsp; &nbsp; relid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read and verify action */<br/></li>
<li></span>&nbsp; &nbsp; action = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action != <span class="Constant">'K'</span> &amp;&amp; action != <span class="Constant">'O'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected action 'O' or 'K', got </span><span class="Special">%c</span><span class="Constant">&quot;</span>, action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L866" title="replication/logical/proto.c:866">logicalrep_read_tuple</a>(in, oldtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write TRUNCATE to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L586">&#x200c;</a></span><span class="linkable">logicalrep_write_truncate</span>(StringInfo out,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid relids[],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> cascade, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> restart_seqs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_TRUNCATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (if not valid, we're not streaming) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, nrelids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* encode and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> truncate flags */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cascade)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= <a href="#L29" title="replication/logical/proto.c:29">TRUNCATE_CASCADE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (restart_seqs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= <a href="#L30" title="replication/logical/proto.c:30">TRUNCATE_RESTART_SEQS</a>;<br/></li>
<li>&nbsp; &nbsp; pq_sendint8(out, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrelids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, relids[i]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read TRUNCATE from stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L618">&#x200c;</a><span class="linkable">logicalrep_read_truncate</span>(StringInfo in,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *cascade, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *restart_seqs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrelids;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relids = NIL;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nrelids = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read and decode truncate flags */<br/></li>
<li></span>&nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; *cascade = (flags &amp; <a href="#L29" title="replication/logical/proto.c:29">TRUNCATE_CASCADE</a>) &gt; <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *restart_seqs = (flags &amp; <a href="#L30" title="replication/logical/proto.c:30">TRUNCATE_RESTART_SEQS</a>) &gt; <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrelids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids, <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write MESSAGE to stream<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L643">&#x200c;</a></span><span class="linkable">logicalrep_write_message</span>(StringInfo out, TransactionId xid, XLogRecPtr lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional, <span class="Type">const</span> <span class="Type">char</span> *prefix, Size sz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *message)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_MESSAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* encode and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> message flags */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (transactional)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= <a href="#L28" title="replication/logical/proto.c:28">MESSAGE_TRANSACTIONAL</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (if not valid, we're not streaming) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendint8(out, flags);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, prefix);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, sz);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(out, message, sz);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write relation description to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L670">&#x200c;</a></span><span class="linkable">logicalrep_write_rel</span>(StringInfo out, TransactionId xid, Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (if not valid, we're not streaming) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use Oid as relation identifier */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> qualified relation name */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1035" title="replication/logical/proto.c:1035">logicalrep_write_namespace</a>(out, RelationGetNamespace(rel));<br/></li>
<li>&nbsp; &nbsp; relname = RelationGetRelationName(rel);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> replica identity */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(out, rel-&gt;rd_rel-&gt;relreplident);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the attribute info */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L926" title="replication/logical/proto.c:926">logicalrep_write_attrs</a>(out, rel, columns);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the relation info from stream and return as LogicalRepRelation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalRepRelation *<br/></li>
<li><a id="L700">&#x200c;</a><span class="linkable">logicalrep_read_rel</span>(StringInfo in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelation *rel = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;remoteid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read relation name from stream */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;nspname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L1055" title="replication/logical/proto.c:1055">logicalrep_read_namespace</a>(in));<br/></li>
<li>&nbsp; &nbsp; rel-&gt;relname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the replica identity. */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;replident = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get attribute description */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L993" title="replication/logical/proto.c:993">logicalrep_read_attrs</a>(in, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write type info to the output stream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function will always write base type info.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L725">&#x200c;</a></span><span class="linkable">logicalrep_write_typ</span>(StringInfo out, TransactionId xid, Oid typoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basetypoid = <a href="../../utils/cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(typoid);<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_TYPE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (if not valid, we're not streaming) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(basetypoid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, basetypoid);<br/></li>
<li>&nbsp; &nbsp; typtup = (Form_pg_type) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use Oid as relation identifier */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, typoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> qualified type name */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1035" title="replication/logical/proto.c:1035">logicalrep_write_namespace</a>(out, typtup-&gt;typnamespace);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, NameStr(typtup-&gt;typname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read type info from the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L756">&#x200c;</a></span><span class="linkable">logicalrep_read_typ</span>(StringInfo in, LogicalRepTyp *ltyp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ltyp-&gt;remoteid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read type name from stream */<br/></li>
<li></span>&nbsp; &nbsp; ltyp-&gt;nspname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L1055" title="replication/logical/proto.c:1055">logicalrep_read_namespace</a>(in));<br/></li>
<li>&nbsp; &nbsp; ltyp-&gt;typname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a tuple to the outputstream, in the most efficient format possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L769">&#x200c;</a></span><span class="linkable">logicalrep_write_tuple</span>(StringInfo out, Relation rel, TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> binary, Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; nliveatts = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; desc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped || att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L50" title="replication/logical/proto.c:50">column_in_column_list</a>(att-&gt;attnum, columns))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nliveatts++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(out, nliveatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot_getallattrs(slot);<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = slot-&gt;tts_values;<br/></li>
<li>&nbsp; &nbsp; isnull = slot-&gt;tts_isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; typtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped || att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L50" title="replication/logical/proto.c:50">column_in_column_list</a>(att-&gt;attnum, columns))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, LOGICALREP_COLUMN_NULL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span> &amp;&amp; VARATT_IS_EXTERNAL_ONDISK(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unchanged toasted datum.&nbsp; (Note that we don't promise to detect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unchanged data in general; this is just a cheap check to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sending large <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> unnecessarily.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, LOGICALREP_COLUMN_UNCHANGED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typtup = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(att-&gt;atttypid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(typtup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, att-&gt;atttypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typclass = (Form_pg_type) GETSTRUCT(typtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Send in binary if requested and type has suitable <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (binary &amp;&amp; OidIsValid(typclass-&gt;typsend))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *outputbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, LOGICALREP_COLUMN_BINARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outputbytes = <a href="../../utils/fmgr/fmgr.c.html#L1782" title="utils/fmgr/fmgr.c:1782">OidSendFunctionCall</a>(typclass-&gt;typsend, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE(outputbytes) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint(out, len, <span class="Constant">4</span>);&nbsp; &nbsp; <span class="Comment">/* length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(out, VARDATA(outputbytes), len);&nbsp; &nbsp; <span class="Comment">/* data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outputbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *outputstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, LOGICALREP_COLUMN_TEXT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outputstr = <a href="../../utils/fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(typclass-&gt;typoutput, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L142" title="libpq/pqformat.c:142">pq_sendcountedtext</a>(out, outputstr, strlen(outputstr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(outputstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(typtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read tuple in logical replication format from stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L866">&#x200c;</a></span><span class="linkable">logicalrep_read_tuple</span>(StringInfo in, LogicalRepTupleData *tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get number of attributes */<br/></li>
<li></span>&nbsp; &nbsp; natts = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate space for per-column <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; zero out unused StringInfoDatas */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;colvalues = (StringInfoData *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(StringInfoData));<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;colstatus = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>));<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;ncols = natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; kind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; value = &amp;tuple-&gt;colvalues[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kind = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;colstatus[i] = kind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (kind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICALREP_COLUMN_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing more to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICALREP_COLUMN_UNCHANGED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't receive the value of an unchanged column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICALREP_COLUMN_TEXT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICALREP_COLUMN_BINARY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);&nbsp; &nbsp; <span class="Comment">/* read length */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buff = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L528" title="libpq/pqformat.c:528">pq_copymsgbytes</a>(in, buff, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NUL termination is required for LOGICALREP_COLUMN_TEXT mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as input <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> require that.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LOGICALREP_COLUMN_BINARY it's not technically required, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's harmless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buff[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfoFromString(value, buff, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized data representation type '</span><span class="Special">%c</span><span class="Constant">'&quot;</span>, kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write relation attribute metadata to the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L926">&#x200c;</a></span><span class="linkable">logicalrep_write_attrs</span>(StringInfo out, Relation rel, Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; nliveatts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *idattrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replidentfull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; desc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> number of live attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped || att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L50" title="replication/logical/proto.c:50">column_in_column_list</a>(att-&gt;attnum, columns))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nliveatts++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pq_sendint16(out, nliveatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch bitmap of REPLICATION IDENTITY attributes */<br/></li>
<li></span>&nbsp; &nbsp; replidentfull = (rel-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!replidentfull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idattrs = <a href="../../utils/cache/relcache.c.html#L5504" title="utils/cache/relcache.c:5504">RelationGetIdentityKeyBitmap</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped || att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L50" title="replication/logical/proto.c:50">column_in_column_list</a>(att-&gt;attnum, columns))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* REPLICA IDENTITY FULL means all columns are sent as part of key. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (replidentfull ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(att-&gt;attnum - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idattrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= <a href="#L26" title="replication/logical/proto.c:26">LOGICALREP_IS_REPLICA_IDENTITY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attribute name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, NameStr(att-&gt;attname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attribute type id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, (<span class="Type">int</span>) att-&gt;atttypid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attribute mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(out, att-&gt;atttypmod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(idattrs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read relation attribute metadata from the stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L993">&#x200c;</a></span><span class="linkable">logicalrep_read_attrs</span>(StringInfo in, LogicalRepRelation *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **attnames;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *atttyps;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *attkeys = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; natts = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; attnames = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; atttyps = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read the attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for replica identity column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; <a href="#L26" title="replication/logical/proto.c:26">LOGICALREP_IS_REPLICA_IDENTITY</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attkeys = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(attkeys, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attribute name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attnames[i] = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attribute type id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; atttyps[i] = (Oid) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we ignore attribute mode for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;attnames = attnames;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;atttyps = atttyps;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;attkeys = attkeys;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;natts = natts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the namespace name or empty string for pg_catalog (to save space).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1035">&#x200c;</a></span><span class="linkable">logicalrep_write_namespace</span>(StringInfo out, Oid nspid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nspid == PG_CATALOG_NAMESPACE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendbyte(out, <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname = <a href="../../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(nspid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nspname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for namespace </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nspid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(out, nspname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the namespace name while treating empty string as pg_catalog.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1055">&#x200c;</a><span class="linkable">logicalrep_read_namespace</span>(StringInfo in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nspname = <a href="../../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nspname[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">&quot;pg_catalog&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nspname;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the information for the start stream message to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1069">&#x200c;</a></span><span class="linkable">logicalrep_write_stream_start</span>(StringInfo out,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> first_segment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_STREAM_START);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID (we're starting to stream, so must be valid) */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* 1 if this is the first streaming segment for this xid */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(out, first_segment ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the information about the start stream message from output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L1087">&#x200c;</a><span class="linkable">logicalrep_read_stream_start</span>(StringInfo in, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *first_segment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(first_segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; *first_segment = (<a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in) == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the stop stream message to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1103">&#x200c;</a></span><span class="linkable">logicalrep_write_stream_stop</span>(StringInfo out)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_STREAM_STOP);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write STREAM COMMIT to the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1112">&#x200c;</a></span><span class="linkable">logicalrep_write_stream_commit</span>(StringInfo out, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_STREAM_COMMIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(txn-&gt;xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the flags field (unused for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(out, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> fields */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(out, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;end_lsn);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(out, txn-&gt;xact_time.commit_time);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read STREAM COMMIT from the output stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L1137">&#x200c;</a><span class="linkable">logicalrep_read_stream_commit</span>(StringInfo in, LogicalRepCommitData *commit_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read flags (unused for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; flags = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized flags </span><span class="Special">%u</span><span class="Constant"> in commit message&quot;</span>, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read fields */<br/></li>
<li></span>&nbsp; &nbsp; commit_data-&gt;commit_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; commit_data-&gt;end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; commit_data-&gt;committime = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write STREAM ABORT to the output stream. Note that xid and subxid will be<br/></li>
<li></span><span class="Comment"> * same for the top-level transaction abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If write_abort_info is true, <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the abort_lsn and abort_time fields,<br/></li>
<li></span><span class="Comment"> * otherwise don't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1166">&#x200c;</a></span><span class="linkable">logicalrep_write_stream_abort</span>(StringInfo out, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId subxid, XLogRecPtr abort_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz abort_time, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> write_abort_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(out, LOGICAL_REP_MSG_STREAM_ABORT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid) &amp;&amp; TransactionIdIsValid(subxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction ID */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint32(out, xid);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(out, subxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write_abort_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint64(out, abort_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint64(out, abort_time);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read STREAM ABORT from the output stream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If read_abort_info is true, read the abort_lsn and abort_time fields,<br/></li>
<li></span><span class="Comment"> * otherwise don't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1192">&#x200c;</a></span><span class="linkable">logicalrep_read_stream_abort</span>(StringInfo in,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepStreamAbortData *abort_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> read_abort_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(abort_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; abort_data-&gt;xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; abort_data-&gt;subxid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(in, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (read_abort_info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abort_data-&gt;abort_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abort_data-&gt;abort_time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(in);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abort_data-&gt;abort_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; abort_data-&gt;abort_time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get string representing LogicalRepMsgType.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1217">&#x200c;</a><span class="linkable">logicalrep_message_type</span>(LogicalRepMsgType action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> err_unknown[<span class="Constant">20</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;BEGIN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_COMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;COMMIT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_ORIGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ORIGIN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;INSERT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;UPDATE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DELETE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;TRUNCATE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;RELATION&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_TYPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;TYPE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_MESSAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;MESSAGE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_BEGIN_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;BEGIN PREPARE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;PREPARE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_COMMIT_PREPARED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;COMMIT PREPARED&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_ROLLBACK_PREPARED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ROLLBACK PREPARED&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;STREAM START&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_STOP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;STREAM STOP&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_COMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;STREAM COMMIT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;STREAM ABORT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;STREAM PREPARE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This message provides context in the error raised when applying a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logical message. So we can't throw an error here. Return an unknown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicator value so that the original error is still reported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(err_unknown, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(err_unknown), <span class="Constant">&quot;??? (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> err_unknown;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
