<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/relation.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/relation.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L50">LogicalRepPartMap</a></li>
<li><a href="#L49">LogicalRepPartMapContext</a></li>
<li><a href="#L36">LogicalRepRelMap</a></li>
<li><a href="#L34">LogicalRepRelMapContext</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L51">LogicalRepPartMapEntry</a></li>
<li><a href="#L55">LogicalRepPartMapEntry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L868">FindLogicalRepLocalIndex</a></li>
<li><a href="#L745">FindUsableIndexForReplicaIdentityFull</a></li>
<li><a href="#L851">GetRelationIdentityOrPK</a></li>
<li><a href="#L804">IsIndexUsableForReplicaIdentityFull</a></li>
<li><a href="#L602">logicalrep_partition_open</a></li>
<li><a href="#L567">logicalrep_partmap_init</a></li>
<li><a href="#L492">logicalrep_partmap_invalidate_cb</a></li>
<li><a href="#L540">logicalrep_partmap_reset_relmap</a></li>
<li><a href="#L209">logicalrep_rel_att_by_name</a></li>
<li><a href="#L473">logicalrep_rel_close</a></li>
<li><a href="#L274">logicalrep_rel_mark_updatable</a></li>
<li><a href="#L327">logicalrep_rel_open</a></li>
<li><a href="#L132">logicalrep_relmap_free_entry</a></li>
<li><a href="#L105">logicalrep_relmap_init</a></li>
<li><a href="#L64">logicalrep_relmap_invalidate_cb</a></li>
<li><a href="#L164">logicalrep_relmap_update</a></li>
<li><a href="#L226">logicalrep_report_missing_attrs</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * relation.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; PostgreSQL logical replication relation mapping cache<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2016-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/relation.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines in this file mainly have to do with mapping the properties<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of local replication target relations to the properties of their<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; remote counterpart.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/amapi.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription_rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalrelation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/worker_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L34">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">LogicalRepRelMapContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L36">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">LogicalRepRelMap</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Partition map (<a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a>)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a partitioned table is used as replication target, replicated<br/></li>
<li></span><span class="Comment"> * operations are actually performed on its leaf partitions, which requires<br/></li>
<li></span><span class="Comment"> * the partitions to also be mapped to the remote relation.&nbsp; Parent's entry<br/></li>
<li></span><span class="Comment"> * (LogicalRepRelMapEntry) cannot be used as-is for all partitions, because<br/></li>
<li></span><span class="Comment"> * individual partitions may have different attribute numbers, which means<br/></li>
<li></span><span class="Comment"> * attribute mappings to remote relation's attributes must be maintained<br/></li>
<li></span><span class="Comment"> * separately for each partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">LogicalRepPartMapContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L50">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">LogicalRepPartMap</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L51">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LogicalRepPartMapEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partoid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a>'s key */<br/></li>
<li></span>&nbsp; &nbsp; LogicalRepRelMapEntry relmapentry;<br/></li>
<li><a id="L55">&#x200c;</a>} <span class="linkable">LogicalRepPartMapEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L868" title="replication/logical/relation.c:868">FindLogicalRepLocalIndex</a>(Relation localrel, LogicalRepRelation *remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrMap *attrMap);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Relcache invalidation callback for our relation map cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="linkable">logicalrep_relmap_invalidate_cb</span>(Datum arg, Oid reloid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just to be sure. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reloid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment">, use inverse lookup hashtable? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((entry = (LogicalRepRelMapEntry *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;localreloid == reloid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrelvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>(&amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalidate all cache entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((entry = (LogicalRepRelMapEntry *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrelvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the relation map cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="linkable">logicalrep_relmap_init</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L34" title="replication/logical/relation.c:34">LogicalRepRelMapContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="replication/logical/relation.c:34">LogicalRepRelMapContext</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L34" title="replication/logical/relation.c:34">LogicalRepRelMapContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the relation <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepRelId);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepRelMapEntry);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = <a href="#L34" title="replication/logical/relation.c:34">LogicalRepRelMapContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;logicalrep relation map cache&quot;</span>, <span class="Constant">128</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Watch for invalidation events. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1558" title="utils/cache/inval.c:1558">CacheRegisterRelcacheCallback</a>(<a href="#L64" title="replication/logical/relation.c:64">logicalrep_relmap_invalidate_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free the entry of a relation map cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="linkable">logicalrep_relmap_free_entry</span>(LogicalRepRelMapEntry *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelation *remoterel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remoterel = &amp;entry-&gt;remoterel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(remoterel-&gt;nspname);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(remoterel-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remoterel-&gt;natts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; remoterel-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(remoterel-&gt;attnames[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(remoterel-&gt;attnames);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(remoterel-&gt;atttyps);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(remoterel-&gt;attkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;attrmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/attmap.c.html#L56" title="access/common/attmap.c:56">free_attrmap</a>(entry-&gt;attrmap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add new entry or update existing entry in the relation map cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called when new relation mapping is sent by the publisher to update<br/></li>
<li></span><span class="Comment"> * our expected view of incoming data from said publisher.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="linkable">logicalrep_relmap_update</span>(LogicalRepRelation *remoterel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="replication/logical/relation.c:105">logicalrep_relmap_init</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HASH_ENTER returns the existing entry if present or creates a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a>, &amp;remoterel-&gt;remoteid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="replication/logical/relation.c:132">logicalrep_relmap_free_entry</a>(entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(entry, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepRelMapEntry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make cached copy of the data */<br/></li>
<li></span>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L34" title="replication/logical/relation.c:34">LogicalRepRelMapContext</a>);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.remoteid = remoterel-&gt;remoteid;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.nspname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remoterel-&gt;nspname);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.relname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remoterel-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.natts = remoterel-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.attnames = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(remoterel-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.atttyps = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(remoterel-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; remoterel-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.attnames[i] = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remoterel-&gt;attnames[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.atttyps[i] = remoterel-&gt;atttyps[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.replident = remoterel-&gt;replident;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;remoterel.attkeys = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(remoterel-&gt;attkeys);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find attribute index in TupleDesc struct by attribute name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 if not found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L209">&#x200c;</a></span><span class="linkable">logicalrep_rel_att_by_name</span>(LogicalRepRelation *remoterel, <span class="Type">const</span> <span class="Type">char</span> *attname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; remoterel-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(remoterel-&gt;attnames[i], attname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report error with names of the missing local relation column(s), if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L226">&#x200c;</a></span><span class="linkable">logicalrep_report_missing_attrs</span>(LogicalRepRelation *remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *missingatts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bms_is_empty(missingatts))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData missingattsbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingattcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;missingattsbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(missingatts, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingattcnt++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (missingattcnt == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;missingattsbuf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoterel-&gt;attnames[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;missingattsbuf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;, </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoterel-&gt;attnames[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;logical replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> is missing replicated column: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> is missing replicated columns: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; missingattcnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoterel-&gt;nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoterel-&gt;relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; missingattsbuf.data)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if replica identity matches and mark the updatable flag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We allow for stricter replica identity (fewer columns) on subscriber as<br/></li>
<li></span><span class="Comment"> * that will not stop us from finding unique tuple. IE, if publisher has<br/></li>
<li></span><span class="Comment"> * identity (id,timestamp) and subscriber just (id) this will not be a<br/></li>
<li></span><span class="Comment"> * problem, but in the opposite scenario it will.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We just mark the relation entry as not updatable here if the local<br/></li>
<li></span><span class="Comment"> * replica identity is found to be insufficient for applying<br/></li>
<li></span><span class="Comment"> * updates/deletes (inserts don't care!) and leave it to<br/></li>
<li></span><span class="Comment"> * <a href="worker.c.html#L2479" title="replication/logical/worker.c:2479">check_relation_updatable</a>() to throw the actual error if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L274">&#x200c;</a></span><span class="linkable">logicalrep_rel_mark_updatable</span>(LogicalRepRelMapEntry *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *idkey;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelation *remoterel = &amp;entry-&gt;remoterel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;updatable = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; idkey = <a href="../../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(entry-&gt;localrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_IDENTITY_KEY);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fallback to PK if no replica identity */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (idkey == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idkey = <a href="../../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(entry-&gt;localrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_PRIMARY_KEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no replica identity index and no PK, the published table must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have replica identity FULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idkey == <span class="Constant">NULL</span> &amp;&amp; remoterel-&gt;replident != REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;updatable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((i = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(idkey, i)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = i + FirstLowInvalidHeapAttributeNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!AttrNumberIsForUserDefinedAttr(attnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> uses &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;system columns in REPLICA IDENTITY index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoterel-&gt;nspname, remoterel-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnum = AttrNumberGetAttrOffset(attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;attrmap-&gt;attnums[attnum] &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(entry-&gt;attrmap-&gt;attnums[attnum], remoterel-&gt;attkeys))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;updatable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open the local relation associated with the remote one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Rebuilds the Relcache mapping if it was invalidated by local DDL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalRepRelMapEntry *<br/></li>
<li><a id="L327">&#x200c;</a><span class="linkable">logicalrep_rel_open</span>(LogicalRepRelId remoteid, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelation *remoterel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L105" title="replication/logical/relation.c:105">logicalrep_relmap_init</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for existing entry. */<br/></li>
<li></span>&nbsp; &nbsp; entry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L36" title="replication/logical/relation.c:36">LogicalRepRelMap</a>, &amp;remoteid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no relation map entry for remote relation ID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remoterel = &amp;entry-&gt;remoterel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we don't leak a relcache refcount. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;localrel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;remote relation ID </span><span class="Special">%u</span><span class="Constant"> is already open&quot;</span>, remoteid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When opening and locking a relation, pending invalidation messages are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed which can invalidate the relation.&nbsp; Hence, if the entry is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently considered valid, try to open the local relation by OID and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see if invalidation ensues.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;localrelvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrel = <a href="../../access/table/table.c.html#L60" title="access/table/table.c:60">try_table_open</a>(entry-&gt;localreloid, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;localrel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Table was renamed or dropped. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrelvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!entry-&gt;localrelvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we release the no-longer-useful lock here. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(entry-&gt;localrel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the entry has been marked invalid since we last had lock on it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-open the local relation by name and rebuild all derived data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;localrelvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *missingatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the no-longer-useful attrmap, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;attrmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/attmap.c.html#L56" title="access/common/attmap.c:56">free_attrmap</a>(entry-&gt;attrmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and lock the relation by name. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relid = RangeVarGetRelid(<a href="../../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(remoterel-&gt;nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoterel-&gt;relname, -<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoterel-&gt;nspname, remoterel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localreloid = relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for supported relkind. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execReplication.c.html#L739" title="executor/execReplication.c:739">CheckSubscriptionRelkind</a>(entry-&gt;localrel-&gt;rd_rel-&gt;relkind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoterel-&gt;nspname, remoterel-&gt;relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build the mapping of local attribute numbers to remote attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * numbers and validate that we don't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> replicated columns as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that would result in potentially unwanted data loss.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; desc = RelationGetDescr(entry-&gt;localrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L34" title="replication/logical/relation.c:34">LogicalRepRelMapContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <a href="../../access/common/attmap.c.html#L40" title="access/common/attmap.c:40">make_attrmap</a>(desc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check and report missing attrs, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; missingatts = <a href="../../nodes/bitmapset.c.html#L1019" title="nodes/bitmapset.c:1019">bms_add_range</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>, remoterel-&gt;natts - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(desc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped || attr-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap-&gt;attnums[i] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="#L209" title="replication/logical/relation.c:209">logicalrep_rel_att_by_name</a>(remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(attr-&gt;attname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap-&gt;attnums[i] = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingatts = <a href="../../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(missingatts, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L226" title="replication/logical/relation.c:226">logicalrep_report_missing_attrs</a>(remoterel, missingatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be tidy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(missingatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set if the table's replica identity is enough to apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update/delete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L274" title="replication/logical/relation.c:274">logicalrep_rel_mark_updatable</a>(entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finding a usable index is an infrequent task. It occurs when an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation is first performed on the relation, or after invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the relation cache entry (such as ANALYZE or CREATE/DROP index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the relation).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localindexoid = <a href="#L868" title="replication/logical/relation.c:868">FindLogicalRepLocalIndex</a>(entry-&gt;localrel, remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrelvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;state != SUBREL_STATE_READY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;state = <a href="../../catalog/pg_subscription.c.html#L341" title="catalog/pg_subscription.c:341">GetSubscriptionRelState</a>(<a href="worker.c.html#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;localreloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;entry-&gt;statelsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close the previously opened logical relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L473">&#x200c;</a></span><span class="linkable">logicalrep_rel_close</span>(LogicalRepRelMapEntry *rel, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel-&gt;localrel, lockmode);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;localrel = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Partition cache: look up partition LogicalRepRelMapEntry's<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike relation map cache, this is keyed by partition OID, not remote<br/></li>
<li></span><span class="Comment"> * relation OID, because we only have to use this cache in the case where<br/></li>
<li></span><span class="Comment"> * partitions are not directly mapped to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remote relation, such as when<br/></li>
<li></span><span class="Comment"> * replication is occurring with one of their ancestors as target.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Relcache invalidation callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L492">&#x200c;</a></span><span class="linkable">logicalrep_partmap_invalidate_cb</span>(Datum arg, Oid reloid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just to be sure. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reloid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment">, use inverse lookup hashtable? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((entry = (<a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;relmapentry.localreloid == reloid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;relmapentry.localrelvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1471" title="utils/hash/dynahash.c:1471">hash_seq_term</a>(&amp;status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalidate all cache entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((entry = (<a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;relmapentry.localrelvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset the entries in the partition map that refer to remoterel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called when new relation mapping is sent by the publisher to update our<br/></li>
<li></span><span class="Comment"> * expected view of incoming data from said publisher.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't update the remoterel information in the entry here,<br/></li>
<li></span><span class="Comment"> * we will update the information in <a href="#L602" title="replication/logical/relation.c:602">logicalrep_partition_open</a> to avoid<br/></li>
<li></span><span class="Comment"> * unnecessary work.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L540">&#x200c;</a></span><span class="linkable">logicalrep_partmap_reset_relmap</span>(LogicalRepRelation *remoterel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a> *part_entry;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((part_entry = (<a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = &amp;part_entry-&gt;relmapentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;remoterel.remoteid != remoterel-&gt;remoteid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="replication/logical/relation.c:132">logicalrep_relmap_free_entry</a>(entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(entry, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRepRelMapEntry));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the partition map cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L567">&#x200c;</a></span><span class="linkable">logicalrep_partmap_init</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L49" title="replication/logical/relation.c:49">LogicalRepPartMapContext</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="replication/logical/relation.c:49">LogicalRepPartMapContext</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L49" title="replication/logical/relation.c:49">LogicalRepPartMapContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the relation <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);&nbsp; &nbsp; <span class="Comment">/* partition OID */<br/></li>
<li></span>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = <a href="#L49" title="replication/logical/relation.c:49">LogicalRepPartMapContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;logicalrep partition map cache&quot;</span>, <span class="Constant">64</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Watch for invalidation events. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1558" title="utils/cache/inval.c:1558">CacheRegisterRelcacheCallback</a>(<a href="#L492" title="replication/logical/relation.c:492">logicalrep_partmap_invalidate_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L602" title="replication/logical/relation.c:602">logicalrep_partition_open</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returned entry reuses most of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the root table's entry, save<br/></li>
<li></span><span class="Comment"> * the attribute map, which can be different for the partition.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * we must physically copy all the data, in case the root table's entry<br/></li>
<li></span><span class="Comment"> * gets freed/rebuilt.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note there's no logicalrep_partition_close, because the caller closes the<br/></li>
<li></span><span class="Comment"> * component relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalRepRelMapEntry *<br/></li>
<li><a id="L602">&#x200c;</a><span class="linkable">logicalrep_partition_open</span>(LogicalRepRelMapEntry *root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation partrel, AttrMap *map)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *entry;<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a> *part_entry;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelation *remoterel = &amp;root-&gt;remoterel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partOid = RelationGetRelid(partrel);<br/></li>
<li>&nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attrmap = root-&gt;attrmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L567" title="replication/logical/relation.c:567">logicalrep_partmap_init</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search for existing entry. */<br/></li>
<li></span>&nbsp; &nbsp; part_entry = (<a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L50" title="replication/logical/relation.c:50">LogicalRepPartMap</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;partOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = &amp;part_entry-&gt;relmapentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must always overwrite entry-&gt;localrel with the latest partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relation pointer, because the Relation pointed to by the old value may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been cleared after the caller would have closed the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation after the last use of this entry.&nbsp; Note that localrelvalid is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only updated by the relcache invalidation callback, so it may still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true irrespective of whether the Relation pointed to by localrel has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been cleared or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; entry-&gt;localrelvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;localrel = partrel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to longer-lived context. */<br/></li>
<li></span>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L49" title="replication/logical/relation.c:49">LogicalRepPartMapContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(part_entry, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L51" title="replication/logical/relation.c:51">LogicalRepPartMapEntry</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; part_entry-&gt;partoid = partOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release the no-longer-useful attrmap, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;attrmap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/attmap.c.html#L56" title="access/common/attmap.c:56">free_attrmap</a>(entry-&gt;attrmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;remoterel.remoteid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remote relation is copied as-is from the root entry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.remoteid = remoterel-&gt;remoteid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.nspname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remoterel-&gt;nspname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.relname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remoterel-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.natts = remoterel-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.attnames = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(remoterel-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.atttyps = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(remoterel-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; remoterel-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.attnames[i] = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remoterel-&gt;attnames[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.atttyps[i] = remoterel-&gt;atttyps[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.replident = remoterel-&gt;replident;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;remoterel.attkeys = <a href="../../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(remoterel-&gt;attkeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;localrel = partrel;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;localreloid = partOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the partition's attributes don't match the root relation's, we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to make a new attrmap which <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> partition attribute numbers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remoterel's, instead of the original which <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> root relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attribute numbers to remoterel's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that 'map' which comes from the tuple routing data structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains 1-based attribute numbers (of the parent relation).&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the map in 'entry', a logical replication data structure, contains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0-based attribute numbers (of the remote relation).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (map)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <a href="../../access/common/attmap.c.html#L40" title="access/common/attmap.c:40">make_attrmap</a>(map-&gt;maplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (attno = <span class="Constant">0</span>; attno &lt; entry-&gt;attrmap-&gt;maplen; attno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; root_attno = map-&gt;attnums[attno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 0 means it's a dropped attribute.&nbsp; See comments atop AttrMap. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (root_attno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap-&gt;attnums[attno] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap-&gt;attnums[attno] = attrmap-&gt;attnums[root_attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lacking copy_attmap, do this the hard way. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <a href="../../access/common/attmap.c.html#L40" title="access/common/attmap.c:40">make_attrmap</a>(attrmap-&gt;maplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(entry-&gt;attrmap-&gt;attnums, attrmap-&gt;attnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attrmap-&gt;maplen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AttrNumber));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set if the table's replica identity is enough to apply update/delete. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L274" title="replication/logical/relation.c:274">logicalrep_rel_mark_updatable</a>(entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* state and statelsn are left set to 0. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finding a usable index is an infrequent task. It occurs when an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation is first performed on the relation, or after invalidation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relation cache entry (such as ANALYZE or CREATE/DROP index on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also prefer to run this code on the oldctx so that we do not leak<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything in the <a href="#L49" title="replication/logical/relation.c:49">LogicalRepPartMapContext</a> (hence <a href="../../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entry-&gt;localindexoid = <a href="#L868" title="replication/logical/relation.c:868">FindLogicalRepLocalIndex</a>(partrel, remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;localrelvalid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the oid of an index that can be used by the apply worker to scan<br/></li>
<li></span><span class="Comment"> * the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect to call this function when REPLICA IDENTITY FULL is defined for<br/></li>
<li></span><span class="Comment"> * the remote relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no suitable index is found, returns InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L745">&#x200c;</a><span class="linkable">FindUsableIndexForReplicaIdentityFull</span>(Relation localrel, AttrMap *attrmap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *idxlist = <a href="../../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(localrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach_oid(idxoid, idxlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isUsableIdx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idxRel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexInfo&nbsp; *idxInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxRel = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(idxoid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxInfo = <a href="../../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(idxRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isUsableIdx = <a href="#L804" title="replication/logical/relation.c:804">IsIndexUsableForReplicaIdentityFull</a>(idxInfo, attrmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idxRel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return the first eligible index found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isUsableIdx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> idxoid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if the index is usable for replica identity full.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The index must be btree or <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, non-partial, and the leftmost field must be<br/></li>
<li></span><span class="Comment"> * a column (not an expression) that references the remote relation column. These<br/></li>
<li></span><span class="Comment"> * limitations <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> to keep the index scan similar to PK/RI index scans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * attrmap is a map of local attributes to remote ones. We can consult this<br/></li>
<li></span><span class="Comment"> * map to check whether the local index attribute has a corresponding remote<br/></li>
<li></span><span class="Comment"> * attribute.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the limitations of index scans for replica identity full only<br/></li>
<li></span><span class="Comment"> * adheres to a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the limitations of PK/RI. For example, we support<br/></li>
<li></span><span class="Comment"> * columns that are marked as [NULL] or we are not interested in the [NOT<br/></li>
<li></span><span class="Comment"> * DEFERRABLE] aspect of constraints here. It works for us because we always<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the tuples for non-PK/RI index scans. See<br/></li>
<li></span><span class="Comment"> * <a href="../../executor/execReplication.c.html#L176" title="executor/execReplication.c:176">RelationFindReplTupleByIndex</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reasons why only Btree and Hash indexes can be considered as usable are:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1) Other index access methods don't have a fixed strategy for equality<br/></li>
<li></span><span class="Comment"> * operation. Refer <a href="../../executor/execReplication.c.html#L49" title="executor/execReplication.c:49">get_equal_strategy_number_for_am</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2) For indexes other than PK and REPLICA IDENTITY, we need to match the<br/></li>
<li></span><span class="Comment"> * local and remote tuples. The equality routine <a href="../../executor/execReplication.c.html#L305" title="executor/execReplication.c:305">tuples_equal</a>() cannot <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a><br/></li>
<li></span><span class="Comment"> * a datatype (e.g. point or box) that does not have a default operator class<br/></li>
<li></span><span class="Comment"> * for Btree or Hash.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: Note that BRIN and GIN indexes do not implement &quot;amgettuple&quot; which<br/></li>
<li></span><span class="Comment"> * will be used later to fetch the tuples. See <a href="../../executor/execReplication.c.html#L176" title="executor/execReplication.c:176">RelationFindReplTupleByIndex</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: To support partial indexes, the required changes are likely to be larger.<br/></li>
<li></span><span class="Comment"> * If <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the tuples satisfy the expression for the index scan, we fall-back<br/></li>
<li></span><span class="Comment"> * to sequential execution, which might not be a good idea in some cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L804">&#x200c;</a></span><span class="linkable">IsIndexUsableForReplicaIdentityFull</span>(IndexInfo *indexInfo, AttrMap *attrmap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; keycol;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure that the index access method has a valid <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> strategy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../executor/execReplication.c.html#L49" title="executor/execReplication.c:49">get_equal_strategy_number_for_am</a>(indexInfo-&gt;ii_Am) == InvalidStrategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The index must not be a partial index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Predicate != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexInfo-&gt;ii_NumIndexAttrs &gt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The leftmost index field must not be an expression */<br/></li>
<li></span>&nbsp; &nbsp; keycol = indexInfo-&gt;ii_IndexAttrNumbers[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!AttributeNumberIsValid(keycol))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And the leftmost index field must reference the remote relation column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is because if it doesn't, the sequential scan is favorable over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index scan in most cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attrmap-&gt;maplen &lt;= AttrNumberGetAttrOffset(keycol) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrmap-&gt;attnums[AttrNumberGetAttrOffset(keycol)] &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexAmRoutine *amroutine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The given index access method must implement amgettuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; amroutine = <a href="../../access/index/amapi.c.html#L56" title="access/index/amapi.c:56">GetIndexAmRoutineByAmId</a>(indexInfo-&gt;ii_Am, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(amroutine-&gt;amgettuple != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the OID of the replica identity index if one is defined;<br/></li>
<li></span><span class="Comment"> * the OID of the PK if one exists and is not deferrable;<br/></li>
<li></span><span class="Comment"> * otherwise, InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L851">&#x200c;</a><span class="linkable">GetRelationIdentityOrPK</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; idxoid = <a href="../../utils/cache/relcache.c.html#L5000" title="utils/cache/relcache.c:5000">RelationGetReplicaIndex</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(idxoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxoid = <a href="../../utils/cache/relcache.c.html#L4979" title="utils/cache/relcache.c:4979">RelationGetPrimaryKeyIndex</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> idxoid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the index oid if we can use an index for subscriber. Otherwise,<br/></li>
<li></span><span class="Comment"> * returns InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L868">&#x200c;</a><span class="linkable">FindLogicalRepLocalIndex</span>(Relation localrel, LogicalRepRelation *remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrMap *attrMap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We never need index oid for partitioned tables, always rely on leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition's index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (localrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Simple case, we already have a primary key or a replica identity index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; idxoid = <a href="#L851" title="replication/logical/relation.c:851">GetRelationIdentityOrPK</a>(localrel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(idxoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> idxoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remoterel-&gt;replident == REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are looking for one more opportunity for using an index. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes defined on the local relation, try to pick a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * suitable index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The index selection safely assumes that all the columns are going<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be available for the index scan given that remote relation has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replica identity full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we are not using the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the cheapest method<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to scan the relation as that would require us to either use <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> which would be a maintenance burden in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * long run or use the full-fledged <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> which could cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overhead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L745" title="replication/logical/relation.c:745">FindUsableIndexForReplicaIdentityFull</a>(localrel, attrMap);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
