<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/worker.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/worker.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L291">ApplyContext</a></li>
<li><a href="#L290">ApplyMessageContext</a></li>
<li><a href="#L318">InitializingApplyWorker</a></li>
<li><a href="#L296">LogRepWorkerWalRcvConn</a></li>
<li><a href="#L294">LogicalStreamingContext</a></li>
<li><a href="#L298">MySubscription</a></li>
<li><a href="#L299">MySubscriptionValid</a></li>
<li><a href="#L278">apply_error_callback_arg</a></li>
<li><a href="#L288">apply_error_context_stack</a></li>
<li><a href="#L303">in_remote_transaction</a></li>
<li><a href="#L307">in_streamed_transaction</a></li>
<li><a href="#L204">lsn_mapping</a></li>
<li><a href="#L301">on_commit_wakeup_workers_subids</a></li>
<li><a href="#L315">parallel_stream_nchanges</a></li>
<li><a href="#L304">remote_final_lsn</a></li>
<li><a href="#L335">skip_xact_finish_lsn</a></li>
<li><a href="#L339">stream_fd</a></li>
<li><a href="#L309">stream_xid</a></li>
<li><a href="#L357">subxact_data</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L219">ApplyErrorCallbackArg</a></li>
<li><a href="#L229">ApplyErrorCallbackArg</a></li>
<li><a href="#L206">ApplyExecutionData</a></li>
<li><a href="#L216">ApplyExecutionData</a></li>
<li><a href="#L349">ApplySubXactData</a></li>
<li><a href="#L355">ApplySubXactData</a></li>
<li><a href="#L197">FlushPosition</a></li>
<li><a href="#L202">FlushPosition</a></li>
<li><a href="#L341">SubXactInfo</a></li>
<li><a href="#L346">SubXactInfo</a></li>
<li><a href="#L275">TransApplyAction</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4685">ApplyWorkerMain</a></li>
<li><a href="#L5003">AtEOXact_LogicalRepWorkers</a></li>
<li><a href="#L4705">DisableSubscriptionAndExit</a></li>
<li><a href="#L2846">FindReplTupleInLocalRel</a></li>
<li><a href="#L4561">InitializeLogRepWorker</a></li>
<li><a href="#L4753">IsLogicalParallelApplyWorker</a></li>
<li><a href="#L4744">IsLogicalWorker</a></li>
<li><a href="#L3478">LogicalRepApplyLoop</a></li>
<li><a href="#L4989">LogicalRepWorkersWakeupAtCommit</a></li>
<li><a href="#L428">ReplicationOriginNameForLogicalRep</a></li>
<li><a href="#L4644">SetupApplyOrSyncWorker</a></li>
<li><a href="#L2339">TargetPrivilegesCheck</a></li>
<li><a href="#L4405">TwoPhaseTransactionGid</a></li>
<li><a href="#L3462">UpdateWorkerStats</a></li>
<li><a href="#L3272">apply_dispatch</a></li>
<li><a href="#L4893">apply_error_callback</a></li>
<li><a href="#L991">apply_handle_begin</a></li>
<li><a href="#L1042">apply_handle_begin_prepare</a></li>
<li><a href="#L1016">apply_handle_commit</a></li>
<li><a href="#L2241">apply_handle_commit_internal</a></li>
<li><a href="#L1169">apply_handle_commit_prepared</a></li>
<li><a href="#L2704">apply_handle_delete</a></li>
<li><a href="#L2792">apply_handle_delete_internal</a></li>
<li><a href="#L2371">apply_handle_insert</a></li>
<li><a href="#L2457">apply_handle_insert_internal</a></li>
<li><a href="#L1408">apply_handle_origin</a></li>
<li><a href="#L1108">apply_handle_prepare</a></li>
<li><a href="#L1071">apply_handle_prepare_internal</a></li>
<li><a href="#L2301">apply_handle_relation</a></li>
<li><a href="#L1218">apply_handle_rollback_prepared</a></li>
<li><a href="#L1812">apply_handle_stream_abort</a></li>
<li><a href="#L2131">apply_handle_stream_commit</a></li>
<li><a href="#L1271">apply_handle_stream_prepare</a></li>
<li><a href="#L1467">apply_handle_stream_start</a></li>
<li><a href="#L1626">apply_handle_stream_stop</a></li>
<li><a href="#L3144">apply_handle_truncate</a></li>
<li><a href="#L2893">apply_handle_tuple_routing</a></li>
<li><a href="#L2324">apply_handle_type</a></li>
<li><a href="#L2520">apply_handle_update</a></li>
<li><a href="#L2637">apply_handle_update_internal</a></li>
<li><a href="#L2001">apply_spooled_messages</a></li>
<li><a href="#L3831">apply_worker_exit</a></li>
<li><a href="#L508">begin_replication_step</a></li>
<li><a href="#L4191">changes_filename</a></li>
<li><a href="#L2479">check_relation_updatable</a></li>
<li><a href="#L4388">cleanup_subxact_info</a></li>
<li><a href="#L4812">clear_subscription_skip_lsn</a></li>
<li><a href="#L652">create_edata_for_relation</a></li>
<li><a href="#L531">end_replication_step</a></li>
<li><a href="#L1969">ensure_last_message</a></li>
<li><a href="#L709">finish_edata</a></li>
<li><a href="#L3392">get_flush_position</a></li>
<li><a href="#L5050">get_transaction_apply_action</a></li>
<li><a href="#L559">handle_streamed_transaction</a></li>
<li><a href="#L3862">maybe_reread_subscription</a></li>
<li><a href="#L4763">maybe_start_skipping_changes</a></li>
<li><a href="#L4973">reset_apply_error_context_info</a></li>
<li><a href="#L4457">run_apply_worker</a></li>
<li><a href="#L3742">send_feedback</a></li>
<li><a href="#L5035">set_apply_error_context_origin</a></li>
<li><a href="#L4965">set_apply_error_context_xact</a></li>
<li><a href="#L4338">set_stream_options</a></li>
<li><a href="#L468">should_apply_changes_for_rel</a></li>
<li><a href="#L740">slot_fill_defaults</a></li>
<li><a href="#L898">slot_modify_data</a></li>
<li><a href="#L797">slot_store_data</a></li>
<li><a href="#L4425">start_apply</a></li>
<li><a href="#L4790">stop_skipping_changes</a></li>
<li><a href="#L3436">store_flush_position</a></li>
<li><a href="#L1729">stream_abort_internal</a></li>
<li><a href="#L4205">stream_cleanup_files</a></li>
<li><a href="#L4274">stream_close_file</a></li>
<li><a href="#L4322">stream_open_and_write_change</a></li>
<li><a href="#L4229">stream_open_file</a></li>
<li><a href="#L1429">stream_start_internal</a></li>
<li><a href="#L1603">stream_stop_internal</a></li>
<li><a href="#L4292">stream_write_change</a></li>
<li><a href="#L3991">subscription_change_cb</a></li>
<li><a href="#L4184">subxact_filename</a></li>
<li><a href="#L4106">subxact_info_add</a></li>
<li><a href="#L4055">subxact_info_read</a></li>
<li><a href="#L4006">subxact_info_write</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L195">NAPTIME_PER_CYCLE</a></li>
<li><a href="#L336">is_skipping_changes</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * worker.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; PostgreSQL logical replication worker (apply)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2016-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/worker.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file contains the worker which applies logical changes as they come<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; from remote logical replication stream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> worker (apply) is started by logical replication worker<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; launcher for every enabled subscription in a database. It uses<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; walsender protocol to communicate with publisher.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This module includes server facing code and shares libpqwalreceiver<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; module with walreceiver for providing the libpq specific functionality.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * STREAMED TRANSACTIONS<br/></li>
<li></span><span class="Comment"> * ---------------------<br/></li>
<li></span><span class="Comment"> * Streamed transactions (large transactions exceeding a memory limit on the<br/></li>
<li></span><span class="Comment"> * upstream) are applied using one of two approaches:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1) Write to temporary files and apply when the final commit arrives<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This approach is used when the user has set the subscription's streaming<br/></li>
<li></span><span class="Comment"> * option as on.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike the regular (non-streamed) case, handling streamed transactions has<br/></li>
<li></span><span class="Comment"> * to handle aborts of both the toplevel transaction and subtransactions. This<br/></li>
<li></span><span class="Comment"> * is achieved by tracking offsets for subtransactions, which is then used<br/></li>
<li></span><span class="Comment"> * to truncate the file with serialized changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The files are placed in tmp file directory by default, and the filenames<br/></li>
<li></span><span class="Comment"> * include both the XID of the toplevel transaction and OID of the<br/></li>
<li></span><span class="Comment"> * subscription. This is necessary so that different workers processing a<br/></li>
<li></span><span class="Comment"> * remote transaction with the same XID doesn't interfere.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use BufFiles instead of using normal temporary files because (a) the<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> infrastructure supports temporary files that exceed the OS file size<br/></li>
<li></span><span class="Comment"> * limit, (b) provides a way for automatic clean up on the error and (c) provides<br/></li>
<li></span><span class="Comment"> * a way to survive these files across local transactions and allow to open and<br/></li>
<li></span><span class="Comment"> * close at stream start and close. We decided to use FileSet<br/></li>
<li></span><span class="Comment"> * infrastructure as without that it deletes the files on the closure of the<br/></li>
<li></span><span class="Comment"> * file and if we decide to keep stream files open across the start/stop stream<br/></li>
<li></span><span class="Comment"> * then it will consume a lot of memory (more than 8K for each <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> and<br/></li>
<li></span><span class="Comment"> * there could be multiple such BufFiles as the subscriber could receive<br/></li>
<li></span><span class="Comment"> * multiple start/stop streams for different transactions <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> getting the<br/></li>
<li></span><span class="Comment"> * commit). Moreover, if we don't use FileSet then we also need to invent<br/></li>
<li></span><span class="Comment"> * a new way to pass filenames to <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> APIs so that we are allowed to open<br/></li>
<li></span><span class="Comment"> * the file we desired across multiple stream-open calls for the same<br/></li>
<li></span><span class="Comment"> * transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2) Parallel apply workers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This approach is used when the user has set the subscription's streaming<br/></li>
<li></span><span class="Comment"> * option as parallel. See logical/applyparallelworker.c for information about<br/></li>
<li></span><span class="Comment"> * this approach.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TWO_PHASE TRANSACTIONS<br/></li>
<li></span><span class="Comment"> * ----------------------<br/></li>
<li></span><span class="Comment"> * Two phase transactions are replayed at prepare and then committed or<br/></li>
<li></span><span class="Comment"> * rolled back at commit prepared and rollback prepared respectively. It is<br/></li>
<li></span><span class="Comment"> * possible to have a prepared transaction that arrives at the apply worker<br/></li>
<li></span><span class="Comment"> * when the tablesync is busy doing the initial copy. In this case, the apply<br/></li>
<li></span><span class="Comment"> * worker skips all the prepared operations [e.g. inserts] while the tablesync<br/></li>
<li></span><span class="Comment"> * is still busy (see the condition of <a href="#L468" title="replication/logical/worker.c:468">should_apply_changes_for_rel</a>). The<br/></li>
<li></span><span class="Comment"> * tablesync worker might not get such a prepared transaction because say it<br/></li>
<li></span><span class="Comment"> * was prior to the initial consistent point but might have got some later<br/></li>
<li></span><span class="Comment"> * commits. Now, the tablesync worker will exit without doing anything for the<br/></li>
<li></span><span class="Comment"> * prepared transaction skipped by the apply worker as the sync location for it<br/></li>
<li></span><span class="Comment"> * will be already ahead of the apply worker's current location. This would lead<br/></li>
<li></span><span class="Comment"> * to an &quot;empty prepare&quot;, because later when the apply worker does the commit<br/></li>
<li></span><span class="Comment"> * prepare, there is nothing in it (the inserts were skipped earlier).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid this, and similar prepare confusions the subscription's two_phase<br/></li>
<li></span><span class="Comment"> * commit is enabled only after the initial sync is over. The two_phase option<br/></li>
<li></span><span class="Comment"> * has been implemented as a tri-state with <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> DISABLED, PENDING, and<br/></li>
<li></span><span class="Comment"> * ENABLED.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Even if the user specifies they want a subscription with two_phase = on,<br/></li>
<li></span><span class="Comment"> * internally it will start with a tri-state of PENDING which only becomes<br/></li>
<li></span><span class="Comment"> * ENABLED after all tablesync initializations are completed - i.e. when all<br/></li>
<li></span><span class="Comment"> * tablesync workers have reached their READY state. In other words, the value<br/></li>
<li></span><span class="Comment"> * PENDING is only a temporary state for subscription start-up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Until the two_phase is properly available (ENABLED) the subscription will<br/></li>
<li></span><span class="Comment"> * behave as if two_phase = off. When the apply worker detects that all<br/></li>
<li></span><span class="Comment"> * tablesyncs have become READY (while the tri-state was PENDING) it will<br/></li>
<li></span><span class="Comment"> * restart the apply worker process. This happens in<br/></li>
<li></span><span class="Comment"> * <a href="tablesync.c.html#L418" title="replication/logical/tablesync.c:418">process_syncing_tables_for_apply</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the (re-started) apply worker finds that all tablesyncs are READY for a<br/></li>
<li></span><span class="Comment"> * two_phase tri-state of PENDING it start streaming messages with the<br/></li>
<li></span><span class="Comment"> * two_phase option which in turn enables the decoding of two-phase commits at<br/></li>
<li></span><span class="Comment"> * the publisher. Then, it updates the tri-state value from PENDING to ENABLED.<br/></li>
<li></span><span class="Comment"> * Now, it is possible that during the time we have not enabled two_phase, the<br/></li>
<li></span><span class="Comment"> * publisher (replication server) would have skipped some prepares but we<br/></li>
<li></span><span class="Comment"> * ensure that such prepares are sent along with commit prepare, see<br/></li>
<li></span><span class="Comment"> * <a href="reorderbuffer.c.html#L2817" title="replication/logical/reorderbuffer.c:2817">ReorderBufferFinishPrepared</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the subscription has no tables then a two_phase tri-state PENDING is<br/></li>
<li></span><span class="Comment"> * left unchanged. This lets the user still do an ALTER SUBSCRIPTION REFRESH<br/></li>
<li></span><span class="Comment"> * PUBLICATION which might otherwise be disallowed (see below).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If ever a user needs to be aware of the tri-state value, they can fetch it<br/></li>
<li></span><span class="Comment"> * from the pg_subscription catalog (see column subtwophasestate).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't allow to toggle two_phase option of a subscription because it can<br/></li>
<li></span><span class="Comment"> * lead to an inconsistent replica. Consider, initially, it was on and we have<br/></li>
<li></span><span class="Comment"> * received some prepare then we turn it off, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> at commit time the server<br/></li>
<li></span><span class="Comment"> * will <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the entire transaction data along with the commit. With some more<br/></li>
<li></span><span class="Comment"> * analysis, we can allow changing this option from off to on but not sure if<br/></li>
<li></span><span class="Comment"> * that alone would be useful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Finally, to avoid problems mentioned in previous paragraphs from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * subsequent (not READY) tablesyncs (need to toggle two_phase option from 'on'<br/></li>
<li></span><span class="Comment"> * to 'off' and then again back to 'on') there is a restriction for<br/></li>
<li></span><span class="Comment"> * ALTER SUBSCRIPTION REFRESH PUBLICATION. This command is not permitted when<br/></li>
<li></span><span class="Comment"> * the two_phase tri-state is ENABLED, except when copy_data = false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can get prepare of the same GID more than once for the genuine cases<br/></li>
<li></span><span class="Comment"> * where we have defined multiple subscriptions for publications on the same<br/></li>
<li></span><span class="Comment"> * server and prepared transaction has operations on tables subscribed to those<br/></li>
<li></span><span class="Comment"> * subscriptions. For such cases, if we use the GID sent by publisher one of<br/></li>
<li></span><span class="Comment"> * the prepares will be successful and others will fail, in which case the<br/></li>
<li></span><span class="Comment"> * server will <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> them again. Now, this can lead to a deadlock if user has<br/></li>
<li></span><span class="Comment"> * set synchronous_standby_names for all the subscriptions on subscriber. To<br/></li>
<li></span><span class="Comment"> * avoid such deadlocks, we generate a unique GID (consisting of the<br/></li>
<li></span><span class="Comment"> * subscription oid and the xid of the prepared transaction) for each prepare<br/></li>
<li></span><span class="Comment"> * transaction on the subscriber.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * FAILOVER<br/></li>
<li></span><span class="Comment"> * ----------------------<br/></li>
<li></span><span class="Comment"> * The logical slot on the primary can be synced to the standby by specifying<br/></li>
<li></span><span class="Comment"> * failover = true when creating the subscription. Enabling failover allows us<br/></li>
<li></span><span class="Comment"> * to smoothly transition to the promoted standby, ensuring that we can<br/></li>
<li></span><span class="Comment"> * subscribe to the new primary without losing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_inherits.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription_rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/execPartition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/walwriter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicallauncher.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalproto.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalrelation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/worker_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteHandler.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/buffile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dynahash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rls.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/usercontext.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L195">&#x200c;</a><span class="PreProc">#define <span class="linkable">NAPTIME_PER_CYCLE</span> </span><span class="Constant">1000</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* max sleep time between cycles (1s) */<br/></li>
<li></span><br/></li>
<li><a id="L197">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FlushPosition</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; node;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; local_end;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; remote_end;<br/></li>
<li><a id="L202">&#x200c;</a>} <span class="linkable">FlushPosition</span>;<br/></li>
<li><br/></li>
<li><a id="L204">&#x200c;</a><span class="Type">static</span> dlist_head <span class="linkable">lsn_mapping</span> = DLIST_STATIC_INIT(<span class="linkable">lsn_mapping</span>);<br/></li>
<li><br/></li>
<li><a id="L206">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ApplyExecutionData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* executor state, used to track resources */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *targetRel;&nbsp; &nbsp; <span class="Comment">/* replication target rel */<br/></li>
<li></span>&nbsp; &nbsp; ResultRelInfo *targetRelInfo;&nbsp; &nbsp; <span class="Comment">/* ResultRelInfo for same */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These fields are used when the target relation is partitioned: */<br/></li>
<li></span>&nbsp; &nbsp; ModifyTableState *mtstate;&nbsp; &nbsp; <span class="Comment">/* dummy ModifyTable state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execPartition.c.html#L91" title="executor/execPartition.c:91">PartitionTupleRouting</a> *proute;&nbsp; &nbsp; <span class="Comment">/* partition routing info */<br/></li>
<li><a id="L216">&#x200c;</a></span>} <span class="linkable">ApplyExecutionData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Struct for saving and restoring apply errcontext information */<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ApplyErrorCallbackArg</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepMsgType command;&nbsp; &nbsp; <span class="Comment">/* 0 if invalid */<br/></li>
<li></span>&nbsp; &nbsp; LogicalRepRelMapEntry *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remote node information */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_attnum;&nbsp; &nbsp; <span class="Comment">/* -1 if invalid */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId remote_xid;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; finish_lsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *origin_name;<br/></li>
<li><a id="L229">&#x200c;</a>} <span class="linkable">ApplyErrorCallbackArg</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The action to be taken for the changes in the transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TRANS_LEADER_APPLY:<br/></li>
<li></span><span class="Comment"> * This action means that we are in the leader apply worker or table sync<br/></li>
<li></span><span class="Comment"> * worker. The changes of the transaction are either directly applied or<br/></li>
<li></span><span class="Comment"> * are read from temporary files (for streaming transactions) and then<br/></li>
<li></span><span class="Comment"> * applied by the worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TRANS_LEADER_SERIALIZE:<br/></li>
<li></span><span class="Comment"> * This action means that we are in the leader apply worker or table sync<br/></li>
<li></span><span class="Comment"> * worker. Changes are written to temporary files and then applied when the<br/></li>
<li></span><span class="Comment"> * final commit arrives.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TRANS_LEADER_SEND_TO_PARALLEL:<br/></li>
<li></span><span class="Comment"> * This action means that we are in the leader apply worker and need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment"> * the changes to the parallel apply worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TRANS_LEADER_PARTIAL_SERIALIZE:<br/></li>
<li></span><span class="Comment"> * This action means that we are in the leader apply worker and have sent some<br/></li>
<li></span><span class="Comment"> * changes directly to the parallel apply worker and the remaining changes are<br/></li>
<li></span><span class="Comment"> * serialized to a file, due to timeout while sending data. The parallel apply<br/></li>
<li></span><span class="Comment"> * worker will apply these serialized changes when the final commit arrives.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't use TRANS_LEADER_SERIALIZE for this case because, in addition to<br/></li>
<li></span><span class="Comment"> * serializing changes, the leader worker also needs to serialize the<br/></li>
<li></span><span class="Comment"> * STREAM_XXX message to a file, and wait for the parallel apply worker to<br/></li>
<li></span><span class="Comment"> * finish the transaction when processing the transaction finish command. So<br/></li>
<li></span><span class="Comment"> * this new action was introduced to keep the code and logic clear.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TRANS_PARALLEL_APPLY:<br/></li>
<li></span><span class="Comment"> * This action means that we are in the parallel apply worker and changes of<br/></li>
<li></span><span class="Comment"> * the transaction are applied directly by the worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The action for non-streaming transactions. */<br/></li>
<li></span>&nbsp; &nbsp; TRANS_LEADER_APPLY,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../tsearch/wparser_def.c.html#L1628" title="tsearch/wparser_def.c:1628">Actions</a> for streaming transactions. */<br/></li>
<li></span>&nbsp; &nbsp; TRANS_LEADER_SERIALIZE,<br/></li>
<li>&nbsp; &nbsp; TRANS_LEADER_SEND_TO_PARALLEL,<br/></li>
<li>&nbsp; &nbsp; TRANS_LEADER_PARTIAL_SERIALIZE,<br/></li>
<li>&nbsp; &nbsp; TRANS_PARALLEL_APPLY,<br/></li>
<li><a id="L275">&#x200c;</a>} <span class="linkable">TransApplyAction</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* errcontext tracker */<br/></li>
<li><a id="L278">&#x200c;</a></span><a href="#L219" title="replication/logical/worker.c:219">ApplyErrorCallbackArg</a> <span class="linkable">apply_error_callback_arg</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .command = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; .rel = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; .remote_attnum = -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; .remote_xid = InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; .finish_lsn = InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; .origin_name = <span class="Constant">NULL</span>,<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L288">&#x200c;</a>ErrorContextCallback *<span class="linkable">apply_error_context_stack</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L290">&#x200c;</a>MemoryContext <span class="linkable">ApplyMessageContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L291">&#x200c;</a>MemoryContext <span class="linkable">ApplyContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* per stream context for streaming transactions */<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">LogicalStreamingContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L296">&#x200c;</a><a href="../libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<span class="linkable">LogRepWorkerWalRcvConn</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L298">&#x200c;</a>Subscription *<span class="linkable">MySubscription</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L299">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">MySubscriptionValid</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L301">&#x200c;</a><span class="Type">static</span> List *<span class="linkable">on_commit_wakeup_workers_subids</span> = NIL;<br/></li>
<li><br/></li>
<li><a id="L303">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">in_remote_transaction</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L304">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">remote_final_lsn</span> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li><span class="Comment">/* fields valid only when processing streamed transaction */<br/></li>
<li><a id="L307">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">in_streamed_transaction</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L309">&#x200c;</a><span class="Type">static</span> TransactionId <span class="linkable">stream_xid</span> = InvalidTransactionId;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The number of changes applied by parallel apply worker during one streaming<br/></li>
<li></span><span class="Comment"> * block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L315">&#x200c;</a></span><span class="Type">static</span> uint32 <span class="linkable">parallel_stream_nchanges</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Are we initializing an apply worker? */<br/></li>
<li><a id="L318">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">InitializingApplyWorker</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We enable skipping all data modification changes (INSERT, UPDATE, etc.) for<br/></li>
<li></span><span class="Comment"> * the subscription if the remote transaction's finish LSN matches the subskiplsn.<br/></li>
<li></span><span class="Comment"> * Once we start skipping changes, we don't stop it until we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> all changes of<br/></li>
<li></span><span class="Comment"> * the transaction even if pg_subscription is updated and <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;skiplsn<br/></li>
<li></span><span class="Comment"> * gets changed or reset during that. Also, in streaming transaction cases (streaming = on),<br/></li>
<li></span><span class="Comment"> * we don't <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> receiving and spooling the changes since we decide whether or not<br/></li>
<li></span><span class="Comment"> * to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> applying the changes when starting to apply changes. The subskiplsn is<br/></li>
<li></span><span class="Comment"> * cleared after successfully skipping the transaction or applying non-empty<br/></li>
<li></span><span class="Comment"> * transaction. The latter prevents the mistakenly specified subskiplsn from<br/></li>
<li></span><span class="Comment"> * being left. Note that we cannot <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the streaming transactions when using<br/></li>
<li></span><span class="Comment"> * parallel apply workers because we cannot get the finish LSN <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying<br/></li>
<li></span><span class="Comment"> * the changes. So, we don't start parallel apply worker when finish LSN is set<br/></li>
<li></span><span class="Comment"> * by the user.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L335">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">skip_xact_finish_lsn</span> = InvalidXLogRecPtr;<br/></li>
<li><a id="L336">&#x200c;</a><span class="PreProc">#define <span class="linkable">is_skipping_changes</span>() (unlikely(!XLogRecPtrIsInvalid(<a href="#L335" title="replication/logical/worker.c:335">skip_xact_finish_lsn</a>)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> handle of the current streaming file */<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="Type">static</span> <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> *<span class="linkable">stream_fd</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L341">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SubXactInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XID of the subxact */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* file number in the buffile */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; offset;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* offset in the file */<br/></li>
<li><a id="L346">&#x200c;</a></span>} <span class="linkable">SubXactInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Sub-transaction data for the current streaming transaction */<br/></li>
<li><a id="L349">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ApplySubXactData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nsubxacts;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of sub-transactions */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nsubxacts_max;&nbsp; &nbsp; <span class="Comment">/* current capacity of subxacts */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId subxact_last; <span class="Comment">/* xid of the last sub-transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L341" title="replication/logical/worker.c:341">SubXactInfo</a> *subxacts;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sub-xact offset in changes file */<br/></li>
<li><a id="L355">&#x200c;</a></span>} <span class="linkable">ApplySubXactData</span>;<br/></li>
<li><br/></li>
<li><a id="L357">&#x200c;</a><span class="Type">static</span> <a href="#L349" title="replication/logical/worker.c:349">ApplySubXactData</a> <span class="linkable">subxact_data</span> = {<span class="Constant">0</span>, <span class="Constant">0</span>, InvalidTransactionId, <span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4184" title="replication/logical/worker.c:4184">subxact_filename</a>(<span class="Type">char</span> *path, Oid subid, TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4191" title="replication/logical/worker.c:4191">changes_filename</a>(<span class="Type">char</span> *path, Oid subid, TransactionId xid);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Information about subtransactions of a given toplevel transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L4006" title="replication/logical/worker.c:4006">subxact_info_write</a>(Oid subid, TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4055" title="replication/logical/worker.c:4055">subxact_info_read</a>(Oid subid, TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4106" title="replication/logical/worker.c:4106">subxact_info_add</a>(TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4388" title="replication/logical/worker.c:4388">cleanup_subxact_info</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Serialize and deserialize changes for a toplevel transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L4229" title="replication/logical/worker.c:4229">stream_open_file</a>(Oid subid, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> first_segment);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a>(<span class="Type">char</span> action, StringInfo s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4322" title="replication/logical/worker.c:4322">stream_open_and_write_change</a>(TransactionId xid, <span class="Type">char</span> action, StringInfo s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4274" title="replication/logical/worker.c:4274">stream_close_file</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3742" title="replication/logical/worker.c:3742">send_feedback</a>(XLogRecPtr recvpos, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> requestReply);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2241" title="replication/logical/worker.c:2241">apply_handle_commit_internal</a>(LogicalRepCommitData *commit_data);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2457" title="replication/logical/worker.c:2457">apply_handle_insert_internal</a>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResultRelInfo *relinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2637" title="replication/logical/worker.c:2637">apply_handle_update_internal</a>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResultRelInfo *relinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepTupleData *newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid localindexoid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2792" title="replication/logical/worker.c:2792">apply_handle_delete_internal</a>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResultRelInfo *relinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid localindexoid);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2846" title="replication/logical/worker.c:2846">FindReplTupleInLocalRel</a>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata, Relation localrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepRelation *remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid localidxoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot **localslot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2893" title="replication/logical/worker.c:2893">apply_handle_tuple_routing</a>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepTupleData *newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CmdType operation);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Compute GID for two_phase transactions */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L4405" title="replication/logical/worker.c:4405">TwoPhaseTransactionGid</a>(Oid subid, TransactionId xid, <span class="Type">char</span> *gid, <span class="Type">int</span> szgid);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Functions for skipping changes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L4763" title="replication/logical/worker.c:4763">maybe_start_skipping_changes</a>(XLogRecPtr finish_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4790" title="replication/logical/worker.c:4790">stop_skipping_changes</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4812" title="replication/logical/worker.c:4812">clear_subscription_skip_lsn</a>(XLogRecPtr finish_lsn);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Functions for apply error callback */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(TransactionId xid, XLogRecPtr lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> <a href="#L5050" title="replication/logical/worker.c:5050">get_transaction_apply_action</a>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelApplyWorkerInfo **winfo);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form the origin name for the subscription.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a common function for tablesync and other workers. Tablesync workers<br/></li>
<li></span><span class="Comment"> * must pass a valid relid. Other callers must pass relid = InvalidOid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the name in the supplied buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L428">&#x200c;</a></span><span class="linkable">ReplicationOriginNameForLogicalRep</span>(Oid suboid, Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *originname, Size szoriginname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replication origin name for tablesync workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(originname, szoriginname, <span class="Constant">&quot;pg_</span><span class="Special">%u</span><span class="Constant"><a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%u</span><span class="Constant">&quot;</span>, suboid, relid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replication origin name for non-tablesync workers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(originname, szoriginname, <span class="Constant">&quot;pg_</span><span class="Special">%u</span><span class="Constant">&quot;</span>, suboid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Should this worker apply changes for given relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is mainly needed for initial relation data sync as that runs in<br/></li>
<li></span><span class="Comment"> * separate worker process running in parallel and we need some way to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment"> * changes coming to the leader apply worker during the sync of a table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we need to do smaller or equals comparison for SYNCDONE state because<br/></li>
<li></span><span class="Comment"> * it might hold position of end of initial slot consistent point WAL<br/></li>
<li></span><span class="Comment"> * record + 1 (ie start of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record) and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record can be COMMIT of<br/></li>
<li></span><span class="Comment"> * transaction we are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> processing (which is what we set <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a><br/></li>
<li></span><span class="Comment"> * to in <a href="#L991" title="replication/logical/worker.c:991">apply_handle_begin</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that for streaming transactions that are being applied in the parallel<br/></li>
<li></span><span class="Comment"> * apply worker, we disallow applying changes if the target table in the<br/></li>
<li></span><span class="Comment"> * subscription is not in the READY state, because we cannot decide whether to<br/></li>
<li></span><span class="Comment"> * apply the change as we won't know <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a> by that time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We already checked this in <a href="applyparallelworker.c.html#L265" title="replication/logical/applyparallelworker.c:265">pa_can_start</a>() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> assigning the<br/></li>
<li></span><span class="Comment"> * streaming transaction to the parallel worker, but it also needs to be<br/></li>
<li></span><span class="Comment"> * checked here because if the user executes ALTER SUBSCRIPTION ... REFRESH<br/></li>
<li></span><span class="Comment"> * PUBLICATION in parallel, the new table can be added to pg_subscription_rel<br/></li>
<li></span><span class="Comment"> * while applying this transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L468">&#x200c;</a></span><span class="linkable">should_apply_changes_for_rel</span>(LogicalRepRelMapEntry *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_TABLESYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;relid == rel-&gt;localreloid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_PARALLEL_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't synchronize rel's that are in unknown state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;state != SUBREL_STATE_READY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;state != SUBREL_STATE_UNKNOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication parallel apply worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will stop&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Cannot handle streamed replication transactions using parallel apply workers until all tables have been synchronized.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rel-&gt;state == SUBREL_STATE_READY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (rel-&gt;state == SUBREL_STATE_READY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rel-&gt;state == SUBREL_STATE_SYNCDONE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;statelsn &lt;= <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WORKERTYPE_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never happen. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;Unknown worker type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dummy for compiler */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Begin one step (one INSERT, UPDATE, etc) of a replication transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Start a transaction, if this is the first step (else we keep using the<br/></li>
<li></span><span class="Comment"> * existing transaction).<br/></li>
<li></span><span class="Comment"> * Also provide a global snapshot and ensure we run in <a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L508">&#x200c;</a></span><span class="linkable">begin_replication_step</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3862" title="replication/logical/worker.c:3862">maybe_reread_subscription</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish up one step of a replication transaction.<br/></li>
<li></span><span class="Comment"> * Callers of <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>() must also call this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't close out the transaction here, but we should increment<br/></li>
<li></span><span class="Comment"> * the command counter to make the effects of this step visible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L531">&#x200c;</a></span><span class="linkable">end_replication_step</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle streamed transactions for both the leader apply worker and the<br/></li>
<li></span><span class="Comment"> * parallel apply workers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the streaming case (receiving a block of the streamed transaction), for<br/></li>
<li></span><span class="Comment"> * serialize mode, simply redirect it to a file for the proper toplevel<br/></li>
<li></span><span class="Comment"> * transaction, and for parallel mode, the leader apply worker will <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment"> * changes to parallel apply workers and the parallel apply worker will define<br/></li>
<li></span><span class="Comment"> * savepoints if needed. (LOGICAL_REP_MSG_RELATION or LOGICAL_REP_MSG_TYPE<br/></li>
<li></span><span class="Comment"> * messages will be applied by both leader apply worker and parallel apply<br/></li>
<li></span><span class="Comment"> * workers).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true for streamed transactions (when the change is either serialized<br/></li>
<li></span><span class="Comment"> * to file or sent to parallel apply worker), false otherwise (regular mode or<br/></li>
<li></span><span class="Comment"> * needs to be processed by parallel apply worker).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Exception: If the message being processed is LOGICAL_REP_MSG_RELATION<br/></li>
<li></span><span class="Comment"> * or LOGICAL_REP_MSG_TYPE, return false even if the message needs to be sent<br/></li>
<li></span><span class="Comment"> * to a parallel apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L559">&#x200c;</a></span><span class="linkable">handle_streamed_transaction</span>(LogicalRepMsgType action, StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId current_xid;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> apply_action;<br/></li>
<li>&nbsp; &nbsp; StringInfoData original_msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; apply_action = <a href="#L5050" title="replication/logical/worker.c:5050">get_transaction_apply_action</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>, &amp;winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not in streaming mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (apply_action == TRANS_LEADER_APPLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parallel apply worker needs the xid in this message to decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether to define a savepoint, so save the original message that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not moved the cursor after the xid. We will serialize this message to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file in PARTIAL_SERIALIZE mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; original_msg = *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should have received XID of the subxact as the first part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * message, so extract it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; current_xid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(s, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(current_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;invalid transaction ID in streamed replication transaction&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (apply_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the new subxact to the array (unless already there). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4106" title="replication/logical/worker.c:4106">subxact_info_add</a>(current_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write the change to the current file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a>(action, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SEND_TO_PARALLEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> The publisher side doesn't always <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> relation/type update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages after the streaming transaction, so also update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation/type in leader apply worker. See function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../pgoutput/pgoutput.c.html#L2232" title="replication/pgoutput/pgoutput.c:2232">cleanup_rel_sync_cache</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="applyparallelworker.c.html#L1146" title="replication/logical/applyparallelworker.c:1146">pa_send_data</a>(winfo, s-&gt;len, s-&gt;data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (action != LOGICAL_REP_MSG_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action != LOGICAL_REP_MSG_TYPE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to serialize mode when we are not able to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change to parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1211" title="replication/logical/applyparallelworker.c:1211">pa_switch_to_partial_serialize</a>(winfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_PARTIAL_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a>(action, &amp;original_msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same reason as TRANS_LEADER_SEND_TO_PARALLEL case. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (action != LOGICAL_REP_MSG_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action != LOGICAL_REP_MSG_TYPE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_PARALLEL_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L315" title="replication/logical/worker.c:315">parallel_stream_nchanges</a> += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Define a savepoint for a subxact if needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1362" title="replication/logical/applyparallelworker.c:1362">pa_start_subtrans</a>(current_xid, <a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected apply action: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) apply_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence compiler warning */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Executor state preparation for evaluation of constraint expressions,<br/></li>
<li></span><span class="Comment"> * indexes and triggers for the specified relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the caller must open and close <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes to be updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *<br/></li>
<li><a id="L652">&#x200c;</a><span class="linkable">create_edata_for_relation</span>(LogicalRepRelMapEntry *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *perminfos = NIL;<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *resultRelInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata = (<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a>));<br/></li>
<li>&nbsp; &nbsp; edata-&gt;targetRel = rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;estate = estate = <a href="../../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rtekind = RTE_RELATION;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relid = RelationGetRelid(rel-&gt;localrel);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relkind = rel-&gt;localrel-&gt;rd_rel-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rellockmode = AccessShareLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>(&amp;perminfos, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execUtils.c.html#L728" title="executor/execUtils.c:728">ExecInitRangeTable</a>(estate, list_make1(rte), perminfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; edata-&gt;targetRelInfo = resultRelInfo = makeNode(ResultRelInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use Relation opened by <a href="relation.c.html#L327" title="replication/logical/relation.c:327">logicalrep_rel_open</a>() instead of opening it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execMain.c.html#L1199" title="executor/execMain.c:1199">InitResultRelInfo</a>(resultRelInfo, rel-&gt;localrel, <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We put the ResultRelInfo in the es_opened_result_relations list, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though we don't populate the es_result_relations array.&nbsp; That's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bogus, but it's enough to make <a href="../../executor/execMain.c.html#L1296" title="executor/execMain.c:1296">ExecGetTriggerResultRel</a>() <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>() is not called here either, each execution path doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an apply operation being responsible for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate-&gt;es_opened_result_relations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(estate-&gt;es_opened_result_relations, resultRelInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_output_cid = <a href="../../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to catch AFTER triggers. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5018" title="commands/trigger.c:5018">AfterTriggerBeginQuery</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* other fields of edata remain NULL for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> edata;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operations related to the executor state created by<br/></li>
<li></span><span class="Comment"> * <a href="#L652" title="replication/logical/worker.c:652">create_edata_for_relation</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">finish_edata</span>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = edata-&gt;estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> queued AFTER triggers. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5038" title="commands/trigger.c:5038">AfterTriggerEndQuery</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shut down tuple routing, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> was done. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (edata-&gt;proute)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execPartition.c.html#L1231" title="executor/execPartition.c:1231">ExecCleanupTupleRouting</a>(edata-&gt;mtstate, edata-&gt;proute);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cleanup.&nbsp; It might seem that we should call <a href="../../executor/execMain.c.html#L1517" title="executor/execMain.c:1517">ExecCloseResultRelations</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, but we intentionally don't.&nbsp; It would close the rel we added to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * es_opened_result_relations above, which is wrong because we took no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding refcount.&nbsp; We rely on <a href="../../executor/execPartition.c.html#L1231" title="executor/execPartition.c:1231">ExecCleanupTupleRouting</a>() to close<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other relations opened during execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1278" title="executor/execTuples.c:1278">ExecResetTupleTable</a>(estate-&gt;es_tupleTable, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(edata);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Executes default <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for columns for which we can't map to remote<br/></li>
<li></span><span class="Comment"> * relation columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows us to support tables which have more columns on the downstream<br/></li>
<li></span><span class="Comment"> * than on the upstream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L740">&#x200c;</a></span><span class="linkable">slot_fill_defaults</span>(LogicalRepRelMapEntry *rel, EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc = RelationGetDescr(rel-&gt;localrel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_phys_attrs = desc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_defaults = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *defmap;<br/></li>
<li>&nbsp; &nbsp; ExprState **defexprs;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We got all the data via replication, no need to evaluate anything. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num_phys_attrs == rel-&gt;remoterel.natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; defmap = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_phys_attrs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; defexprs = (ExprState **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(num_phys_attrs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExprState *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rel-&gt;attrmap-&gt;maplen == num_phys_attrs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (attnum = <span class="Constant">0</span>; attnum &lt; num_phys_attrs; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *defexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(desc, attnum)-&gt;attisdropped || TupleDescAttr(desc, attnum)-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;attrmap-&gt;attnums[attnum] &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; defexpr = (Expr *) <a href="../../rewrite/rewriteHandler.c.html#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>(rel-&gt;localrel, attnum + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defexpr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Run the expression through <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defexpr = <a href="../../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>(defexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize executable expression in copycontext */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defexprs[num_defaults] = <a href="../../executor/execExpr.c.html#L134" title="executor/execExpr.c:134">ExecInitExpr</a>(defexpr, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defmap[num_defaults] = attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_defaults++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_defaults; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[defmap[i]] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecEvalExpr(defexprs[i], econtext, &amp;slot-&gt;tts_isnull[defmap[i]]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store tuple data into slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Incoming data can be either text or binary format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L797">&#x200c;</a></span><span class="linkable">slot_store_data</span>(TupleTableSlot *slot, LogicalRepRelMapEntry *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepTupleData *tupleData)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = slot-&gt;tts_tupleDescriptor-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Call the &quot;in&quot; function for each non-dropped, non-null attribute */<br/></li>
<li></span>&nbsp; &nbsp; Assert(natts == rel-&gt;attrmap-&gt;maplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(slot-&gt;tts_tupleDescriptor, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteattnum = rel-&gt;attrmap-&gt;attnums[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!att-&gt;attisdropped &amp;&amp; remoteattnum &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; colvalue = &amp;tupleData-&gt;colvalues[remoteattnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(remoteattnum &lt; tupleData-&gt;ncols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set attnum for error callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.remote_attnum = remoteattnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupleData-&gt;colstatus[remoteattnum] == LOGICALREP_COLUMN_TEXT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typinput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(att-&gt;atttypid, &amp;typinput, &amp;typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1754" title="utils/fmgr/fmgr.c:1754">OidInputFunctionCall</a>(typinput, colvalue-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typioparam, att-&gt;atttypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tupleData-&gt;colstatus[remoteattnum] == LOGICALREP_COLUMN_BINARY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typreceive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In some code paths we may be asked to re-<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple data.&nbsp; Reset the StringInfo's cursor so that works.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colvalue-&gt;cursor = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2940" title="utils/cache/lsyscache.c:2940">getTypeBinaryInputInfo</a>(att-&gt;atttypid, &amp;typreceive, &amp;typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1772" title="utils/fmgr/fmgr.c:1772">OidReceiveFunctionCall</a>(typreceive, colvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typioparam, att-&gt;atttypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Trouble if it didn't eat the whole buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colvalue-&gt;cursor != colvalue-&gt;len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incorrect binary data format in logical replication column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteattnum + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL value from remote.&nbsp; (We don't expect to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LOGICALREP_COLUMN_UNCHANGED here, but if we do, treat it as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset attnum for error callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.remote_attnum = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assign NULL to dropped attributes and missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> should be later filled using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L740" title="replication/logical/worker.c:740">slot_fill_defaults</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replace updated columns with data from the LogicalRepTupleData struct.<br/></li>
<li></span><span class="Comment"> * This is somewhat similar to <a href="../../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a> but also calls the type<br/></li>
<li></span><span class="Comment"> * input <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> on the user data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;slot&quot; is filled with a copy of the tuple in &quot;srcslot&quot;, replacing<br/></li>
<li></span><span class="Comment"> * columns provided in &quot;tupleData&quot; and leaving others as-is.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: unreplaced pass-by-ref columns in &quot;slot&quot; will point into the<br/></li>
<li></span><span class="Comment"> * storage for &quot;srcslot&quot;.&nbsp; This is OK for current usage, but someday we may<br/></li>
<li></span><span class="Comment"> * need to materialize &quot;slot&quot; at the end to make it independent of &quot;srcslot&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L898">&#x200c;</a></span><span class="linkable">slot_modify_data</span>(TupleTableSlot *slot, TupleTableSlot *srcslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepRelMapEntry *rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepTupleData *tupleData)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = slot-&gt;tts_tupleDescriptor-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We'll fill &quot;slot&quot; with a virtual tuple, so we must start with ... */<br/></li>
<li></span>&nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy all the column data from srcslot, so that we'll have valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for unreplaced columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(natts == srcslot-&gt;tts_tupleDescriptor-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; slot_getallattrs(srcslot);<br/></li>
<li>&nbsp; &nbsp; memcpy(slot-&gt;tts_values, srcslot-&gt;tts_values, natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; memcpy(slot-&gt;tts_isnull, srcslot-&gt;tts_isnull, natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Call the &quot;in&quot; function for each replaced attribute */<br/></li>
<li></span>&nbsp; &nbsp; Assert(natts == rel-&gt;attrmap-&gt;maplen);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(slot-&gt;tts_tupleDescriptor, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteattnum = rel-&gt;attrmap-&gt;attnums[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remoteattnum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(remoteattnum &lt; tupleData-&gt;ncols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupleData-&gt;colstatus[remoteattnum] != LOGICALREP_COLUMN_UNCHANGED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; colvalue = &amp;tupleData-&gt;colvalues[remoteattnum];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set attnum for error callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.remote_attnum = remoteattnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupleData-&gt;colstatus[remoteattnum] == LOGICALREP_COLUMN_TEXT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typinput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(att-&gt;atttypid, &amp;typinput, &amp;typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1754" title="utils/fmgr/fmgr.c:1754">OidInputFunctionCall</a>(typinput, colvalue-&gt;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typioparam, att-&gt;atttypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tupleData-&gt;colstatus[remoteattnum] == LOGICALREP_COLUMN_BINARY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typreceive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In some code paths we may be asked to re-<a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple data.&nbsp; Reset the StringInfo's cursor so that works.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colvalue-&gt;cursor = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2940" title="utils/cache/lsyscache.c:2940">getTypeBinaryInputInfo</a>(att-&gt;atttypid, &amp;typreceive, &amp;typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1772" title="utils/fmgr/fmgr.c:1772">OidReceiveFunctionCall</a>(typreceive, colvalue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typioparam, att-&gt;atttypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Trouble if it didn't eat the whole buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colvalue-&gt;cursor != colvalue-&gt;len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incorrect binary data format in logical replication column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteattnum + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be LOGICALREP_COLUMN_NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_values[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;tts_isnull[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset attnum for error callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.remote_attnum = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And finally, declare that &quot;slot&quot; contains a valid virtual tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle BEGIN message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L991">&#x200c;</a></span><span class="linkable">apply_handle_begin</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepBeginData begin_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There must not be an active streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!TransactionIdIsValid(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L74" title="replication/logical/proto.c:74">logicalrep_read_begin</a>(s, &amp;begin_data);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(begin_data.xid, begin_data.final_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a> = begin_data.final_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4763" title="replication/logical/worker.c:4763">maybe_start_skipping_changes</a>(begin_data.final_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle COMMIT message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">, support tracking of multiple origins<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1016">&#x200c;</a></span><span class="linkable">apply_handle_commit</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepCommitData commit_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L109" title="replication/logical/proto.c:109">logicalrep_read_commit</a>(s, &amp;commit_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (commit_data.commit_lsn != <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;incorrect commit LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> in commit message (expected </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(commit_data.commit_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2241" title="replication/logical/worker.c:2241">apply_handle_commit_internal</a>(&amp;commit_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables that are being synchronized in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tablesync.c.html#L667" title="replication/logical/tablesync.c:667">process_syncing_tables</a>(commit_data.end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle BEGIN PREPARE message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1042">&#x200c;</a></span><span class="linkable">apply_handle_begin_prepare</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepPreparedTxnData begin_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tablesync should never receive prepare. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (am_tablesync_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;tablesync worker received a BEGIN PREPARE message&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There must not be an active streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!TransactionIdIsValid(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L145" title="replication/logical/proto.c:145">logicalrep_read_begin_prepare</a>(s, &amp;begin_data);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(begin_data.xid, begin_data.prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a> = begin_data.prepare_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4763" title="replication/logical/worker.c:4763">maybe_start_skipping_changes</a>(begin_data.prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common function to prepare the GID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1071">&#x200c;</a></span><span class="linkable">apply_handle_prepare_internal</span>(LogicalRepPreparedTxnData *prepare_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; gid[GIDSIZE];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute unique GID for two_phase transactions. We don't use GID of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared transaction sent by server as that can lead to deadlock when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have multiple subscriptions from same node point to publications on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same node. See comments atop worker.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4405" title="replication/logical/worker.c:4405">TwoPhaseTransactionGid</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, prepare_data-&gt;xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(gid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L3873" title="access/transam/xact.c:3873">BeginTransactionBlock</a> is necessary to balance the <a href="../../access/transam/xact.c.html#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called within the <a href="../../access/transam/xact.c.html#L3941" title="access/transam/xact.c:3941">PrepareTransactionBlock</a> below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3873" title="access/transam/xact.c:3873">BeginTransactionBlock</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>(); <span class="Comment">/* Completes the preceding Begin command. */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update origin state so we can restart streaming from correct position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case of crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = prepare_data-&gt;end_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = prepare_data-&gt;prepare_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3941" title="access/transam/xact.c:3941">PrepareTransactionBlock</a>(gid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle PREPARE message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1108">&#x200c;</a></span><span class="linkable">apply_handle_prepare</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepPreparedTxnData prepare_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L239" title="replication/logical/proto.c:239">logicalrep_read_prepare</a>(s, &amp;prepare_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prepare_data.prepare_lsn != <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;incorrect prepare LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> in prepare message (expected </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(prepare_data.prepare_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike commit, here, we always prepare the transaction even though no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change has happened in this transaction or all changes are skipped. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is done this way because at commit prepared time, we won't know whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have skipped preparing a transaction because of those reasons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">, We can <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> such that at commit prepared time, we first check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether we have prepared the transaction or not but that doesn't seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worthwhile because such cases shouldn't be common.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1071" title="replication/logical/worker.c:1071">apply_handle_prepare_internal</a>(&amp;prepare_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3436" title="replication/logical/worker.c:3436">store_flush_position</a>(prepare_data.end_lsn, <a href="../../access/transam/xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables that are being synchronized in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tablesync.c.html#L667" title="replication/logical/tablesync.c:667">process_syncing_tables</a>(prepare_data.end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we have already prepared the transaction, in a case where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server crashes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> clearing the subskiplsn, it will be left but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction won't be resent. But that's okay because it's a rare case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the subskiplsn will be cleared when finishing the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4790" title="replication/logical/worker.c:4790">stop_skipping_changes</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L4812" title="replication/logical/worker.c:4812">clear_subscription_skip_lsn</a>(prepare_data.prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle a COMMIT PREPARED of a previously PREPARED transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't need to wait here if the transaction was prepared in a<br/></li>
<li></span><span class="Comment"> * parallel apply worker. In that case, we have already waited for the prepare<br/></li>
<li></span><span class="Comment"> * to finish in <a href="#L1271" title="replication/logical/worker.c:1271">apply_handle_stream_prepare</a>() which will ensure all the<br/></li>
<li></span><span class="Comment"> * operations in that transaction have happened in the subscriber, so no<br/></li>
<li></span><span class="Comment"> * concurrent transaction can cause deadlock or transaction dependency issues.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1169">&#x200c;</a></span><span class="linkable">apply_handle_commit_prepared</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepCommitPreparedTxnData prepare_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; gid[GIDSIZE];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L278" title="replication/logical/proto.c:278">logicalrep_read_commit_prepared</a>(s, &amp;prepare_data);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(prepare_data.xid, prepare_data.commit_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute GID for two_phase transactions. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4405" title="replication/logical/worker.c:4405">TwoPhaseTransactionGid</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, prepare_data.xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(gid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There is no transaction when COMMIT PREPARED is called */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update origin state so we can restart streaming from correct position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case of crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = prepare_data.end_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = prepare_data.commit_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/twophase.c.html#L1503" title="access/transam/twophase.c:1503">FinishPreparedTransaction</a>(gid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3436" title="replication/logical/worker.c:3436">store_flush_position</a>(prepare_data.end_lsn, <a href="../../access/transam/xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables that are being synchronized in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tablesync.c.html#L667" title="replication/logical/tablesync.c:667">process_syncing_tables</a>(prepare_data.end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4812" title="replication/logical/worker.c:4812">clear_subscription_skip_lsn</a>(prepare_data.end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle a ROLLBACK PREPARED of a previously PREPARED TRANSACTION.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't need to wait here if the transaction was prepared in a<br/></li>
<li></span><span class="Comment"> * parallel apply worker. In that case, we have already waited for the prepare<br/></li>
<li></span><span class="Comment"> * to finish in <a href="#L1271" title="replication/logical/worker.c:1271">apply_handle_stream_prepare</a>() which will ensure all the<br/></li>
<li></span><span class="Comment"> * operations in that transaction have happened in the subscriber, so no<br/></li>
<li></span><span class="Comment"> * concurrent transaction can cause deadlock or transaction dependency issues.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1218">&#x200c;</a></span><span class="linkable">apply_handle_rollback_prepared</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRollbackPreparedTxnData rollback_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; gid[GIDSIZE];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L336" title="replication/logical/proto.c:336">logicalrep_read_rollback_prepared</a>(s, &amp;rollback_data);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(rollback_data.xid, rollback_data.rollback_end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute GID for two_phase transactions. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4405" title="replication/logical/worker.c:4405">TwoPhaseTransactionGid</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, rollback_data.xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(gid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is possible that we haven't received prepare because it occurred<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> walsender reached a consistent point or the two_phase was still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not enabled by that time, so in such cases, we need to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> rollback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/twophase.c.html#L2634" title="access/transam/twophase.c:2634">LookupGXact</a>(gid, rollback_data.prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rollback_data.prepare_time))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update origin state so we can restart streaming from correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * position in case of crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = rollback_data.rollback_end_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = rollback_data.rollback_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There is no transaction when ABORT/ROLLBACK PREPARED is called */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/twophase.c.html#L1503" title="access/transam/twophase.c:1503">FinishPreparedTransaction</a>(gid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4812" title="replication/logical/worker.c:4812">clear_subscription_skip_lsn</a>(rollback_data.rollback_end_lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3436" title="replication/logical/worker.c:3436">store_flush_position</a>(rollback_data.rollback_end_lsn, <a href="../../access/transam/xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables that are being synchronized in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tablesync.c.html#L667" title="replication/logical/tablesync.c:667">process_syncing_tables</a>(rollback_data.rollback_end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle STREAM PREPARE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1271">&#x200c;</a></span><span class="linkable">apply_handle_stream_prepare</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepPreparedTxnData prepare_data;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> apply_action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the message <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is consumed. */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData original_msg = *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;STREAM PREPARE message without STREAM STOP&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tablesync should never receive prepare. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (am_tablesync_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;tablesync worker received a STREAM PREPARE message&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L376" title="replication/logical/proto.c:376">logicalrep_read_stream_prepare</a>(s, &amp;prepare_data);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(prepare_data.xid, prepare_data.prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; apply_action = <a href="#L5050" title="replication/logical/worker.c:5050">get_transaction_apply_action</a>(prepare_data.xid, &amp;winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (apply_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_APPLY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The transaction has been serialized to file, so replay all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spooled operations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2001" title="replication/logical/worker.c:2001">apply_spooled_messages</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prepare_data.xid, prepare_data.prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the transaction as prepared. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1071" title="replication/logical/worker.c:1071">apply_handle_prepare_internal</a>(&amp;prepare_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3436" title="replication/logical/worker.c:3436">store_flush_position</a>(prepare_data.end_lsn, <a href="../../access/transam/xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unlink the files with serialized changes and subxact info. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4205" title="replication/logical/worker.c:4205">stream_cleanup_files</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, prepare_data.xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;finished processing the STREAM PREPARE command&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SEND_TO_PARALLEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="applyparallelworker.c.html#L1146" title="replication/logical/applyparallelworker.c:1146">pa_send_data</a>(winfo, s-&gt;len, s-&gt;data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish processing the streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1618" title="replication/logical/applyparallelworker.c:1618">pa_xact_finish</a>(winfo, prepare_data.end_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to serialize mode when we are not able to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change to parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1211" title="replication/logical/applyparallelworker.c:1211">pa_switch_to_partial_serialize</a>(winfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_PARTIAL_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4322" title="replication/logical/worker.c:4322">stream_open_and_write_change</a>(prepare_data.xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOGICAL_REP_MSG_STREAM_PREPARE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;original_msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1498" title="replication/logical/applyparallelworker.c:1498">pa_set_fileset_state</a>(winfo-&gt;shared, FS_SERIALIZE_DONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish processing the streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1618" title="replication/logical/applyparallelworker.c:1618">pa_xact_finish</a>(winfo, prepare_data.end_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_PARALLEL_APPLY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parallel apply worker is applying spooled messages then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * close the file <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> preparing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4274" title="replication/logical/worker.c:4274">stream_close_file</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the transaction as prepared. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1071" title="replication/logical/worker.c:1071">apply_handle_prepare_internal</a>(&amp;prepare_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;last_commit_end = <a href="../../access/transam/xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1307" title="replication/logical/applyparallelworker.c:1307">pa_set_xact_state</a>(<a href="applyparallelworker.c.html#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>, PARALLEL_TRANS_FINISHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1580" title="replication/logical/applyparallelworker.c:1580">pa_unlock_transaction</a>(<a href="applyparallelworker.c.html#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;xid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1402" title="replication/logical/applyparallelworker.c:1402">pa_reset_subtrans</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;finished processing the STREAM PREPARE command&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected apply action: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) apply_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables that are being synchronized in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tablesync.c.html#L667" title="replication/logical/tablesync.c:667">process_syncing_tables</a>(prepare_data.end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similar to prepare case, the subskiplsn could be left in a case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server crash but it's okay. See the comments in <a href="#L1108" title="replication/logical/worker.c:1108">apply_handle_prepare</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4790" title="replication/logical/worker.c:4790">stop_skipping_changes</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L4812" title="replication/logical/worker.c:4812">clear_subscription_skip_lsn</a>(prepare_data.prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle ORIGIN message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">, support tracking of multiple origins<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1408">&#x200c;</a></span><span class="linkable">apply_handle_origin</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ORIGIN message can only come inside streaming transaction or inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remote transaction and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> actual writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!<a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>() &amp;&amp; !am_tablesync_worker())))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;ORIGIN message sent out of order&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize fileset (if not already done).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create a new file when first_segment is true, otherwise open the existing<br/></li>
<li></span><span class="Comment"> * file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1429">&#x200c;</a></span><span class="linkable">stream_start_internal</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> first_segment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the worker's stream_fileset if we haven't yet. This will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used for the entire duration of the worker so create it in a permanent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context. We create this on the very first streaming message from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction and then use it for this and other streaming transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, we could create a fileset at the start of the worker as well but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we won't be sure that it will ever be used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FileSet));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fileset.c.html#L52" title="storage/file/fileset.c:52">FileSetInit</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the spool file for this transaction. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4229" title="replication/logical/worker.c:4229">stream_open_file</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid, first_segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this is not the first segment, open existing subxact file. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!first_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4055" title="replication/logical/worker.c:4055">subxact_info_read</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle STREAM START message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1467">&#x200c;</a></span><span class="linkable">apply_handle_stream_start</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first_segment;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> apply_action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the message <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is consumed. */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData original_msg = *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;duplicate STREAM START message&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There must not be an active streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!TransactionIdIsValid(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* notify handle methods we're processing a remote transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* extract XID of the top-level transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L309" title="replication/logical/worker.c:309">stream_xid</a> = <a href="proto.c.html#L1087" title="replication/logical/proto.c:1087">logicalrep_read_stream_start</a>(s, &amp;first_segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;invalid transaction ID in streamed replication transaction&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>, InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to allocate a worker for the streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (first_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L470" title="replication/logical/applyparallelworker.c:470">pa_allocate_worker</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; apply_action = <a href="#L5050" title="replication/logical/worker.c:5050">get_transaction_apply_action</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>, &amp;winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (apply_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SERIALIZE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Function <a href="#L1429" title="replication/logical/worker.c:1429">stream_start_internal</a> starts a transaction. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction will be committed on the stream stop unless it is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tablesync worker in which case it will be committed after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing all the messages. We need this transaction for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handling the <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>, used for serializing the streaming data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and subxact info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1429" title="replication/logical/worker.c:1429">stream_start_internal</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>, first_segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SEND_TO_PARALLEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we start serializing the changes, the parallel apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker will wait for the leader to release the stream lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until the end of the transaction. So, we don't need to release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lock or increment the stream count in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="applyparallelworker.c.html#L1146" title="replication/logical/applyparallelworker.c:1146">pa_send_data</a>(winfo, s-&gt;len, s-&gt;data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unlock the shared object lock so that the parallel apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker can continue to receive changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!first_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1547" title="replication/logical/applyparallelworker.c:1547">pa_unlock_stream</a>(winfo-&gt;shared-&gt;xid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Increment the number of streaming blocks <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed by parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_add_fetch_u32(&amp;winfo-&gt;shared-&gt;pending_stream_count, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cache the parallel apply worker for this transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1334" title="replication/logical/applyparallelworker.c:1334">pa_set_stream_apply_worker</a>(winfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to serialize mode when we are not able to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change to parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1211" title="replication/logical/applyparallelworker.c:1211">pa_switch_to_partial_serialize</a>(winfo, !first_segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_PARTIAL_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Open the spool file unless it was already opened when switching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to serialize mode. The transaction started in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1429" title="replication/logical/worker.c:1429">stream_start_internal</a> will be committed on the stream stop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (apply_action != TRANS_LEADER_SEND_TO_PARALLEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1429" title="replication/logical/worker.c:1429">stream_start_internal</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>, first_segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a>(LOGICAL_REP_MSG_STREAM_START, &amp;original_msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cache the parallel apply worker for this transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1334" title="replication/logical/applyparallelworker.c:1334">pa_set_stream_apply_worker</a>(winfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_PARALLEL_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hold the lock until the end of the transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1573" title="replication/logical/applyparallelworker.c:1573">pa_lock_transaction</a>(<a href="applyparallelworker.c.html#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;xid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1307" title="replication/logical/applyparallelworker.c:1307">pa_set_xact_state</a>(<a href="applyparallelworker.c.html#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>, PARALLEL_TRANS_STARTED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Signal the leader apply worker, as it may be <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L676" title="replication/logical/launcher.c:676">logicalrep_worker_wakeup</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L315" title="replication/logical/worker.c:315">parallel_stream_nchanges</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected apply action: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) apply_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the information about subxacts and close the file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should be called when the <a href="#L1429" title="replication/logical/worker.c:1429">stream_start_internal</a> function has<br/></li>
<li></span><span class="Comment"> * been called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1603">&#x200c;</a></span><span class="linkable">stream_stop_internal</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Serialize information about subxacts for the toplevel transaction, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close the stream messages spool file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4006" title="replication/logical/worker.c:4006">subxact_info_write</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4274" title="replication/logical/worker.c:4274">stream_close_file</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must be in a valid transaction state */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Commit the per-stream transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset per-stream context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L294" title="replication/logical/worker.c:294">LogicalStreamingContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle STREAM STOP message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1626">&#x200c;</a></span><span class="linkable">apply_handle_stream_stop</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> apply_action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;STREAM STOP message without STREAM START&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; apply_action = <a href="#L5050" title="replication/logical/worker.c:5050">get_transaction_apply_action</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>, &amp;winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (apply_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1603" title="replication/logical/worker.c:1603">stream_stop_internal</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SEND_TO_PARALLEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending the STREAM_STOP message so that the leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can hold the lock first and the parallel apply worker will wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for leader to release the lock. See Locking Considerations atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applyparallelworker.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1540" title="replication/logical/applyparallelworker.c:1540">pa_lock_stream</a>(winfo-&gt;shared-&gt;xid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="applyparallelworker.c.html#L1146" title="replication/logical/applyparallelworker.c:1146">pa_send_data</a>(winfo, s-&gt;len, s-&gt;data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1334" title="replication/logical/applyparallelworker.c:1334">pa_set_stream_apply_worker</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to serialize mode when we are not able to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change to parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1211" title="replication/logical/applyparallelworker.c:1211">pa_switch_to_partial_serialize</a>(winfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_PARTIAL_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a>(LOGICAL_REP_MSG_STREAM_STOP, s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1603" title="replication/logical/worker.c:1603">stream_stop_internal</a>(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1334" title="replication/logical/applyparallelworker.c:1334">pa_set_stream_apply_worker</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_PARALLEL_APPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;applied </span><span class="Special">%u</span><span class="Constant"> changes in the streaming chunk&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L315" title="replication/logical/worker.c:315">parallel_stream_nchanges</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By the time parallel apply worker is processing the changes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current streaming block, the leader apply worker may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sent multiple streaming blocks. This can lead to parallel apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker start <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> even when there are more chunk of streams<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the queue. So, try to lock only if there is no message left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the queue. See Locking Considerations atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applyparallelworker.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that here we have a race condition where we can start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> even when there are pending streaming chunks. This can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen if the leader sends another streaming block and acquires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the stream lock again after the parallel apply worker checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that there is no pending streaming block and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starts <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on a lock. We can handle this case by not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allowing the leader to increment the stream block count during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the time parallel apply worker acquires the lock but it is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clear whether that is worth the complexity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now, if this missed chunk contains rollback to savepoint, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is a risk of deadlock which probably shouldn't happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1591" title="replication/logical/applyparallelworker.c:1591">pa_decr_and_wait_stream_block</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected apply action: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) apply_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L309" title="replication/logical/worker.c:309">stream_xid</a> = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parallel apply worker could be in a transaction in which case we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to report the state as STATE_IDLEINTRANSACTION.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLEINTRANSACTION, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function to handle STREAM ABORT message when the transaction was<br/></li>
<li></span><span class="Comment"> * serialized to file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1729">&#x200c;</a></span><span class="linkable">stream_abort_internal</span>(TransactionId xid, TransactionId subxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the two XIDs are the same, it's in fact abort of toplevel xact, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just delete the files with serialized info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xid == subxid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4205" title="replication/logical/worker.c:4205">stream_cleanup_files</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, so it's a subxact. We need to read the subxact file for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * toplevel transaction, determine the offset tracked for the subxact,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and truncate the file with changes. We also remove the subxacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with higher offsets (or rather higher XIDs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We intentionally scan the array from the tail, because we're likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aborting a change for the most recent subtransactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't use the binary search here as subxact XIDs won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessarily arrive in sorted order, consider the case where we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * released the savepoint for multiple subtransactions and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performed rollback to savepoint for one of the earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sub-transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; subidx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subidx = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4055" title="replication/logical/worker.c:4055">subxact_info_read</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts[i - <span class="Constant">1</span>].xid == subxid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subidx = (i - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's an empty sub-transaction then we will not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the subxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here so just <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> the subxact info and return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cleanup the subxact info */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4388" title="replication/logical/worker.c:4388">cleanup_subxact_info</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* open the changes file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4191" title="replication/logical/worker.c:4191">changes_filename</a>(path, <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; O_RDWR, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, truncate the file at the right offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L933" title="storage/file/buffile.c:933">BufFileTruncateFileSet</a>(fd, <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts[subidx].fileno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts[subidx].offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* discard the subxacts added later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts = subidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the updated subxact list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4006" title="replication/logical/worker.c:4006">subxact_info_write</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle STREAM ABORT message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1812">&#x200c;</a></span><span class="linkable">apply_handle_stream_abort</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; TransactionId subxid;<br/></li>
<li>&nbsp; &nbsp; LogicalRepStreamAbortData abort_data;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> apply_action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the message <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is consumed. */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData original_msg = *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toplevel_xact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;STREAM ABORT message without STREAM STOP&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We receive abort information only when we can apply in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="proto.c.html#L1192" title="replication/logical/proto.c:1192">logicalrep_read_stream_abort</a>(s, &amp;abort_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;parallel_apply);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid = abort_data.xid;<br/></li>
<li>&nbsp; &nbsp; subxid = abort_data.subxid;<br/></li>
<li>&nbsp; &nbsp; toplevel_xact = (xid == subxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(subxid, abort_data.abort_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; apply_action = <a href="#L5050" title="replication/logical/worker.c:5050">get_transaction_apply_action</a>(xid, &amp;winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (apply_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_APPLY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in the leader apply worker and the transaction has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * serialized to file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1729" title="replication/logical/worker.c:1729">stream_abort_internal</a>(xid, subxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;finished processing the STREAM ABORT command&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SEND_TO_PARALLEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the case of aborting the subtransaction, we increment the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of streaming blocks and take the lock again <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sending the STREAM_ABORT to ensure that the parallel apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker will wait on the lock for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set of changes after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing the STREAM_ABORT message if it is not already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for STREAM_STOP message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is important to perform this locking <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * STREAM_ABORT message so that the leader can hold the lock first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and the parallel apply worker will wait for the leader to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the lock. This is the same as what we do in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1626" title="replication/logical/worker.c:1626">apply_handle_stream_stop</a>. See Locking Considerations atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applyparallelworker.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!toplevel_xact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1547" title="replication/logical/applyparallelworker.c:1547">pa_unlock_stream</a>(xid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_add_fetch_u32(&amp;winfo-&gt;shared-&gt;pending_stream_count, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1540" title="replication/logical/applyparallelworker.c:1540">pa_lock_stream</a>(xid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="applyparallelworker.c.html#L1146" title="replication/logical/applyparallelworker.c:1146">pa_send_data</a>(winfo, s-&gt;len, s-&gt;data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unlike STREAM_COMMIT and STREAM_PREPARE, we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wait here for the parallel apply worker to finish as that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not required to maintain the commit order and won't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the risk of failures due to transaction dependencies and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlocks. However, it is possible that <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker finishes and we clear the worker info, the xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wraparound happens on the upstream and a new transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the same xid can appear and that can lead to duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries in <a href="applyparallelworker.c.html#L225" title="replication/logical/applyparallelworker.c:225">ParallelApplyTxnHash</a>. Yet another problem could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be that we may have serialized the changes in partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * serialize mode and the file containing xact changes may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already exist, and after xid wraparound trying to create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the file for the same xid can lead to an error. To avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these problems, we decide to wait for the aborts to finish.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note, it is okay to not update the flush location position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for aborts as in worst case that means such a transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't be sent again after restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toplevel_xact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1618" title="replication/logical/applyparallelworker.c:1618">pa_xact_finish</a>(winfo, InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to serialize mode when we are not able to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change to parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1211" title="replication/logical/applyparallelworker.c:1211">pa_switch_to_partial_serialize</a>(winfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_PARTIAL_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parallel apply worker might have applied some changes, so write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the STREAM_ABORT message so that it can rollback the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4322" title="replication/logical/worker.c:4322">stream_open_and_write_change</a>(xid, LOGICAL_REP_MSG_STREAM_ABORT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;original_msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toplevel_xact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1498" title="replication/logical/applyparallelworker.c:1498">pa_set_fileset_state</a>(winfo-&gt;shared, FS_SERIALIZE_DONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1618" title="replication/logical/applyparallelworker.c:1618">pa_xact_finish</a>(winfo, InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_PARALLEL_APPLY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parallel apply worker is applying spooled messages then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * close the file <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> aborting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toplevel_xact &amp;&amp; <a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4274" title="replication/logical/worker.c:4274">stream_close_file</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1416" title="replication/logical/applyparallelworker.c:1416">pa_stream_abort</a>(&amp;abort_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to wait after processing rollback to savepoint for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set of changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have a race condition here due to which we can start <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here when there are more chunk of streams in the queue. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1626" title="replication/logical/worker.c:1626">apply_handle_stream_stop</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!toplevel_xact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1591" title="replication/logical/applyparallelworker.c:1591">pa_decr_and_wait_stream_block</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;finished processing the STREAM ABORT command&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected apply action: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) apply_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that the passed location is fileset's end.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1969">&#x200c;</a></span><span class="linkable">ensure_last_message</span>(FileSet *stream_fileset, TransactionId xid, <span class="Type">int</span> fileno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">off_t</span> offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_fileno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; last_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4191" title="replication/logical/worker.c:4191">changes_filename</a>(path, <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(stream_fileset, path, O_RDONLY, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(fd, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">SEEK_END</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(fd, &amp;last_fileno, &amp;last_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (last_fileno != fileno || last_offset != offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected message left in streaming transaction's changes file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common spoolfile processing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2001">&#x200c;</a></span><span class="linkable">apply_spooled_messages</span>(FileSet *stream_fileset, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchanges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner oldowner;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fileno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!am_parallel_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4763" title="replication/logical/worker.c:4763">maybe_start_skipping_changes</a>(lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have an open transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate file handle and memory required to process all the messages in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> to avoid them getting reset after each message is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the spool file for the committed/prepared transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4191" title="replication/logical/worker.c:4191">changes_filename</a>(path, <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;replaying changes from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the file is owned by the toplevel transaction so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file will not be accidentally closed when aborting a subtransaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> = <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(stream_fileset, path, O_RDONLY, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = oldowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L304" title="replication/logical/worker.c:304">remote_final_lsn</a> = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the handle <a href="#L3272" title="replication/logical/worker.c:3272">apply_dispatch</a> methods are aware we're in a remote<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the entries one by one and pass them through the same logic as in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3272" title="replication/logical/worker.c:3272">apply_dispatch</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nchanges = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData s2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read length of the on-disk record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="../../storage/file/buffile.c.html#L664" title="storage/file/buffile.c:664">BufFileReadMaybeEOF</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>, &amp;len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have we reached end of the file? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do we have a correct length? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incorrect length </span><span class="Special">%d</span><span class="Constant"> in streaming transaction's changes file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we have sufficiently large buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(buffer, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and finally read the data into the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>, buffer, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>, &amp;fileno, &amp;offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* init a stringinfo using the buffer and call <a href="#L3272" title="replication/logical/worker.c:3272">apply_dispatch</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;s2, buffer, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure we are reading the data into our memory context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3272" title="replication/logical/worker.c:3272">apply_dispatch</a>(&amp;s2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nchanges++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible the file has been closed because we have processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the transaction end message like stream_commit in which case that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be the last message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1969" title="replication/logical/worker.c:1969">ensure_last_message</a>(stream_fileset, xid, fileno, offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nchanges % <span class="Constant">1000</span> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;replayed </span><span class="Special">%d</span><span class="Constant"> changes from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nchanges, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4274" title="replication/logical/worker.c:4274">stream_close_file</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;replayed </span><span class="Special">%d</span><span class="Constant"> (all) changes from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nchanges, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle STREAM COMMIT message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2131">&#x200c;</a></span><span class="linkable">apply_handle_stream_commit</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; LogicalRepCommitData commit_data;<br/></li>
<li>&nbsp; &nbsp; ParallelApplyWorkerInfo *winfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> apply_action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the message <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is consumed. */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData original_msg = *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;STREAM COMMIT message without STREAM STOP&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid = <a href="proto.c.html#L1137" title="replication/logical/proto.c:1137">logicalrep_read_stream_commit</a>(s, &amp;commit_data);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(xid, commit_data.commit_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; apply_action = <a href="#L5050" title="replication/logical/worker.c:5050">get_transaction_apply_action</a>(xid, &amp;winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (apply_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_APPLY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The transaction has been serialized to file, so replay all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spooled operations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2001" title="replication/logical/worker.c:2001">apply_spooled_messages</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; commit_data.commit_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2241" title="replication/logical/worker.c:2241">apply_handle_commit_internal</a>(&amp;commit_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unlink the files with serialized changes and subxact info. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4205" title="replication/logical/worker.c:4205">stream_cleanup_files</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;finished processing the STREAM COMMIT command&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_SEND_TO_PARALLEL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="applyparallelworker.c.html#L1146" title="replication/logical/applyparallelworker.c:1146">pa_send_data</a>(winfo, s-&gt;len, s-&gt;data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish processing the streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1618" title="replication/logical/applyparallelworker.c:1618">pa_xact_finish</a>(winfo, commit_data.end_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to serialize mode when we are not able to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change to parallel apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1211" title="replication/logical/applyparallelworker.c:1211">pa_switch_to_partial_serialize</a>(winfo, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_LEADER_PARTIAL_SERIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(winfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4322" title="replication/logical/worker.c:4322">stream_open_and_write_change</a>(xid, LOGICAL_REP_MSG_STREAM_COMMIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;original_msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1498" title="replication/logical/applyparallelworker.c:1498">pa_set_fileset_state</a>(winfo-&gt;shared, FS_SERIALIZE_DONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish processing the streaming transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1618" title="replication/logical/applyparallelworker.c:1618">pa_xact_finish</a>(winfo, commit_data.end_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_PARALLEL_APPLY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parallel apply worker is applying spooled messages then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * close the file <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> committing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4274" title="replication/logical/worker.c:4274">stream_close_file</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2241" title="replication/logical/worker.c:2241">apply_handle_commit_internal</a>(&amp;commit_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>-&gt;last_commit_end = <a href="../../access/transam/xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is important to set the transaction state as finished <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * releasing the lock. See <a href="applyparallelworker.c.html#L1274" title="replication/logical/applyparallelworker.c:1274">pa_wait_for_xact_finish</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1307" title="replication/logical/applyparallelworker.c:1307">pa_set_xact_state</a>(<a href="applyparallelworker.c.html#L239" title="replication/logical/applyparallelworker.c:239">MyParallelShared</a>, PARALLEL_TRANS_FINISHED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1580" title="replication/logical/applyparallelworker.c:1580">pa_unlock_transaction</a>(xid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="applyparallelworker.c.html#L1402" title="replication/logical/applyparallelworker.c:1402">pa_reset_subtrans</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;finished processing the STREAM COMMIT command&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected apply action: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) apply_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tables that are being synchronized in parallel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="tablesync.c.html#L667" title="replication/logical/tablesync.c:667">process_syncing_tables</a>(commit_data.end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4973" title="replication/logical/worker.c:4973">reset_apply_error_context_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L1016" title="replication/logical/worker.c:1016">apply_handle_commit</a> and <a href="#L2131" title="replication/logical/worker.c:2131">apply_handle_stream_commit</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2241">&#x200c;</a></span><span class="linkable">apply_handle_commit_internal</span>(LogicalRepCommitData *commit_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L336" title="replication/logical/worker.c:336">is_skipping_changes</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4790" title="replication/logical/worker.c:4790">stop_skipping_changes</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start a new transaction to clear the subskiplsn, if not started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The transaction is either non-empty or skipped, so we clear the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subskiplsn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4812" title="replication/logical/worker.c:4812">clear_subscription_skip_lsn</a>(commit_data-&gt;commit_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update origin state so we can restart streaming from correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * position in case of crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a> = commit_data-&gt;end_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = commit_data-&gt;committime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3436" title="replication/logical/worker.c:3436">store_flush_position</a>(commit_data-&gt;end_lsn, <a href="../../access/transam/xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalidation messages that might have accumulated. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3862" title="replication/logical/worker.c:3862">maybe_reread_subscription</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle RELATION message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we don't do validation against local schema here. The validation<br/></li>
<li></span><span class="Comment"> * against local schema is postponed until first change for given relation<br/></li>
<li></span><span class="Comment"> * comes as we only care about it when applying changes for it anyway and we<br/></li>
<li></span><span class="Comment"> * do less locking this way.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2301">&#x200c;</a></span><span class="linkable">apply_handle_relation</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelation *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L559" title="replication/logical/worker.c:559">handle_streamed_transaction</a>(LOGICAL_REP_MSG_RELATION, s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="proto.c.html#L700" title="replication/logical/proto.c:700">logicalrep_read_rel</a>(s);<br/></li>
<li>&nbsp; &nbsp; <a href="relation.c.html#L164" title="replication/logical/relation.c:164">logicalrep_relmap_update</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also reset all entries in the partition map that refer to remoterel. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="relation.c.html#L540" title="replication/logical/relation.c:540">logicalrep_partmap_reset_relmap</a>(rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle TYPE message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This implementation pays no attention to TYPE messages; we expect the user<br/></li>
<li></span><span class="Comment"> * to have set things up so that the incoming data is acceptable to the input<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for the locally subscribed tables.&nbsp; Hence, we just read and<br/></li>
<li></span><span class="Comment"> * discard the message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2324">&#x200c;</a></span><span class="linkable">apply_handle_type</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepTyp typ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L559" title="replication/logical/worker.c:559">handle_streamed_transaction</a>(LOGICAL_REP_MSG_TYPE, s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="proto.c.html#L756" title="replication/logical/proto.c:756">logicalrep_read_typ</a>(s, &amp;typ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that we (the subscription owner) have sufficient privileges on the<br/></li>
<li></span><span class="Comment"> * target relation to perform the given operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2339">&#x200c;</a></span><span class="linkable">TargetPrivilegesCheck</span>(Relation rel, AclMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; aclresult = <a href="../../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(relid, <a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), mode);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(rel-&gt;rd_rel-&gt;relkind),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(relid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We lack the infrastructure to honor RLS policies.&nbsp; It might be possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to add such infrastructure here, but tablesync workers lack it, too, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't bother.&nbsp; RLS does not ordinarily apply to TRUNCATE commands,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it seems dangerous to replicate a TRUNCATE and then refuse to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replicate subsequent INSERTs, so we forbid all commands the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/rls.c.html#L52" title="utils/misc/rls.c:52">check_enable_rls</a>(relid, InvalidOid, <span class="Constant">false</span>) == RLS_ENABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;user </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot replicate into relation with row-level security enabled: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L980" title="utils/init/miscinit.c:980">GetUserNameFromId</a>(<a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), <span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle INSERT message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2371">&#x200c;</a></span><span class="linkable">apply_handle_insert</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *rel;<br/></li>
<li>&nbsp; &nbsp; LogicalRepTupleData newtup;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelId relid;<br/></li>
<li>&nbsp; &nbsp; UserContext ucxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *remoteslot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; run_as_owner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quick return if we are skipping data modification changes or handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streamed transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L336" title="replication/logical/worker.c:336">is_skipping_changes</a>() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L559" title="replication/logical/worker.c:559">handle_streamed_transaction</a>(LOGICAL_REP_MSG_INSERT, s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = <a href="proto.c.html#L436" title="replication/logical/proto.c:436">logicalrep_read_insert</a>(s, &amp;newtup);<br/></li>
<li>&nbsp; &nbsp; rel = <a href="relation.c.html#L327" title="replication/logical/relation.c:327">logicalrep_rel_open</a>(relid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L468" title="replication/logical/worker.c:468">should_apply_changes_for_rel</a>(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The relation can't become interesting in the middle of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction so it's safe to unlock it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-supplied code runs as the table owner, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the user has opted out of that behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_as_owner = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;runasowner;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!run_as_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/usercontext.c.html#L33" title="utils/init/usercontext.c:33">SwitchToUntrustedUser</a>(rel-&gt;localrel-&gt;rd_rel-&gt;relowner, &amp;ucxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set relation for error callback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.rel = rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the executor state. */<br/></li>
<li></span>&nbsp; &nbsp; edata = <a href="#L652" title="replication/logical/worker.c:652">create_edata_for_relation</a>(rel);<br/></li>
<li>&nbsp; &nbsp; estate = edata-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; remoteslot = <a href="../../executor/execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(rel-&gt;localrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process and store remote tuple in the slot */<br/></li>
<li></span>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; <a href="#L797" title="replication/logical/worker.c:797">slot_store_data</a>(remoteslot, rel, &amp;newtup);<br/></li>
<li>&nbsp; &nbsp; <a href="#L740" title="replication/logical/worker.c:740">slot_fill_defaults</a>(rel, estate, remoteslot);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For a partitioned table, insert the tuple into a partition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;localrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2893" title="replication/logical/worker.c:2893">apply_handle_tuple_routing</a>(edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot, <span class="Constant">NULL</span>, CMD_INSERT);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2457" title="replication/logical/worker.c:2457">apply_handle_insert_internal</a>(edata, edata-&gt;targetRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L709" title="replication/logical/worker.c:709">finish_edata</a>(edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset relation for error callback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.rel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!run_as_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/usercontext.c.html#L87" title="utils/init/usercontext.c:87">RestoreUserContext</a>(&amp;ucxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse for <a href="#L2371" title="replication/logical/worker.c:2371">apply_handle_insert</a>()<br/></li>
<li></span><span class="Comment"> * relinfo is for the relation we're actually inserting into<br/></li>
<li></span><span class="Comment"> * (could be a child partition of edata-&gt;targetRelInfo)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2457">&#x200c;</a></span><span class="linkable">apply_handle_insert_internal</span>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResultRelInfo *relinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = edata-&gt;estate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must open indexes here. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>(relinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the insert. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2339" title="replication/logical/worker.c:2339">TargetPrivilegesCheck</a>(relinfo-&gt;ri_RelationDesc, ACL_INSERT);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execReplication.c.html#L490" title="executor/execReplication.c:490">ExecSimpleRelationInsert</a>(relinfo, estate, remoteslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L231" title="executor/execIndexing.c:231">ExecCloseIndices</a>(relinfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the logical replication relation is updatable and throw<br/></li>
<li></span><span class="Comment"> * appropriate error if it isn't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2479">&#x200c;</a></span><span class="linkable">check_relation_updatable</span>(LogicalRepRelMapEntry *rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For partitioned tables, we only need to care if the target partition is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updatable (aka has PK or RI defined for it).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;localrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Updatable, no error. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;updatable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are in error mode so it's fine this is somewhat slow. It's better to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * give user correct error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="relation.c.html#L851" title="replication/logical/relation.c:851">GetRelationIdentityOrPK</a>(rel-&gt;localrel)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;publisher did not <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> replica identity column &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;expected by the logical replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;remoterel.nspname, rel-&gt;remoterel.relname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> has &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;neither REPLICA IDENTITY index nor PRIMARY &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> and published relation does not have &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;REPLICA IDENTITY FULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;remoterel.nspname, rel-&gt;remoterel.relname)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle UPDATE message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: FDW support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2520">&#x200c;</a></span><span class="linkable">apply_handle_update</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *rel;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelId relid;<br/></li>
<li>&nbsp; &nbsp; UserContext ucxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; LogicalRepTupleData oldtup;<br/></li>
<li>&nbsp; &nbsp; LogicalRepTupleData newtup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_oldtup;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *remoteslot;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *target_perminfo;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; run_as_owner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quick return if we are skipping data modification changes or handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streamed transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L336" title="replication/logical/worker.c:336">is_skipping_changes</a>() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L559" title="replication/logical/worker.c:559">handle_streamed_transaction</a>(LOGICAL_REP_MSG_UPDATE, s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = <a href="proto.c.html#L492" title="replication/logical/proto.c:492">logicalrep_read_update</a>(s, &amp;has_oldtup, &amp;oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;newtup);<br/></li>
<li>&nbsp; &nbsp; rel = <a href="relation.c.html#L327" title="replication/logical/relation.c:327">logicalrep_rel_open</a>(relid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L468" title="replication/logical/worker.c:468">should_apply_changes_for_rel</a>(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The relation can't become interesting in the middle of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction so it's safe to unlock it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set relation for error callback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.rel = rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we can do the update. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2479" title="replication/logical/worker.c:2479">check_relation_updatable</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-supplied code runs as the table owner, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the user has opted out of that behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_as_owner = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;runasowner;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!run_as_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/usercontext.c.html#L33" title="utils/init/usercontext.c:33">SwitchToUntrustedUser</a>(rel-&gt;localrel-&gt;rd_rel-&gt;relowner, &amp;ucxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the executor state. */<br/></li>
<li></span>&nbsp; &nbsp; edata = <a href="#L652" title="replication/logical/worker.c:652">create_edata_for_relation</a>(rel);<br/></li>
<li>&nbsp; &nbsp; estate = edata-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; remoteslot = <a href="../../executor/execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(rel-&gt;localrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Populate updatedCols so that per-column triggers can fire, and so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executor can correctly pass down indexUnchanged hint.&nbsp; This could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include more columns than were actually changed on the publisher<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the logical replication protocol doesn't contain that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information.&nbsp; But it would for example exclude columns that only exist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the subscriber, since we are not touching those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; target_perminfo = list_nth(estate-&gt;es_rteperminfos, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; remoteslot-&gt;tts_tupleDescriptor-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(remoteslot-&gt;tts_tupleDescriptor, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteattnum = rel-&gt;attrmap-&gt;attnums[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!att-&gt;attisdropped &amp;&amp; remoteattnum &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(remoteattnum &lt; newtup.ncols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtup.colstatus[remoteattnum] != LOGICALREP_COLUMN_UNCHANGED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_perminfo-&gt;updatedCols =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(target_perminfo-&gt;updatedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i + <span class="Constant">1</span> - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the search tuple. */<br/></li>
<li></span>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; <a href="#L797" title="replication/logical/worker.c:797">slot_store_data</a>(remoteslot, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_oldtup ? &amp;oldtup : &amp;newtup);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For a partitioned table, apply update to correct partition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;localrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2893" title="replication/logical/worker.c:2893">apply_handle_tuple_routing</a>(edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot, &amp;newtup, CMD_UPDATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2637" title="replication/logical/worker.c:2637">apply_handle_update_internal</a>(edata, edata-&gt;targetRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot, &amp;newtup, rel-&gt;localindexoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L709" title="replication/logical/worker.c:709">finish_edata</a>(edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset relation for error callback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.rel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!run_as_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/usercontext.c.html#L87" title="utils/init/usercontext.c:87">RestoreUserContext</a>(&amp;ucxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse for <a href="#L2520" title="replication/logical/worker.c:2520">apply_handle_update</a>()<br/></li>
<li></span><span class="Comment"> * relinfo is for the relation we're actually updating in<br/></li>
<li></span><span class="Comment"> * (could be a child partition of edata-&gt;targetRelInfo)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2637">&#x200c;</a></span><span class="linkable">apply_handle_update_internal</span>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResultRelInfo *relinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepTupleData *newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid localindexoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = edata-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *relmapentry = edata-&gt;targetRel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; localrel = relinfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; EPQState&nbsp; &nbsp; epqstate;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *localslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execMain.c.html#L2539" title="executor/execMain.c:2539">EvalPlanQualInit</a>(&amp;epqstate, estate, <span class="Constant">NULL</span>, NIL, -<span class="Constant">1</span>, NIL);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>(relinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; found = <a href="#L2846" title="replication/logical/worker.c:2846">FindReplTupleInLocalRel</a>(edata, localrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;relmapentry-&gt;remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localindexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot, &amp;localslot);<br/></li>
<li>&nbsp; &nbsp; ExecClearTuple(remoteslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tuple found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note this will fail if there are other conflicting unique indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process and store remote tuple in the slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L898" title="replication/logical/worker.c:898">slot_modify_data</a>(remoteslot, localslot, relmapentry, newtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EvalPlanQualSetSlot(&amp;epqstate, remoteslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the actual update. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="replication/logical/worker.c:2339">TargetPrivilegesCheck</a>(relinfo-&gt;ri_RelationDesc, ACL_UPDATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execReplication.c.html#L554" title="executor/execReplication.c:554">ExecSimpleRelationUpdate</a>(relinfo, estate, &amp;epqstate, localslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple to be updated could not be found.&nbsp; Do nothing except for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitting a log message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should this be promoted to ereport(LOG) perhaps?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication did not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> row to be updated &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;in replication target relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(localrel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L231" title="executor/execIndexing.c:231">ExecCloseIndices</a>(relinfo);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execMain.c.html#L2982" title="executor/execMain.c:2982">EvalPlanQualEnd</a>(&amp;epqstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle DELETE message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: FDW support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2704">&#x200c;</a></span><span class="linkable">apply_handle_delete</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *rel;<br/></li>
<li>&nbsp; &nbsp; LogicalRepTupleData oldtup;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelId relid;<br/></li>
<li>&nbsp; &nbsp; UserContext ucxt;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *remoteslot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; run_as_owner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quick return if we are skipping data modification changes or handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streamed transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L336" title="replication/logical/worker.c:336">is_skipping_changes</a>() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L559" title="replication/logical/worker.c:559">handle_streamed_transaction</a>(LOGICAL_REP_MSG_DELETE, s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = <a href="proto.c.html#L564" title="replication/logical/proto.c:564">logicalrep_read_delete</a>(s, &amp;oldtup);<br/></li>
<li>&nbsp; &nbsp; rel = <a href="relation.c.html#L327" title="replication/logical/relation.c:327">logicalrep_rel_open</a>(relid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L468" title="replication/logical/worker.c:468">should_apply_changes_for_rel</a>(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The relation can't become interesting in the middle of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction so it's safe to unlock it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set relation for error callback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.rel = rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we can do the delete. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2479" title="replication/logical/worker.c:2479">check_relation_updatable</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-supplied code runs as the table owner, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the user has opted out of that behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; run_as_owner = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;runasowner;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!run_as_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/usercontext.c.html#L33" title="utils/init/usercontext.c:33">SwitchToUntrustedUser</a>(rel-&gt;localrel-&gt;rd_rel-&gt;relowner, &amp;ucxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the executor state. */<br/></li>
<li></span>&nbsp; &nbsp; edata = <a href="#L652" title="replication/logical/worker.c:652">create_edata_for_relation</a>(rel);<br/></li>
<li>&nbsp; &nbsp; estate = edata-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; remoteslot = <a href="../../executor/execTuples.c.html#L1918" title="executor/execTuples.c:1918">ExecInitExtraTupleSlot</a>(estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(rel-&gt;localrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the search tuple. */<br/></li>
<li></span>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; <a href="#L797" title="replication/logical/worker.c:797">slot_store_data</a>(remoteslot, rel, &amp;oldtup);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For a partitioned table, apply delete to correct partition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;localrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2893" title="replication/logical/worker.c:2893">apply_handle_tuple_routing</a>(edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot, <span class="Constant">NULL</span>, CMD_DELETE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2792" title="replication/logical/worker.c:2792">apply_handle_delete_internal</a>(edata, edata-&gt;targetRelInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot, rel-&gt;localindexoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L709" title="replication/logical/worker.c:709">finish_edata</a>(edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset relation for error callback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.rel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!run_as_owner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/usercontext.c.html#L87" title="utils/init/usercontext.c:87">RestoreUserContext</a>(&amp;ucxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhorse for <a href="#L2704" title="replication/logical/worker.c:2704">apply_handle_delete</a>()<br/></li>
<li></span><span class="Comment"> * relinfo is for the relation we're actually deleting from<br/></li>
<li></span><span class="Comment"> * (could be a child partition of edata-&gt;targetRelInfo)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2792">&#x200c;</a></span><span class="linkable">apply_handle_delete_internal</span>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ResultRelInfo *relinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid localindexoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = edata-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; localrel = relinfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelation *remoterel = &amp;edata-&gt;targetRel-&gt;remoterel;<br/></li>
<li>&nbsp; &nbsp; EPQState&nbsp; &nbsp; epqstate;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *localslot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execMain.c.html#L2539" title="executor/execMain.c:2539">EvalPlanQualInit</a>(&amp;epqstate, estate, <span class="Constant">NULL</span>, NIL, -<span class="Constant">1</span>, NIL);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>(relinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; found = <a href="#L2846" title="replication/logical/worker.c:2846">FindReplTupleInLocalRel</a>(edata, localrel, remoterel, localindexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot, &amp;localslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If found delete it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EvalPlanQualSetSlot(&amp;epqstate, localslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the actual delete. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="replication/logical/worker.c:2339">TargetPrivilegesCheck</a>(relinfo-&gt;ri_RelationDesc, ACL_DELETE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execReplication.c.html#L619" title="executor/execReplication.c:619">ExecSimpleRelationDelete</a>(relinfo, estate, &amp;epqstate, localslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple to be deleted could not be found.&nbsp; Do nothing except for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitting a log message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should this be promoted to ereport(LOG) perhaps?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication did not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> row to be deleted &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;in replication target relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(localrel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L231" title="executor/execIndexing.c:231">ExecCloseIndices</a>(relinfo);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execMain.c.html#L2982" title="executor/execMain.c:2982">EvalPlanQualEnd</a>(&amp;epqstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a tuple received from the publication side (in 'remoteslot') in<br/></li>
<li></span><span class="Comment"> * the corresponding local relation using either replica identity index,<br/></li>
<li></span><span class="Comment"> * primary key, index or if needed, sequential scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Local tuple, if found, is returned in '*localslot'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2846">&#x200c;</a></span><span class="linkable">FindReplTupleInLocalRel</span>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata, Relation localrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepRelation *remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid localidxoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot **localslot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = edata-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Regardless of the top-level operation, we're performing a read here, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for SELECT privileges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2339" title="replication/logical/worker.c:2339">TargetPrivilegesCheck</a>(localrel, ACL_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *localslot = <a href="../../access/table/tableam.c.html#L91" title="access/table/tableam.c:91">table_slot_create</a>(localrel, &amp;estate-&gt;es_tupleTable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(localidxoid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (remoterel-&gt;replident == REPLICA_IDENTITY_FULL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(localidxoid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; idxrel = <a href="../../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(localidxoid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Index must be PK, RI, or usable for REPLICA IDENTITY FULL tables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="relation.c.html#L851" title="replication/logical/relation.c:851">GetRelationIdentityOrPK</a>(idxrel) == localidxoid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="relation.c.html#L804" title="replication/logical/relation.c:804">IsIndexUsableForReplicaIdentityFull</a>(<a href="../../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(idxrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; edata-&gt;targetRel-&gt;attrmap));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idxrel, AccessShareLock);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <a href="../../executor/execReplication.c.html#L176" title="executor/execReplication.c:176">RelationFindReplTupleByIndex</a>(localrel, localidxoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockTupleExclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot, *localslot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <a href="../../executor/execReplication.c.html#L378" title="executor/execReplication.c:378">RelationFindReplTupleSeq</a>(localrel, LockTupleExclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot, *localslot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This handles insert, update, delete on a partitioned table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2893">&#x200c;</a></span><span class="linkable">apply_handle_tuple_routing</span>(<a href="#L206" title="replication/logical/worker.c:206">ApplyExecutionData</a> *edata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalRepTupleData *newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CmdType operation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = edata-&gt;estate;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *relmapentry = edata-&gt;targetRel;<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *relinfo = edata-&gt;targetRelInfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; parentrel = relinfo-&gt;ri_RelationDesc;<br/></li>
<li>&nbsp; &nbsp; ModifyTableState *mtstate;<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execPartition.c.html#L91" title="executor/execPartition.c:91">PartitionTupleRouting</a> *proute;<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *partrelinfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; partrel;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *remoteslot_part;<br/></li>
<li>&nbsp; &nbsp; TupleConversionMap *map;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; LogicalRepRelMapEntry *part_entry = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attrmap = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ModifyTableState is needed for <a href="../../executor/execPartition.c.html#L262" title="executor/execPartition.c:262">ExecFindPartition</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;mtstate = mtstate = makeNode(ModifyTableState);<br/></li>
<li>&nbsp; &nbsp; mtstate-&gt;ps.plan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; mtstate-&gt;ps.state = estate;<br/></li>
<li>&nbsp; &nbsp; mtstate-&gt;operation = operation;<br/></li>
<li>&nbsp; &nbsp; mtstate-&gt;resultRelInfo = relinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... as is <a href="../../executor/execPartition.c.html#L91" title="executor/execPartition.c:91">PartitionTupleRouting</a>. */<br/></li>
<li></span>&nbsp; &nbsp; edata-&gt;proute = proute = <a href="../../executor/execPartition.c.html#L215" title="executor/execPartition.c:215">ExecSetupPartitionTupleRouting</a>(estate, parentrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the partition to which the &quot;search tuple&quot; belongs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(remoteslot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; partrelinfo = <a href="../../executor/execPartition.c.html#L262" title="executor/execPartition.c:262">ExecFindPartition</a>(mtstate, relinfo, proute,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot, estate);<br/></li>
<li>&nbsp; &nbsp; Assert(partrelinfo != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; partrel = partrelinfo-&gt;ri_RelationDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for supported relkind.&nbsp; We need this since partitions might be of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unsupported relkinds; and the set of partitions can change, so checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at CREATE/ALTER SUBSCRIPTION would be insufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/execReplication.c.html#L739" title="executor/execReplication.c:739">CheckSubscriptionRelkind</a>(partrel-&gt;rd_rel-&gt;relkind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(partrel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(partrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To perform <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the operations below, the tuple must match the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition's rowtype. Convert if needed or just copy, using a dedicated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot to store the tuple in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; remoteslot_part = partrelinfo-&gt;ri_PartitionTupleSlot;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remoteslot_part == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part = <a href="../../access/table/tableam.c.html#L91" title="access/table/tableam.c:91">table_slot_create</a>(partrel, &amp;estate-&gt;es_tupleTable);<br/></li>
<li>&nbsp; &nbsp; map = <a href="../../executor/execUtils.c.html#L1232" title="executor/execUtils.c:1232">ExecGetRootToChildMap</a>(partrelinfo, estate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrmap = map-&gt;attrMap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part = <a href="../../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(attrmap, remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part = ExecCopySlot(remoteslot_part, remoteslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we can do the update or delete on the leaf partition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (operation == CMD_UPDATE || operation == CMD_DELETE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; part_entry = <a href="relation.c.html#L602" title="replication/logical/relation.c:602">logicalrep_partition_open</a>(relmapentry, partrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attrmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2479" title="replication/logical/worker.c:2479">check_relation_updatable</a>(part_entry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (operation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2457" title="replication/logical/worker.c:2457">apply_handle_insert_internal</a>(edata, partrelinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2792" title="replication/logical/worker.c:2792">apply_handle_delete_internal</a>(edata, partrelinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot_part,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; part_entry-&gt;localindexoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For UPDATE, depending on whether or not the updated tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * satisfies the partition's constraint, perform a simple UPDATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the partition or move the updated tuple into a different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * suitable partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *localslot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultRelInfo *partrelinfo_new;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; partrel_new;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the matching local tuple from the partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <a href="#L2846" title="replication/logical/worker.c:2846">FindReplTupleInLocalRel</a>(edata, partrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;part_entry-&gt;remoterel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_entry-&gt;localindexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part, &amp;localslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple to be updated could not be found.&nbsp; Do nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * except for emitting a log message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should this be promoted to ereport(LOG) perhaps?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication did not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> row to be updated &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;in replication target relation's partition </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(partrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply the update to the local tuple, putting the result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remoteslot_part.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L898" title="replication/logical/worker.c:898">slot_modify_data</a>(remoteslot_part, localslot, part_entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does the updated tuple still satisfy the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition's constraint?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!partrel-&gt;rd_rel-&gt;relispartition ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execMain.c.html#L1792" title="executor/execMain.c:1792">ExecPartitionCheck</a>(partrelinfo, remoteslot_part, estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, so simply UPDATE the partition.&nbsp; We don't call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2637" title="replication/logical/worker.c:2637">apply_handle_update_internal</a>() here, which would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * normally do the following work, to avoid repeating some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * work already done above to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the local tuple in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EPQState&nbsp; &nbsp; epqstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execMain.c.html#L2539" title="executor/execMain.c:2539">EvalPlanQualInit</a>(&amp;epqstate, estate, <span class="Constant">NULL</span>, NIL, -<span class="Constant">1</span>, NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>(partrelinfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EvalPlanQualSetSlot(&amp;epqstate, remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="replication/logical/worker.c:2339">TargetPrivilegesCheck</a>(partrelinfo-&gt;ri_RelationDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_UPDATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execReplication.c.html#L554" title="executor/execReplication.c:554">ExecSimpleRelationUpdate</a>(partrelinfo, estate, &amp;epqstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; localslot, remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execIndexing.c.html#L231" title="executor/execIndexing.c:231">ExecCloseIndices</a>(partrelinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execMain.c.html#L2982" title="executor/execMain.c:2982">EvalPlanQualEnd</a>(&amp;epqstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move the tuple into the new partition. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New partition will be found using tuple routing, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can only occur via the parent table.&nbsp; We might need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * convert the tuple to the parent's rowtype.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this is the tuple found in the partition, not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original search tuple received by this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleConversionMap *PartitionToRootMap =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupconvert.c.html#L102" title="access/common/tupconvert.c:102">convert_tuples_by_name</a>(RelationGetDescr(partrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(parentrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(PartitionToRootMap-&gt;attrMap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part, remoteslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot = ExecCopySlot(remoteslot, remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(remoteslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the new partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partrelinfo_new = <a href="../../executor/execPartition.c.html#L262" title="executor/execPartition.c:262">ExecFindPartition</a>(mtstate, relinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proute, remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(partrelinfo_new != partrelinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partrel_new = partrelinfo_new-&gt;ri_RelationDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that new partition also has supported relkind. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execReplication.c.html#L739" title="executor/execReplication.c:739">CheckSubscriptionRelkind</a>(partrel_new-&gt;rd_rel-&gt;relkind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(partrel_new)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(partrel_new));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DELETE old tuple found in the old partition. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2792" title="replication/logical/worker.c:2792">apply_handle_delete_internal</a>(edata, partrelinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; localslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; part_entry-&gt;localindexoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* INSERT new tuple into the new partition. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the replacement tuple to match the destination<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition rowtype.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part = partrelinfo_new-&gt;ri_PartitionTupleSlot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remoteslot_part == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part = <a href="../../access/table/tableam.c.html#L91" title="access/table/tableam.c:91">table_slot_create</a>(partrel_new,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;estate-&gt;es_tupleTable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = <a href="../../executor/execUtils.c.html#L1232" title="executor/execUtils.c:1232">ExecGetRootToChildMap</a>(partrelinfo_new, estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part = <a href="../../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(map-&gt;attrMap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remoteslot_part = ExecCopySlot(remoteslot_part,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_getallattrs(remoteslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2457" title="replication/logical/worker.c:2457">apply_handle_insert_internal</a>(edata, partrelinfo_new,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; remoteslot_part);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized CmdType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) operation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle TRUNCATE message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: FDW support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3144">&#x200c;</a></span><span class="linkable">apply_handle_truncate</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cascade = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; restart_seqs = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *remote_relids = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *remote_rels = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rels = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *part_rels = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relids = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *relids_logged = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode = AccessExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quick return if we are skipping data modification changes or handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streamed transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L336" title="replication/logical/worker.c:336">is_skipping_changes</a>() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L559" title="replication/logical/worker.c:559">handle_streamed_transaction</a>(LOGICAL_REP_MSG_TRUNCATE, s))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L508" title="replication/logical/worker.c:508">begin_replication_step</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; remote_relids = <a href="proto.c.html#L618" title="replication/logical/proto.c:618">logicalrep_read_truncate</a>(s, &amp;cascade, &amp;restart_seqs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, remote_relids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepRelId relid = lfirst_oid(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepRelMapEntry *rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="relation.c.html#L327" title="replication/logical/relation.c:327">logicalrep_rel_open</a>(relid, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L468" title="replication/logical/worker.c:468">should_apply_changes_for_rel</a>(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The relation can't become interesting in the middle of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction so it's safe to unlock it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remote_rels = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(remote_rels, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="replication/logical/worker.c:2339">TargetPrivilegesCheck</a>(rel-&gt;localrel, ACL_TRUNCATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rels, rel-&gt;localrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids, rel-&gt;localreloid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsLogicallyLogged(rel-&gt;localrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids_logged = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids_logged, rel-&gt;localreloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Truncate partitions if we got a message to truncate a partitioned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;localrel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *children = <a href="../../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a>(rel-&gt;localreloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(child, children)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrelid = lfirst_oid(child);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(relids, childrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../catalog/pg_inherits.c.html#L255" title="catalog/pg_inherits.c:255">find_all_inheritors</a> already got lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childrel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(childrelid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore temp tables of other backends.&nbsp; See similar code in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/tablecmds.c.html#L1807" title="commands/tablecmds.c:1807">ExecuteTruncate</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(childrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2339" title="replication/logical/worker.c:2339">TargetPrivilegesCheck</a>(childrel, ACL_TRUNCATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rels = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rels, childrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part_rels = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(part_rels, childrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids, childrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Log this relation only if needed for logical decoding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsLogicallyLogged(childrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids_logged = <a href="../../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(relids_logged, childrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even if we used CASCADE on the upstream primary we explicitly default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to replaying changes without further cascading. This might be later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changeable with a user specified option.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;runasowner tells us whether we want to execute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication actions as the subscription owner; the last argument to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TruncateGuts tells it whether we want to switch to the table owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Those are exactly opposite conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L1931" title="commands/tablecmds.c:1931">ExecuteTruncateGuts</a>(rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids_logged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DROP_RESTRICT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_seqs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;runasowner);<br/></li>
<li>&nbsp; &nbsp; foreach(lc, remote_rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalRepRelMapEntry *rel = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="relation.c.html#L473" title="replication/logical/relation.c:473">logicalrep_rel_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; foreach(lc, part_rels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L531" title="replication/logical/worker.c:531">end_replication_step</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Logical replication protocol message dispatcher.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3272">&#x200c;</a></span><span class="linkable">apply_dispatch</span>(StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRepMsgType action = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(s);<br/></li>
<li>&nbsp; &nbsp; LogicalRepMsgType saved_command;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the current command being applied. Since this function can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called recursively when applying spooled changes, save the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; saved_command = <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.command;<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.command = action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L991" title="replication/logical/worker.c:991">apply_handle_begin</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_COMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1016" title="replication/logical/worker.c:1016">apply_handle_commit</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2371" title="replication/logical/worker.c:2371">apply_handle_insert</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2520" title="replication/logical/worker.c:2520">apply_handle_update</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2704" title="replication/logical/worker.c:2704">apply_handle_delete</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3144" title="replication/logical/worker.c:3144">apply_handle_truncate</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2301" title="replication/logical/worker.c:2301">apply_handle_relation</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_TYPE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2324" title="replication/logical/worker.c:2324">apply_handle_type</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_ORIGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1408" title="replication/logical/worker.c:1408">apply_handle_origin</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_MESSAGE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Logical replication does not use generic logical messages yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although, it could be used by other applications that use this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output plugin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1467" title="replication/logical/worker.c:1467">apply_handle_stream_start</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_STOP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1626" title="replication/logical/worker.c:1626">apply_handle_stream_stop</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1812" title="replication/logical/worker.c:1812">apply_handle_stream_abort</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_COMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2131" title="replication/logical/worker.c:2131">apply_handle_stream_commit</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_BEGIN_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1042" title="replication/logical/worker.c:1042">apply_handle_begin_prepare</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1108" title="replication/logical/worker.c:1108">apply_handle_prepare</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_COMMIT_PREPARED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1169" title="replication/logical/worker.c:1169">apply_handle_commit_prepared</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_ROLLBACK_PREPARED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1218" title="replication/logical/worker.c:1218">apply_handle_rollback_prepared</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LOGICAL_REP_MSG_STREAM_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1271" title="replication/logical/worker.c:1271">apply_handle_stream_prepare</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid logical replication message type </span><span class="Special">\&quot;</span><span class="Constant">??? (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>, action)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the current command */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.command = saved_command;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Figure out which write/flush positions to report to the walsender process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't simply report back the last LSN the walsender sent us because the<br/></li>
<li></span><span class="Comment"> * local transaction might not yet be flushed to disk locally. Instead we<br/></li>
<li></span><span class="Comment"> * build a list that associates local with remote LSNs for every commit. When<br/></li>
<li></span><span class="Comment"> * reporting back the flush position to the sender we iterate that list and<br/></li>
<li></span><span class="Comment"> * check which entries on it are already locally flushed. Those we can report<br/></li>
<li></span><span class="Comment"> * as having been flushed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The have_pending_txes is true if there are outstanding transactions that<br/></li>
<li></span><span class="Comment"> * need to be flushed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3392">&#x200c;</a></span><span class="linkable">get_flush_position</span>(XLogRecPtr *write, XLogRecPtr *flush,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_pending_txes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; local_flush = <a href="../../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *write = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; *flush = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L204" title="replication/logical/worker.c:204">lsn_mapping</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L197" title="replication/logical/worker.c:197">FlushPosition</a> *pos =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(<a href="#L197" title="replication/logical/worker.c:197">FlushPosition</a>, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *write = pos-&gt;remote_end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos-&gt;local_end &lt;= local_flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *flush = pos-&gt;remote_end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't want to uselessly iterate over the rest of the list which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could potentially be long. Instead get the last <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grab the write position from there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = dlist_tail_element(<a href="#L197" title="replication/logical/worker.c:197">FlushPosition</a>, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L204" title="replication/logical/worker.c:204">lsn_mapping</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *write = pos-&gt;remote_end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_pending_txes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *have_pending_txes = !dlist_is_empty(&amp;<a href="#L204" title="replication/logical/worker.c:204">lsn_mapping</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store current remote/local lsn pair in the tracking list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3436">&#x200c;</a></span><span class="linkable">store_flush_position</span>(XLogRecPtr remote_lsn, XLogRecPtr local_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L197" title="replication/logical/worker.c:197">FlushPosition</a> *flushpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Skip for parallel apply workers, because the <a href="#L204" title="replication/logical/worker.c:204">lsn_mapping</a> is maintained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the leader apply worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (am_parallel_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to do this in permanent context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Track commit lsn&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; flushpos = (<a href="#L197" title="replication/logical/worker.c:197">FlushPosition</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L197" title="replication/logical/worker.c:197">FlushPosition</a>));<br/></li>
<li>&nbsp; &nbsp; flushpos-&gt;local_end = local_lsn;<br/></li>
<li>&nbsp; &nbsp; flushpos-&gt;remote_end = remote_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;<a href="#L204" title="replication/logical/worker.c:204">lsn_mapping</a>, &amp;flushpos-&gt;node);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Update statistics of the worker. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3462">&#x200c;</a></span><span class="linkable">UpdateWorkerStats</span>(XLogRecPtr last_lsn, TimestampTz send_time, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reply)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;last_lsn = last_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;last_send_time = send_time;<br/></li>
<li>&nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;last_recv_time = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reply)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;reply_lsn = last_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;reply_time = send_time;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Apply <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3478">&#x200c;</a></span><span class="linkable">LogicalRepApplyLoop</span>(XLogRecPtr last_received)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz last_recv_timestamp = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ping_sent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Init the <a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a> which we clean up after each replication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protocol message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a> = AllocSetContextCreate(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This memory context is used for per-stream data when the streaming mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is enabled. This context is reset on each stream stop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L294" title="replication/logical/worker.c:294">LogicalStreamingContext</a> = AllocSetContextCreate(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L294" title="replication/logical/worker.c:294">LogicalStreamingContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark as idle, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting to loop */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Push apply error context callback. Fields will be filled while applying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="#L4893" title="replication/logical/worker.c:4893">apply_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="replication/logical/worker.c:288">apply_error_context_stack</a> = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This outer loop iterates once per wait. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgsocket&nbsp; &nbsp; fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; endofstream = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; wait_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = walrcv_receive(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>, &amp;buf, &amp;fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop to process all available data (without blocking). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;data stream from publisher has ended&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endofstream = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset timeout. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_recv_timestamp = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ping_sent = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure we are reading the data into our memory context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;s, buf, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c == <span class="Constant">'w'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; start_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; end_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz send_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; send_time = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_received &lt; start_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_received = start_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_received &lt; end_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_received = end_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3462" title="replication/logical/worker.c:3462">UpdateWorkerStats</a>(last_received, send_time, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3272" title="replication/logical/worker.c:3272">apply_dispatch</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (c == <span class="Constant">'k'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; end_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz timestamp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reply_requested;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_lsn = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamp = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reply_requested = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_received &lt; end_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_received = end_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3742" title="replication/logical/worker.c:3742">send_feedback</a>(last_received, reply_requested, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3462" title="replication/logical/worker.c:3462">UpdateWorkerStats</a>(last_received, timestamp, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other message types are purposefully ignored */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = walrcv_receive(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>, &amp;buf, &amp;fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* confirm all writes so far */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3742" title="replication/logical/worker.c:3742">send_feedback</a>(last_received, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a> &amp;&amp; !<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't get <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions for a while there might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unconsumed invalidation messages in the queue, consume them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3862" title="replication/logical/worker.c:3862">maybe_reread_subscription</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> table synchronization changes. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tablesync.c.html#L667" title="replication/logical/tablesync.c:667">process_syncing_tables</a>(last_received);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cleanup the memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L290" title="replication/logical/worker.c:290">ApplyMessageContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we need to exit the streaming loop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endofstream)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for more data or latch.&nbsp; If we have unflushed transactions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wake up after <a href="../../postmaster/walwriter.c.html#L71" title="postmaster/walwriter.c:71">WalWriterDelay</a> to see if they've been flushed yet (in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case we should <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a feedback message).&nbsp; Otherwise, there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no particular urgency about waking up unless we get data or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dlist_is_empty(&amp;<a href="#L204" title="replication/logical/worker.c:204">lsn_mapping</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_time = <a href="../../postmaster/walwriter.c.html#L71" title="postmaster/walwriter.c:71">WalWriterDelay</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_time = <a href="#L195" title="replication/logical/worker.c:195">NAPTIME_PER_CYCLE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_SOCKET_READABLE | WL_LATCH_SET |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fd, wait_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_LOGICAL_APPLY_MAIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_TIMEOUT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We didn't receive anything new. If we haven't heard anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the server for more than <a href="../walreceiver.c.html#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a> / 2, ping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the server. Also, if it's been longer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../walreceiver.c.html#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> since the last update we sent,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a status update to the primary anyway, to report <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * progress in applying WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; requestReply = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if time since last receive from primary has reached the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * configured limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../walreceiver.c.html#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz timeout;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTzPlusMilliseconds(last_recv_timestamp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiver.c.html#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= timeout)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating logical replication worker due to timeout&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check to see if it's time for a ping. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ping_sent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout = TimestampTzPlusMilliseconds(last_recv_timestamp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../walreceiver.c.html#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a> / <span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= timeout)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requestReply = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ping_sent = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3742" title="replication/logical/worker.c:3742">send_feedback</a>(last_received, requestReply, requestReply);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force reporting to ensure long idle periods don't lead to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arbitrarily delayed stats. Stats can only be reported outside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of (implicit or explicit) transactions. That shouldn't lead to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stats being delayed for long, because transactions are either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sent as a whole on commit or streamed. Streamed transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are spilled to disk and applied on commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="replication/logical/worker.c:288">apply_error_context_stack</a> = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All done */<br/></li>
<li></span>&nbsp; &nbsp; walrcv_endstreaming(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>, &amp;tli);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a Standby Status Update message to server.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'recvpos' is the latest LSN we've received data to, force is set if we need<br/></li>
<li></span><span class="Comment"> * to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a response to avoid timeouts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3742">&#x200c;</a></span><span class="linkable">send_feedback</span>(XLogRecPtr recvpos, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> requestReply)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> StringInfo <a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TimestampTz send_time = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr last_recvpos = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr last_writepos = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr last_flushpos = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; writepos;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; flushpos;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_pending_txes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the user doesn't want status to be reported to the publisher, be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure to exit <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing anything at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!force &amp;&amp; <a href="../walreceiver.c.html#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's legal to not pass a recvpos */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recvpos &lt; last_recvpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recvpos = last_recvpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3392" title="replication/logical/worker.c:3392">get_flush_position</a>(&amp;writepos, &amp;flushpos, &amp;have_pending_txes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No outstanding transactions to flush, we can report the latest received<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position. This is important for synchronous replication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!have_pending_txes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flushpos = writepos = recvpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (writepos &lt; last_writepos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writepos = last_writepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flushpos &lt; last_flushpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flushpos = last_flushpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we've already reported everything we're good */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!force &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writepos == last_writepos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flushpos == last_flushpos &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(send_time, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiver.c.html#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> * <span class="Constant">1000</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; send_time = <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx = MemoryContextSwitchTo(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a> = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, <span class="Constant">'r'</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, recvpos);&nbsp; &nbsp; <span class="Comment">/* write */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, flushpos);&nbsp; &nbsp; <span class="Comment">/* flush */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, writepos);&nbsp; &nbsp; <span class="Comment">/* apply */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint64(<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);&nbsp; &nbsp; <span class="Comment">/* sendTime */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendbyte(<a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>, requestReply);&nbsp; &nbsp; <span class="Comment">/* replyRequested */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;sending feedback (force </span><span class="Special">%d</span><span class="Constant">) to <a href="../../port/win32/socket.c.html#L37" title="port/win32/socket.c:37">recv</a> </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, write </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, flush </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; force,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(recvpos),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(writepos),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(flushpos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walrcv_send(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>-&gt;data, <a href="../walreceiver.c.html#L131" title="replication/walreceiver.c:131">reply_message</a>-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recvpos &gt; last_recvpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_recvpos = recvpos;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (writepos &gt; last_writepos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_writepos = writepos;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flushpos &gt; last_flushpos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_flushpos = flushpos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Exit routine for apply workers due to subscription parameter changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3831">&#x200c;</a></span><span class="linkable">apply_worker_exit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (am_parallel_apply_worker())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't stop the parallel apply worker as the leader will detect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subscription parameter change and restart logical replication later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway. This also prevents the leader from reporting errors when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to communicate with a stopped parallel apply worker, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would accidentally disable subscriptions if disable_on_error was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset the last-start time for this apply worker so that the launcher<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will restart it without <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for <a href="../../access/transam/xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a> if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subscription is still active, and so that we won't leak that <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry if it isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (am_leader_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L1075" title="replication/logical/launcher.c:1075">ApplyLauncherForgetWorkerStartTime</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reread subscription info if needed. Most changes will be exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3862">&#x200c;</a></span><span class="linkable">maybe_reread_subscription</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; Subscription *<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When cache state is valid there is nothing to do here. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="replication/logical/worker.c:299">MySubscriptionValid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This function might be called inside or outside of transaction. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure allocations in permanent context. */<br/></li>
<li></span>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a> = <a href="../../catalog/pg_subscription.c.html#L41" title="catalog/pg_subscription.c:41">GetSubscription</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exit if the subscription was removed. This normally should not happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the worker gets killed during DROP SUBSCRIPTION.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will stop because the subscription was removed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure we remove no-longer-useful entry for worker's start time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (am_leader_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L1075" title="replication/logical/launcher.c:1075">ApplyLauncherForgetWorkerStartTime</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exit if the subscription was disabled. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;enabled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will stop because the subscription was disabled&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3831" title="replication/logical/worker.c:3831">apply_worker_exit</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* !slotname should never happen when enabled is true. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;slotname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* two-phase should not be altered */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;twophasestate == <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;twophasestate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exit if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameter that affects the remote connection was changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The launcher will start a new worker but note that the parallel apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker won't restart if the streaming option's value is changed from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'parallel' to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other value or the server decides not to stream the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-progress transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;conninfo, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;conninfo) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;name, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;slotname, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;slotname) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;binary != <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;binary ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;stream != <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;stream ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;passwordrequired != <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;passwordrequired ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;origin, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;origin) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;owner != <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;owner ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;publications, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;publications))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (am_parallel_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication parallel apply worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will stop because of a parameter change&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will restart because of a parameter change&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3831" title="replication/logical/worker.c:3831">apply_worker_exit</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exit if the subscription owner's <a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> privileges have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * revoked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;ownersuperuser &amp;&amp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;ownersuperuser)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (am_parallel_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication parallel apply worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will stop because the subscription owner's <a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> privileges have been revoked&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will restart because the subscription owner's <a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> privileges have been revoked&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3831" title="replication/logical/worker.c:3831">apply_worker_exit</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for other changes that should never happen too. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>-&gt;dbid != <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;dbid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;subscription </span><span class="Special">%u</span><span class="Constant"> changed unexpectedly&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean old subscription info and switch to new one. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/pg_subscription.c.html#L155" title="catalog/pg_subscription.c:155">FreeSubscription</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a> = <a href="../../regex/regc_color.c.html#L389" title="regex/regc_color.c:389">newsub</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Change synchronous commit according to the user's wishes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../../access/transam/xact.c.html#L85" title="access/transam/xact.c:85">synchronous_commit</a>&quot;</span>, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;synccommit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_BACKEND, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (started_tx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="replication/logical/worker.c:299">MySubscriptionValid</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback from subscription syscache invalidation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3991">&#x200c;</a></span><span class="linkable">subscription_change_cb</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="replication/logical/worker.c:299">MySubscriptionValid</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4006" title="replication/logical/worker.c:4006">subxact_info_write</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Store information about subxacts for a toplevel transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each subxact we store offset of it's first change in the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> file.<br/></li>
<li></span><span class="Comment"> * The file is always over-written as a whole.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We should only store subxacts that were not aborted yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4006">&#x200c;</a></span><span class="linkable">subxact_info_write</span>(Oid subid, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* construct the subxact filename */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4184" title="replication/logical/worker.c:4184">subxact_filename</a>(path, subid, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the subxacts file, if exists. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4388" title="replication/logical/worker.c:4388">cleanup_subxact_info</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L364" title="storage/file/buffile.c:364">BufFileDeleteFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, path, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the subxact file if it not already created, otherwise open the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, path, O_RDWR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../../storage/file/buffile.c.html#L267" title="storage/file/buffile.c:267">BufFileCreateFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L341" title="replication/logical/worker.c:341">SubXactInfo</a>) * <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the subxact count and subxact info */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(fd, &amp;<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(fd, <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free the memory allocated for subxact info */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4388" title="replication/logical/worker.c:4388">cleanup_subxact_info</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4055" title="replication/logical/worker.c:4055">subxact_info_read</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Restore information about subxacts of a streamed transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Read information about subxacts into the structure <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a> that can be<br/></li>
<li></span><span class="Comment"> * used later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4055">&#x200c;</a></span><span class="linkable">subxact_info_read</span>(Oid subid, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a>&nbsp; &nbsp; *fd;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the subxact file doesn't exist that means we don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subxact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4184" title="replication/logical/worker.c:4184">subxact_filename</a>(path, subid, xid);<br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, path, O_RDONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read number of subxact items */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(fd, &amp;<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L341" title="replication/logical/worker.c:341">SubXactInfo</a>) * <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we keep the maximum as a power of 2 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max = <span class="Constant">1</span> &lt;&lt; <a href="../../utils/hash/dynahash.c.html#L1751" title="utils/hash/dynahash.c:1751">my_log2</a>(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate subxact information in the logical streaming context. We need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this information during the complete stream so that we can add the sub<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction info to this. On stream stop we will flush this information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the subxact file and reset the logical streaming context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L294" title="replication/logical/worker.c:294">LogicalStreamingContext</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L341" title="replication/logical/worker.c:341">SubXactInfo</a>));<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(fd, <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(fd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4106" title="replication/logical/worker.c:4106">subxact_info_add</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Add information about a subxact (offset in the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> file).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4106">&#x200c;</a></span><span class="linkable">subxact_info_add</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L341" title="replication/logical/worker.c:341">SubXactInfo</a> *subxacts = <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must have a valid top level stream xid and a stream fd. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the XID matches the toplevel transaction, we don't want to add it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L309" title="replication/logical/worker.c:309">stream_xid</a> == xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In most cases we're checking the same subxact as we've already seen in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the last call, so make sure to ignore it (this change comes later).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxact_last == xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, remember we're processing this XID. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxact_last = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the transaction is already present in the array of subxact. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intentionally scan the array from the tail, because we're likely adding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a change for the most recent subtransactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Can we rely on the subxact XIDs arriving in sorted order? That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would allow us to use binary search here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found, so we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subxacts[i - <span class="Constant">1</span>].xid == xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is a new subxact, so we need to add it to the array. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max = <span class="Constant">128</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate this memory for subxacts in per-stream context, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L4055" title="replication/logical/worker.c:4055">subxact_info_read</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L294" title="replication/logical/worker.c:294">LogicalStreamingContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subxacts = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L341" title="replication/logical/worker.c:341">SubXactInfo</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts == <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subxacts = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(subxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L341" title="replication/logical/worker.c:341">SubXactInfo</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subxacts[<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts].xid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the current offset of the stream file and store it as offset of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this subxact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L833" title="storage/file/buffile.c:833">BufFileTell</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subxacts[<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts].fileno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;subxacts[<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts].offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts = subxacts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* format filename for file containing the info about subxacts */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4184">&#x200c;</a></span><span class="linkable">subxact_filename</span>(<span class="Type">char</span> *path, Oid subid, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; snprintf(path, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant">.subxacts&quot;</span>, subid, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* format filename for file containing serialized changes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4191">&#x200c;</a></span><span class="linkable">changes_filename</span>(<span class="Type">char</span> *path, Oid subid, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; snprintf(path, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">-</span><span class="Special">%u</span><span class="Constant">.changes&quot;</span>, subid, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4205" title="replication/logical/worker.c:4205">stream_cleanup_files</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Cleanup files for a subscription / toplevel transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove files with serialized changes and subxact info for a particular<br/></li>
<li></span><span class="Comment"> * toplevel transaction. Each subscription has a separate set of files<br/></li>
<li></span><span class="Comment"> * for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> toplevel transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4205">&#x200c;</a></span><span class="linkable">stream_cleanup_files</span>(Oid subid, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the changes file. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4191" title="replication/logical/worker.c:4191">changes_filename</a>(path, subid, xid);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L364" title="storage/file/buffile.c:364">BufFileDeleteFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, path, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the subxact file, if it exists. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4184" title="replication/logical/worker.c:4184">subxact_filename</a>(path, subid, xid);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L364" title="storage/file/buffile.c:364">BufFileDeleteFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset, path, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4229" title="replication/logical/worker.c:4229">stream_open_file</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Open a file that we'll use to serialize changes for a toplevel<br/></li>
<li></span><span class="Comment"> * transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Open a file for streamed changes from a toplevel transaction identified<br/></li>
<li></span><span class="Comment"> * by <a href="#L309" title="replication/logical/worker.c:309">stream_xid</a> (global variable). If it's the first chunk of streamed<br/></li>
<li></span><span class="Comment"> * changes for this transaction, create the buffile, otherwise open the<br/></li>
<li></span><span class="Comment"> * previously created file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4229">&#x200c;</a></span><span class="linkable">stream_open_file</span>(Oid subid, TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> first_segment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(subid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4191" title="replication/logical/worker.c:4191">changes_filename</a>(path, subid, xid);<br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;opening file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for streamed changes&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create/open the buffiles under the logical streaming context so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have those files until stream stop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L294" title="replication/logical/worker.c:294">LogicalStreamingContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first streamed segment, create the changes file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, just open the file for writing, in append mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (first_segment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> = <a href="../../storage/file/buffile.c.html#L267" title="storage/file/buffile.c:267">BufFileCreateFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Open the file and seek to the end of the file because we always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * append the changes file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> = <a href="../../storage/file/buffile.c.html#L291" title="storage/file/buffile.c:291">BufFileOpenFileSet</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;stream_fileset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path, O_RDWR, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L740" title="storage/file/buffile.c:740">BufFileSeek</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">SEEK_END</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4274" title="replication/logical/worker.c:4274">stream_close_file</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Close the currently open file with streamed changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4274">&#x200c;</a></span><span class="linkable">stream_close_file</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Serialize a change to a file for the current toplevel transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The change is serialized in a simple format, with length (not including<br/></li>
<li></span><span class="Comment"> * the length), action code (identifying the message type) and message<br/></li>
<li></span><span class="Comment"> * contents (without the subxact TransactionId value).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4292">&#x200c;</a></span><span class="linkable">stream_write_change</span>(<span class="Type">char</span> action, StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* total on-disk size, including the action type character */<br/></li>
<li></span>&nbsp; &nbsp; len = (s-&gt;len - s-&gt;cursor) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first write the size */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>, &amp;len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(len));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* then the action */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>, &amp;action, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(action));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and finally the remaining part of the buffer (after the XID) */<br/></li>
<li></span>&nbsp; &nbsp; len = (s-&gt;len - s-&gt;cursor);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>, &amp;s-&gt;data[s-&gt;cursor], len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4322" title="replication/logical/worker.c:4322">stream_open_and_write_change</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Serialize a message to a file for the given transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is similar to <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a> except that it will open the<br/></li>
<li></span><span class="Comment"> * target file if not already <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> writing the message and close the file at<br/></li>
<li></span><span class="Comment"> * the end.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4322">&#x200c;</a></span><span class="linkable">stream_open_and_write_change</span>(TransactionId xid, <span class="Type">char</span> action, StringInfo s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L339" title="replication/logical/worker.c:339">stream_fd</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1429" title="replication/logical/worker.c:1429">stream_start_internal</a>(xid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4292" title="replication/logical/worker.c:4292">stream_write_change</a>(action, s);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1603" title="replication/logical/worker.c:1603">stream_stop_internal</a>(xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets streaming options including replication slot name and origin start<br/></li>
<li></span><span class="Comment"> * position. Workers need these options for logical replication.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4338">&#x200c;</a></span><span class="linkable">set_stream_options</span>(WalRcvStreamOptions *options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *slotname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *origin_startpos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; server_version;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; options-&gt;logical = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; options-&gt;startpoint = *origin_startpos;<br/></li>
<li>&nbsp; &nbsp; options-&gt;slotname = slotname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; server_version = walrcv_server_version(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>);<br/></li>
<li>&nbsp; &nbsp; options-&gt;proto.logical.proto_version =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; server_version &gt;= <span class="Constant">160000</span> ? LOGICALREP_PROTO_STREAM_PARALLEL_VERSION_NUM :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; server_version &gt;= <span class="Constant">150000</span> ? LOGICALREP_PROTO_TWOPHASE_VERSION_NUM :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; server_version &gt;= <span class="Constant">140000</span> ? LOGICALREP_PROTO_STREAM_VERSION_NUM :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOGICALREP_PROTO_VERSION_NUM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; options-&gt;proto.logical.publication_names = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;publications;<br/></li>
<li>&nbsp; &nbsp; options-&gt;proto.logical.binary = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;binary;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assign the appropriate option value for streaming option according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the 'streaming' mode and the publisher's ability to support that mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (server_version &gt;= <span class="Constant">160000</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;stream == LOGICALREP_STREAM_PARALLEL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; options-&gt;proto.logical.streaming_str = <span class="Constant">&quot;parallel&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;parallel_apply = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (server_version &gt;= <span class="Constant">140000</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;stream != LOGICALREP_STREAM_OFF)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; options-&gt;proto.logical.streaming_str = <span class="Constant">&quot;on&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;parallel_apply = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; options-&gt;proto.logical.streaming_str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;parallel_apply = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; options-&gt;proto.logical.twophase = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; options-&gt;proto.logical.origin = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;origin);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup the memory for subxacts and reset the related variables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4388">&#x200c;</a></span><span class="linkable">cleanup_subxact_info</span>()<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxacts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.subxact_last = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L357" title="replication/logical/worker.c:357">subxact_data</a>.nsubxacts_max = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form the prepared transaction GID for two_phase transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the GID in the supplied buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4405">&#x200c;</a></span><span class="linkable">TwoPhaseTransactionGid</span>(Oid subid, TransactionId xid, <span class="Type">char</span> *gid, <span class="Type">int</span> szgid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(subid != InvalidRepOriginId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;invalid two-phase transaction ID&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(gid, szgid, <span class="Constant">&quot;pg_gid_</span><span class="Special">%u</span><span class="Constant"><a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a></span><span class="Special">%u</span><span class="Constant">&quot;</span>, subid, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common function to run the apply loop with error handling. Disable the<br/></li>
<li></span><span class="Comment"> * subscription, if necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't handle FATAL errors which are probably because<br/></li>
<li></span><span class="Comment"> * of system resource error and are not repeatable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4425">&#x200c;</a></span><span class="linkable">start_apply</span>(XLogRecPtr origin_startpos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3478" title="replication/logical/worker.c:3478">LogicalRepApplyLoop</a>(origin_startpos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;disableonerr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4705" title="replication/logical/worker.c:4705">DisableSubscriptionAndExit</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report the worker failed while applying changes. Abort the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current transaction so that the stats message is sent in an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * idle state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4811" title="access/transam/xact.c:4811">AbortOutOfAnyTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_subscription.c.html#L27" title="utils/activity/pgstat_subscription.c:27">pgstat_report_subscription_error</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, !am_tablesync_worker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Runs the leader apply worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It sets up replication origin, streaming options and then starts streaming.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4457">&#x200c;</a></span><span class="linkable">run_apply_worker</span>()<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; originname[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; origin_startpos = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *slotname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; WalRcvStreamOptions options;<br/></li>
<li>&nbsp; &nbsp; RepOriginId originid;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; startpointTLI;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *err;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; must_use_password;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slotname = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;slotname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This shouldn't happen if the subscription is enabled, but guard against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DDL bugs or manual catalog changes.&nbsp; (libpqwalreceiver will crash if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot is NULL.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!slotname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;subscription has no replication slot set&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup replication origin tracking. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L428" title="replication/logical/worker.c:428">ReplicationOriginNameForLogicalRep</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; originname, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(originname));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; originid = <a href="origin.c.html#L221" title="replication/logical/origin.c:221">replorigin_by_name</a>(originname, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(originid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; originid = <a href="origin.c.html#L252" title="replication/logical/origin.c:252">replorigin_create</a>(originname);<br/></li>
<li>&nbsp; &nbsp; <a href="origin.c.html#L1097" title="replication/logical/origin.c:1097">replorigin_session_setup</a>(originid, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> = originid;<br/></li>
<li>&nbsp; &nbsp; origin_startpos = <a href="origin.c.html#L1237" title="replication/logical/origin.c:1237">replorigin_session_get_progress</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the use of a password mandatory? */<br/></li>
<li></span>&nbsp; &nbsp; must_use_password = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;passwordrequired &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;ownersuperuser;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a> = walrcv_connect(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;conninfo, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, must_use_password,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name, &amp;err);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the publisher: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, err)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't really use the output identify_system for anything but it does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some initializations on the upstream so let's still call it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) walrcv_identify_system(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>, &amp;startpointTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5035" title="replication/logical/worker.c:5035">set_apply_error_context_origin</a>(originname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4338" title="replication/logical/worker.c:4338">set_stream_options</a>(&amp;options, slotname, &amp;origin_startpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even when the two_phase mode is requested by the user, it remains as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tri-state PENDING until all tablesyncs have reached READY state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only then, can it become ENABLED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: If the subscription has no tables then leave the state as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PENDING, which allows ALTER SUBSCRIPTION ... REFRESH PUBLICATION to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;twophasestate == LOGICALREP_TWOPHASE_STATE_PENDING &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tablesync.c.html#L1731" title="replication/logical/tablesync.c:1731">AllTablesyncsReady</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start streaming with two_phase enabled */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; options.proto.logical.twophase = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walrcv_startstreaming(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>, &amp;options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="tablesync.c.html#L1756" title="replication/logical/tablesync.c:1756">UpdateTwoPhaseState</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, LOGICALREP_TWOPHASE_STATE_ENABLED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;twophasestate = LOGICALREP_TWOPHASE_STATE_ENABLED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walrcv_startstreaming(<a href="#L296" title="replication/logical/worker.c:296">LogRepWorkerWalRcvConn</a>, &amp;options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;logical replication apply worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> two_phase is </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;twophasestate == LOGICALREP_TWOPHASE_STATE_DISABLED ? <span class="Constant">&quot;DISABLED&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;twophasestate == LOGICALREP_TWOPHASE_STATE_PENDING ? <span class="Constant">&quot;PENDING&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;twophasestate == LOGICALREP_TWOPHASE_STATE_ENABLED ? <span class="Constant">&quot;ENABLED&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;?&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Run the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4425" title="replication/logical/worker.c:4425">start_apply</a>(origin_startpos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common initialization for leader apply worker, parallel apply worker and<br/></li>
<li></span><span class="Comment"> * tablesync worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initialize the database connection, in-memory subscription and necessary<br/></li>
<li></span><span class="Comment"> * config options.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4561">&#x200c;</a></span><span class="linkable">InitializeLogRepWorker</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Run as replica session replication role. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;session_replication_role&quot;</span>, <span class="Constant">&quot;replica&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Connect to our database. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L4189" title="postmaster/postmaster.c:4189">BackgroundWorkerInitializeConnectionByOid</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;dbid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set always-secure search path, so malicious users can't redirect user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code (e.g. pg_index.indexprs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;search_path&quot;</span>, <span class="Constant">&quot;&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the subscription into persistent memory context. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a> = <a href="../../catalog/pg_subscription.c.html#L41" title="catalog/pg_subscription.c:41">GetSubscription</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker for subscription </span><span class="Special">%u</span><span class="Constant"> will not start because the subscription was removed during startup&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure we remove no-longer-useful entry for worker's start time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (am_leader_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L1075" title="replication/logical/launcher.c:1075">ApplyLauncherForgetWorkerStartTime</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="replication/logical/worker.c:299">MySubscriptionValid</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;enabled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> will not start because the subscription was disabled during startup&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3831" title="replication/logical/worker.c:3831">apply_worker_exit</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup synchronous commit according to the user's wishes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../../access/transam/xact.c.html#L85" title="access/transam/xact.c:85">synchronous_commit</a>&quot;</span>, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;synccommit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_BACKEND, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep us informed about subscription or role changes. Note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * role's <a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> privilege can be revoked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(SUBSCRIPTIONOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3991" title="replication/logical/worker.c:3991">subscription_change_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(AUTHOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3991" title="replication/logical/worker.c:3991">subscription_change_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (am_tablesync_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication table synchronization worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has started&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;relid))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication apply worker for subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has started&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Common function to setup the leader apply or tablesync worker. */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4644">&#x200c;</a></span><span class="linkable">SetupApplyOrSyncWorker</span>(<span class="Type">int</span> worker_slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach to slot */<br/></li>
<li></span>&nbsp; &nbsp; <a href="launcher.c.html#L707" title="replication/logical/launcher.c:707">logicalrep_worker_attach</a>(worker_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(am_tablesync_worker() || am_leader_apply_worker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup signal handling */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="../../postmaster/interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L4229" title="postmaster/postmaster.c:4229">BackgroundWorkerUnblockSignals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't currently need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ResourceOwner in a walreceiver process, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we did, we could call <a href="../../utils/resowner/resowner.c.html#L982" title="utils/resowner/resowner.c:982">CreateAuxProcessResourceOwner</a> here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialise stats to a sanish value */<br/></li>
<li></span>&nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;last_send_time = <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;last_recv_time =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;reply_time = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the libpq-specific <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/fmgr/dfmgr.c.html#L144" title="utils/fmgr/dfmgr.c:144">load_file</a>(<span class="Constant">&quot;libpqwalreceiver&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4561" title="replication/logical/worker.c:4561">InitializeLogRepWorker</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Connect to the origin and start the replication. */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;connecting to publisher using connection string </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;conninfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup callback for syscache so that we know when something changes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the subscription relation state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(SUBSCRIPTIONRELMAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="tablesync.c.html#L281" title="replication/logical/tablesync.c:281">invalidate_syncing_table_states</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Logical Replication Apply worker entry point */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4685">&#x200c;</a></span><span class="linkable">ApplyWorkerMain</span>(Datum main_arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker_slot = DatumGetInt32(main_arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L318" title="replication/logical/worker.c:318">InitializingApplyWorker</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4644" title="replication/logical/worker.c:4644">SetupApplyOrSyncWorker</a>(worker_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L318" title="replication/logical/worker.c:318">InitializingApplyWorker</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4457" title="replication/logical/worker.c:4457">run_apply_worker</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * After error recovery, disable the subscription in a new transaction<br/></li>
<li></span><span class="Comment"> * and exit cleanly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4705">&#x200c;</a></span><span class="linkable">DisableSubscriptionAndExit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit the error message, and recover from the error state to an idle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4811" title="access/transam/xact.c:4811">AbortOutOfAnyTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report the worker failed during either table synchronization or apply */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_subscription.c.html#L27" title="utils/activity/pgstat_subscription.c:27">pgstat_report_subscription_error</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !am_tablesync_worker());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable the subscription */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_subscription.c.html#L169" title="catalog/pg_subscription.c:169">DisableSubscription</a>(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we remove no-longer-useful entry for worker's start time */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (am_leader_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L1075" title="replication/logical/launcher.c:1075">ApplyLauncherForgetWorkerStartTime</a>(<a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a>-&gt;subid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Notify the subscription has been disabled and exit */<br/></li>
<li></span>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has been disabled because of an error&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is current process a logical replication worker?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4744">&#x200c;</a></span><span class="linkable">IsLogicalWorker</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="launcher.c.html#L54" title="replication/logical/launcher.c:54">MyLogicalRepWorker</a> != <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is current process a logical replication parallel apply worker?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4753">&#x200c;</a></span><span class="linkable">IsLogicalParallelApplyWorker</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L4744" title="replication/logical/worker.c:4744">IsLogicalWorker</a>() &amp;&amp; am_parallel_apply_worker();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start skipping changes of the transaction if the given LSN matches the<br/></li>
<li></span><span class="Comment"> * LSN specified by subscription's skiplsn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4763">&#x200c;</a></span><span class="linkable">maybe_start_skipping_changes</span>(XLogRecPtr finish_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L336" title="replication/logical/worker.c:336">is_skipping_changes</a>());<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L303" title="replication/logical/worker.c:303">in_remote_transaction</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quick return if it's not requested to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this transaction. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function is called for every remote transaction and we assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * skipping the transaction is not used often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (likely(XLogRecPtrIsInvalid(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;skiplsn) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;skiplsn != finish_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start skipping all changes of this transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L335" title="replication/logical/worker.c:335">skip_xact_finish_lsn</a> = finish_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication starts skipping transaction at LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L335" title="replication/logical/worker.c:335">skip_xact_finish_lsn</a>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stop skipping changes by resetting <a href="#L335" title="replication/logical/worker.c:335">skip_xact_finish_lsn</a> if enabled.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4790">&#x200c;</a></span><span class="linkable">stop_skipping_changes</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L336" title="replication/logical/worker.c:336">is_skipping_changes</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication completed skipping transaction at LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L335" title="replication/logical/worker.c:335">skip_xact_finish_lsn</a>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Stop skipping changes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L335" title="replication/logical/worker.c:335">skip_xact_finish_lsn</a> = InvalidXLogRecPtr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear subskiplsn of pg_subscription catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * finish_lsn is the transaction's finish LSN that is used to check if the<br/></li>
<li></span><span class="Comment"> * subskiplsn matches it. If not matched, we raise a warning when clearing the<br/></li>
<li></span><span class="Comment"> * subskiplsn in order to inform users for cases e.g., where the user mistakenly<br/></li>
<li></span><span class="Comment"> * specified the wrong subskiplsn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4812">&#x200c;</a></span><span class="linkable">clear_subscription_skip_lsn</span>(XLogRecPtr finish_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Form_pg_subscription subform;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; myskiplsn = <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;skiplsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(XLogRecPtrIsInvalid(myskiplsn)) || am_parallel_apply_worker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; started_tx = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Protect subskiplsn of pg_subscription from being concurrently updated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while clearing it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1083" title="storage/lmgr/lmgr.c:1083">LockSharedObject</a>(SubscriptionRelationId, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(SubscriptionRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the existing tuple. */<br/></li>
<li></span>&nbsp; &nbsp; tup = SearchSysCacheCopy1(SUBSCRIPTIONOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(<a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subform = (Form_pg_subscription) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the subskiplsn. If the user has already changed subskiplsn <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clearing it we don't update the catalog and the replication origin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state won't get advanced. So in the worst case, if the server crashes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending an acknowledgment of the flush position the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be sent again and the user needs to set subskiplsn again. We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reduce the possibility by logging a replication origin WAL record to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance the origin LSN instead but there is no way to advance the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * origin timestamp and it doesn't seem to be worth doing anything about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it since it's a very rare case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (subform-&gt;subskiplsn == myskiplsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Natts_pg_subscription];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replaces[Natts_pg_subscription];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Natts_pg_subscription];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(nulls, <span class="Constant">false</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nulls));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(replaces, <span class="Constant">false</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(replaces));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset subskiplsn */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_subscription_subskiplsn - <span class="Constant">1</span>] = LSNGetDatum(InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replaces[Anum_pg_subscription_subskiplsn - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tup, RelationGetDescr(rel), <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replaces);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(rel, &amp;tup-&gt;t_self, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (myskiplsn != finish_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>-LSN of subscription </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cleared&quot;</span>, <a href="#L298" title="replication/logical/worker.c:298">MySubscription</a>-&gt;name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Remote transaction's finish WAL location (LSN) </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> did not match <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>-LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(finish_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(myskiplsn)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tup);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (started_tx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Error callback to give more context info about the change being applied */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4893">&#x200c;</a></span><span class="linkable">apply_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L219" title="replication/logical/worker.c:219">ApplyErrorCallbackArg</a> *errarg = &amp;<a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.command == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(errarg-&gt;origin_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errarg-&gt;rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(errarg-&gt;remote_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing remote data for replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during message type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;origin_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proto.c.html#L1217" title="replication/logical/proto.c:1217">logicalrep_message_type</a>(errarg-&gt;command));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (XLogRecPtrIsInvalid(errarg-&gt;finish_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing remote data for replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during message type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;origin_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proto.c.html#L1217" title="replication/logical/proto.c:1217">logicalrep_message_type</a>(errarg-&gt;command),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;remote_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing remote data for replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during message type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in transaction </span><span class="Special">%u</span><span class="Constant">, finished at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;origin_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proto.c.html#L1217" title="replication/logical/proto.c:1217">logicalrep_message_type</a>(errarg-&gt;command),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;remote_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(errarg-&gt;finish_lsn));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errarg-&gt;remote_attnum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(errarg-&gt;finish_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing remote data for replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during message type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> in transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;origin_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proto.c.html#L1217" title="replication/logical/proto.c:1217">logicalrep_message_type</a>(errarg-&gt;command),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;remote_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing remote data for replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during message type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> in transaction </span><span class="Special">%u</span><span class="Constant">, finished at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;origin_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proto.c.html#L1217" title="replication/logical/proto.c:1217">logicalrep_message_type</a>(errarg-&gt;command),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;remote_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(errarg-&gt;finish_lsn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(errarg-&gt;finish_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing remote data for replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during message type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;origin_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proto.c.html#L1217" title="replication/logical/proto.c:1217">logicalrep_message_type</a>(errarg-&gt;command),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.attnames[errarg-&gt;remote_attnum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;remote_xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing remote data for replication origin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during message type </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for replication target relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in transaction </span><span class="Special">%u</span><span class="Constant">, finished at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;origin_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="proto.c.html#L1217" title="replication/logical/proto.c:1217">logicalrep_message_type</a>(errarg-&gt;command),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.nspname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;rel-&gt;remoterel.attnames[errarg-&gt;remote_attnum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errarg-&gt;remote_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(errarg-&gt;finish_lsn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Set transaction information of apply error callback */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4965">&#x200c;</a></span><span class="linkable">set_apply_error_context_xact</span>(TransactionId xid, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.remote_xid = xid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.finish_lsn = lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Reset all information of apply error callback */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L4973">&#x200c;</a></span><span class="linkable">reset_apply_error_context_info</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.command = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.rel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.remote_attnum = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4965" title="replication/logical/worker.c:4965">set_apply_error_context_xact</a>(InvalidTransactionId, InvalidXLogRecPtr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Request <a href="../walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> of the workers for the given subscription OID<br/></li>
<li></span><span class="Comment"> * at commit of the current transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to ensure that the workers process assorted changes<br/></li>
<li></span><span class="Comment"> * as soon as possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4989">&#x200c;</a></span><span class="linkable">LogicalRepWorkersWakeupAtCommit</span>(Oid subid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L301" title="replication/logical/worker.c:301">on_commit_wakeup_workers_subids</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1380" title="nodes/list.c:1380">list_append_unique_oid</a>(<a href="#L301" title="replication/logical/worker.c:301">on_commit_wakeup_workers_subids</a>, subid);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up the workers of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subscriptions that were changed in this xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5003">&#x200c;</a></span><span class="linkable">AtEOXact_LogicalRepWorkers</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit &amp;&amp; <a href="#L301" title="replication/logical/worker.c:301">on_commit_wakeup_workers_subids</a> != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(LogicalRepWorkerLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="#L301" title="replication/logical/worker.c:301">on_commit_wakeup_workers_subids</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subid = lfirst_oid(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workers = <a href="launcher.c.html#L275" title="replication/logical/launcher.c:275">logicalrep_workers_find</a>(subid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, workers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRepWorker *worker = (LogicalRepWorker *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="launcher.c.html#L696" title="replication/logical/launcher.c:696">logicalrep_worker_wakeup_ptr</a>(worker);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(LogicalRepWorkerLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The List storage will be reclaimed automatically in xact <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L301" title="replication/logical/worker.c:301">on_commit_wakeup_workers_subids</a> = NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate the origin name in long-lived context for error context message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5035">&#x200c;</a></span><span class="linkable">set_apply_error_context_origin</span>(<span class="Type">char</span> *originname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="replication/logical/worker.c:278">apply_error_callback_arg</a>.origin_name = <a href="../../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="#L291" title="replication/logical/worker.c:291">ApplyContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; originname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the action to be taken for the given transaction. See<br/></li>
<li></span><span class="Comment"> * <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a> for information on each of the actions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *winfo is assigned to the destination parallel worker info when the leader<br/></li>
<li></span><span class="Comment"> * apply worker has to pass all the transaction's changes to the parallel<br/></li>
<li></span><span class="Comment"> * apply worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L275" title="replication/logical/worker.c:275">TransApplyAction</a><br/></li>
<li><a id="L5050">&#x200c;</a><span class="linkable">get_transaction_apply_action</span>(TransactionId xid, ParallelApplyWorkerInfo **winfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *winfo = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (am_parallel_apply_worker())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TRANS_PARALLEL_APPLY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are processing this transaction using a parallel apply worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then either we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the changes to the parallel worker or if the worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is busy then serialize the changes to the file which will later be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed by the parallel worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *winfo = <a href="applyparallelworker.c.html#L518" title="replication/logical/applyparallelworker.c:518">pa_find_worker</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*winfo &amp;&amp; (*winfo)-&gt;serialize_changes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TRANS_LEADER_PARTIAL_SERIALIZE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*winfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TRANS_LEADER_SEND_TO_PARALLEL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is no parallel worker involved to process this transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we either directly apply the change or serialize it to a file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which will later be applied when the transaction finish message is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L307" title="replication/logical/worker.c:307">in_streamed_transaction</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TRANS_LEADER_SERIALIZE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TRANS_LEADER_APPLY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
