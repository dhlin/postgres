<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/reorderbuffer.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/reorderbuffer.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L216">debug_logical_replication_streaming</a></li>
<li><a href="#L212">logical_decoding_work_mem</a></li>
<li><a href="#L213">max_changes_in_memory</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L177">ReorderBufferDiskChange</a></li>
<li><a href="#L182">ReorderBufferDiskChange</a></li>
<li><a href="#L146">ReorderBufferIterTXNEntry</a></li>
<li><a href="#L153">ReorderBufferIterTXNEntry</a></li>
<li><a href="#L155">ReorderBufferIterTXNState</a></li>
<li><a href="#L161">ReorderBufferIterTXNState</a></li>
<li><a href="#L116">ReorderBufferTXNByIdEnt</a></li>
<li><a href="#L120">ReorderBufferTXNByIdEnt</a></li>
<li><a href="#L164">ReorderBufferToastEnt</a></li>
<li><a href="#L174">ReorderBufferToastEnt</a></li>
<li><a href="#L129">ReorderBufferTupleCidEnt</a></li>
<li><a href="#L135">ReorderBufferTupleCidEnt</a></li>
<li><a href="#L123">ReorderBufferTupleCidKey</a></li>
<li><a href="#L127">ReorderBufferTupleCidKey</a></li>
<li><a href="#L5016">RewriteMappingFile</a></li>
<li><a href="#L5020">RewriteMappingFile</a></li>
<li><a href="#L138">TXNEntryFile</a></li>
<li><a href="#L143">TXNEntryFile</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L5052">ApplyLogicalMappingFile</a></li>
<li><a href="#L983">AssertChangeLsnOrder</a></li>
<li><a href="#L912">AssertTXNLsnOrder</a></li>
<li><a href="#L5024">DisplayMapping</a></li>
<li><a href="#L2902">ReorderBufferAbort</a></li>
<li><a href="#L2947">ReorderBufferAbortOld</a></li>
<li><a href="#L3300">ReorderBufferAddInvalidations</a></li>
<li><a href="#L3164">ReorderBufferAddNewCommandId</a></li>
<li><a href="#L3263">ReorderBufferAddNewTupleCids</a></li>
<li><a href="#L3115">ReorderBufferAddSnapshot</a></li>
<li><a href="#L309">ReorderBufferAllocate</a></li>
<li><a href="#L1968">ReorderBufferApplyChange</a></li>
<li><a href="#L1996">ReorderBufferApplyMessage</a></li>
<li><a href="#L1982">ReorderBufferApplyTruncate</a></li>
<li><a href="#L1069">ReorderBufferAssignChild</a></li>
<li><a href="#L1734">ReorderBufferBuildTupleCidHash</a></li>
<li><a href="#L4000">ReorderBufferCanStartStreaming</a></li>
<li><a href="#L3991">ReorderBufferCanStream</a></li>
<li><a href="#L3192">ReorderBufferChangeMemoryUpdate</a></li>
<li><a href="#L4143">ReorderBufferChangeSize</a></li>
<li><a href="#L3608">ReorderBufferCheckMemoryLimit</a></li>
<li><a href="#L4569">ReorderBufferCleanupSerializedTXNs</a></li>
<li><a href="#L1505">ReorderBufferCleanupTXN</a></li>
<li><a href="#L2711">ReorderBufferCommit</a></li>
<li><a href="#L1189">ReorderBufferCommitChild</a></li>
<li><a href="#L1807">ReorderBufferCopySnap</a></li>
<li><a href="#L3359">ReorderBufferExecuteInvalidations</a></li>
<li><a href="#L2817">ReorderBufferFinishPrepared</a></li>
<li><a href="#L2994">ReorderBufferForget</a></li>
<li><a href="#L396">ReorderBufferFree</a></li>
<li><a href="#L1866">ReorderBufferFreeSnap</a></li>
<li><a href="#L3409">ReorderBufferGetCatalogChangesXacts</a></li>
<li><a href="#L477">ReorderBufferGetChange</a></li>
<li><a href="#L1014">ReorderBufferGetOldestTXN</a></li>
<li><a href="#L1042">ReorderBufferGetOldestXmin</a></li>
<li><a href="#L595">ReorderBufferGetRelids</a></li>
<li><a href="#L414">ReorderBufferGetTXN</a></li>
<li><a href="#L562">ReorderBufferGetTupleBuf</a></li>
<li><a href="#L3066">ReorderBufferImmediateInvalidation</a></li>
<li><a href="#L3035">ReorderBufferInvalidate</a></li>
<li><a href="#L1231">ReorderBufferIterCompare</a></li>
<li><a href="#L1474">ReorderBufferIterTXNFinish</a></li>
<li><a href="#L1254">ReorderBufferIterTXNInit</a></li>
<li><a href="#L1382">ReorderBufferIterTXNNext</a></li>
<li><a href="#L3564">ReorderBufferLargestStreamableTopTXN</a></li>
<li><a href="#L3524">ReorderBufferLargestTXN</a></li>
<li><a href="#L2780">ReorderBufferPrepare</a></li>
<li><a href="#L711">ReorderBufferProcessPartialChange</a></li>
<li><a href="#L2080">ReorderBufferProcessTXN</a></li>
<li><a href="#L3102">ReorderBufferProcessXid</a></li>
<li><a href="#L780">ReorderBufferQueueChange</a></li>
<li><a href="#L843">ReorderBufferQueueMessage</a></li>
<li><a href="#L2733">ReorderBufferRememberPrepareInfo</a></li>
<li><a href="#L2650">ReorderBufferReplay</a></li>
<li><a href="#L2037">ReorderBufferResetTXN</a></li>
<li><a href="#L4371">ReorderBufferRestoreChange</a></li>
<li><a href="#L4228">ReorderBufferRestoreChanges</a></li>
<li><a href="#L4539">ReorderBufferRestoreCleanup</a></li>
<li><a href="#L492">ReorderBufferReturnChange</a></li>
<li><a href="#L611">ReorderBufferReturnRelids</a></li>
<li><a href="#L438">ReorderBufferReturnTXN</a></li>
<li><a href="#L580">ReorderBufferReturnTupleBuf</a></li>
<li><a href="#L2016">ReorderBufferSaveTXNSnapshot</a></li>
<li><a href="#L3776">ReorderBufferSerializeChange</a></li>
<li><a href="#L3491">ReorderBufferSerializeReserve</a></li>
<li><a href="#L3681">ReorderBufferSerializeTXN</a></li>
<li><a href="#L4608">ReorderBufferSerializedPath</a></li>
<li><a href="#L3133">ReorderBufferSetBaseSnapshot</a></li>
<li><a href="#L1057">ReorderBufferSetRestartPoint</a></li>
<li><a href="#L2761">ReorderBufferSkipPrepare</a></li>
<li><a href="#L1881">ReorderBufferStreamCommit</a></li>
<li><a href="#L4026">ReorderBufferStreamTXN</a></li>
<li><a href="#L623">ReorderBufferTXNByXid</a></li>
<li><a href="#L3508">ReorderBufferTXNSizeCompare</a></li>
<li><a href="#L4679">ReorderBufferToastAppendChunk</a></li>
<li><a href="#L4659">ReorderBufferToastInitHash</a></li>
<li><a href="#L4762">ReorderBufferToastReplace</a></li>
<li><a href="#L4953">ReorderBufferToastReset</a></li>
<li><a href="#L1135">ReorderBufferTransferSnapToParent</a></li>
<li><a href="#L1616">ReorderBufferTruncateTXN</a></li>
<li><a href="#L3461">ReorderBufferXidHasBaseSnapshot</a></li>
<li><a href="#L3444">ReorderBufferXidHasCatalogChanges</a></li>
<li><a href="#L3371">ReorderBufferXidSetCatalogChanges</a></li>
<li><a href="#L5245">ResolveCminCmaxDuringDecoding</a></li>
<li><a href="#L1945">SetupCheckXidLive</a></li>
<li><a href="#L4625">StartupReorderBuffer</a></li>
<li><a href="#L5144">TransactionIdInArray</a></li>
<li><a href="#L5167">UpdateLogicalMappings</a></li>
<li><a href="#L5154">file_sort_by_lsn</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L2468">CHANGES_THRESHOLD</a></li>
<li><a href="#L193">IsInsertOrUpdate</a></li>
<li><a href="#L188">IsSpecConfirmOrAbort</a></li>
<li><a href="#L184">IsSpecInsert</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * reorderbuffer.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; PostgreSQL logical replay/reorder buffer management<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2012-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/reorderbuffer.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This module gets handed individual pieces of transactions in the order<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; they are written to the WAL and is responsible to reassemble them into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; toplevel transaction sized pieces. When a transaction is completely<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; reassembled - signaled by reading the transaction commit record - it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; will then call the output plugin (cf. <a href="#L2711" title="replication/logical/reorderbuffer.c:2711">ReorderBufferCommit</a>()) with the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; individual changes. The output plugins rely on snapshots built by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; snapbuild.c which hands them to us.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Transactions and subtransactions/savepoints in postgres are not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; immediately linked to each other from outside the performing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; backend. Only at commit/abort (or special xact_assignment <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>) they<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; are linked together. Which means that we will have to splice together a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; toplevel transaction from its subtransactions. To do that efficiently we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; build a binary heap indexed by the smallest current lsn of the individual<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; subtransactions' changestreams. As the individual streams are inherently<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ordered by LSN - since that is where we build them from - the transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; can easily be reassembled by always using the subtransaction with the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; smallest current LSN from the heap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; In order to cope with large transactions - which can be several times as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; big as the available memory - this module supports spooling the contents<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of large transactions to disk. When the transaction is replayed the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; contents of individual (sub-)transactions will be read from disk in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; chunks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This module also has to deal with reassembling toast <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> from the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; individual chunks stored in WAL. When a new (or initial) version of a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; tuple is stored in WAL it will always be preceded by the toast chunks<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; emitted for the columns stored out of line. Within a single toplevel<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transaction there will be no other data carrying <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> between a row's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; toast chunks and the row data itself. See ReorderBufferToast* for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; ReorderBuffer uses two special memory context types - <a href="../../utils/mmgr/slab.c.html#L103" title="utils/mmgr/slab.c:103">SlabContext</a> for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; allocations of fixed-length structures (changes and transactions), and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/generation.c.html#L59" title="utils/mmgr/generation.c:59">GenerationContext</a> for the variable-length transaction data (allocated<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and freed in groups with similar lifespans).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; To limit the amount of memory used by decoded changes, we track memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; used at the reorder buffer level (i.e. total amount of memory), and for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; each transaction. When the total amount of used memory exceeds the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; limit, the transaction consuming the most memory is then serialized to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Only decoded changes are evicted from memory (spilled to disk), not the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transaction <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. The number of toplevel transactions is limited,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; but a transaction with many subtransactions may still consume significant<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; amounts of memory. However, the transaction <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are fairly small and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; are not included in the memory limit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The current eviction algorithm is very simple - the transaction is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; picked merely by size, while it might be useful to also consider age<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (LSN) of the changes for example. With the new Generational memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; allocator, evicting the oldest changes would make it more likely the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; memory gets actually freed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We use a max-heap with transaction size as the key to efficiently <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the largest transaction. We update the max-heap whenever the memory<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; counter is updated; however transactions with size 0 are not stored in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the heap, because they have no changes to evict.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; We still rely on <a href="#L213" title="replication/logical/reorderbuffer.c:213">max_changes_in_memory</a> when loading serialized changes<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; back into memory. At that point we can't use the memory limit directly<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; as we load the subxacts independently. One option to deal with this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; would be to count the subxacts, and allow each to allocate 1/N of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; memory limit. That however does not seem very appealing, because with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; many subtransactions it may easily cause thrashing (short cycles of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; deserializing and applying very few changes). We probably should give<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more memory to the oldest subtransactions, because it's likely<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; they are the source for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> sequence of changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/rewriteheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/binaryheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/reorderbuffer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/snapbuild.h&quot;</span>&nbsp; &nbsp; <span class="Comment">/* just for <a href="snapbuild.c.html#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relfilenumbermap.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* entry for a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table we use to map from xid to our transaction state */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReorderBufferTXNByIdEnt</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><a id="L120">&#x200c;</a>} <span class="linkable">ReorderBufferTXNByIdEnt</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* data structures for (relfilelocator, ctid) =&gt; (cmin, cmax) mapping */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReorderBufferTupleCidKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData tid;<br/></li>
<li><a id="L127">&#x200c;</a>} <span class="linkable">ReorderBufferTupleCidKey</span>;<br/></li>
<li><br/></li>
<li><a id="L129">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReorderBufferTupleCidEnt</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="replication/logical/reorderbuffer.c:123">ReorderBufferTupleCidKey</a> key;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cmin;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cmax;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; combocid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just for debugging */<br/></li>
<li><a id="L135">&#x200c;</a></span>} <span class="linkable">ReorderBufferTupleCidEnt</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Virtual file descriptor with file offset tracking */<br/></li>
<li><a id="L138">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TXNEntryFile</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -1 when the file is closed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; curOffset;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* offset for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> write or read. Reset to 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when <a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a> is opened. */<br/></li>
<li><a id="L143">&#x200c;</a></span>} <span class="linkable">TXNEntryFile</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* k-way in-order change iteration support structures */<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReorderBufferIterTXNEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li>&nbsp; &nbsp; <a href="#L138" title="replication/logical/reorderbuffer.c:138">TXNEntryFile</a> file;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li><a id="L153">&#x200c;</a>} <span class="linkable">ReorderBufferIterTXNEntry</span>;<br/></li>
<li><br/></li>
<li><a id="L155">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReorderBufferIterTXNState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; binaryheap *heap;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nr_txns;<br/></li>
<li>&nbsp; &nbsp; dlist_head&nbsp; &nbsp; old_change;<br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="replication/logical/reorderbuffer.c:146">ReorderBufferIterTXNEntry</a> entries[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L161">&#x200c;</a>} <span class="linkable">ReorderBufferIterTXNState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* toast datastructures */<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReorderBufferToastEnt</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_id;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* toast_table.chunk_id */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; last_chunk_seq; <span class="Comment">/* toast_table.chunk_seq of the last chunk we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have seen */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; num_chunks;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of chunks we've already seen */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* combined size of chunks seen */<br/></li>
<li></span>&nbsp; &nbsp; dlist_head&nbsp; &nbsp; chunks;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* linked list of chunks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> varlena *reconstructed;&nbsp; &nbsp; <span class="Comment">/* reconstructed varlena <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> pointed to in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> tup */<br/></li>
<li><a id="L174">&#x200c;</a></span>} <span class="linkable">ReorderBufferToastEnt</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Disk serialization support datastructures */<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ReorderBufferDiskChange</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange change;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* data follows */<br/></li>
<li><a id="L182">&#x200c;</a></span>} <span class="linkable">ReorderBufferDiskChange</span>;<br/></li>
<li><br/></li>
<li><a id="L184">&#x200c;</a><span class="PreProc">#define <span class="linkable">IsSpecInsert</span>(action) \<br/></li>
<li></span><span class="PreProc">( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((action) == REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT) \<br/></li>
<li></span><span class="PreProc">)<br/></li>
<li><a id="L188">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IsSpecConfirmOrAbort</span>(action) \<br/></li>
<li></span><span class="PreProc">( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((action) == REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM) || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((action) == REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT)) \<br/></li>
<li></span><span class="PreProc">)<br/></li>
<li><a id="L193">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">IsInsertOrUpdate</span>(action) \<br/></li>
<li></span><span class="PreProc">( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((action) == REORDER_BUFFER_CHANGE_INSERT) || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((action) == REORDER_BUFFER_CHANGE_UPDATE) || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((action) == REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT)) \<br/></li>
<li></span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum number of changes kept in memory, per transaction. After that,<br/></li>
<li></span><span class="Comment"> * changes are spooled to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current value should be sufficient to decode the entire transaction<br/></li>
<li></span><span class="Comment"> * without hitting disk in OLTP workloads, while starting to spool to disk in<br/></li>
<li></span><span class="Comment"> * other workloads reasonably fast.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At some point in the future it probably makes sense to have a more elaborate<br/></li>
<li></span><span class="Comment"> * resource management here, but it's not entirely clear what that would look<br/></li>
<li></span><span class="Comment"> * like.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L212">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">logical_decoding_work_mem</span>;<br/></li>
<li><a id="L213">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> Size <span class="linkable">max_changes_in_memory</span> = <span class="Constant">4096</span>; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> for restore only */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC variable */<br/></li>
<li><a id="L216">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">debug_logical_replication_streaming</span> = DEBUG_LOGICAL_REP_STREAMING_BUFFERED;<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------<br/></li>
<li></span><span class="Comment"> * primary reorderbuffer support routines<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ReorderBufferTXN *<a href="#L414" title="replication/logical/reorderbuffer.c:414">ReorderBufferGetTXN</a>(ReorderBuffer *rb);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L438" title="replication/logical/reorderbuffer.c:438">ReorderBufferReturnTXN</a>(ReorderBuffer *rb, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> ReorderBufferTXN *<a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(ReorderBuffer *rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_new,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create_as_top);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1135" title="replication/logical/reorderbuffer.c:1135">ReorderBufferTransferSnapToParent</a>(ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *subtxn);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L912" title="replication/logical/reorderbuffer.c:912">AssertTXNLsnOrder</a>(ReorderBuffer *rb);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------<br/></li>
<li></span><span class="Comment"> * support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for lsn-order iterating over the -&gt;changes of a<br/></li>
<li></span><span class="Comment"> * transaction and its subtransactions<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * used for iteration over the k-way heap <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> of a transaction and its<br/></li>
<li></span><span class="Comment"> * subtransactions<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1254" title="replication/logical/reorderbuffer.c:1254">ReorderBufferIterTXNInit</a>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *<span class="Type">volatile</span> *iter_state);<br/></li>
<li><span class="Type">static</span> ReorderBufferChange *<a href="#L1382" title="replication/logical/reorderbuffer.c:1382">ReorderBufferIterTXNNext</a>(ReorderBuffer *rb, <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1474" title="replication/logical/reorderbuffer.c:1474">ReorderBufferIterTXNFinish</a>(ReorderBuffer *rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3359" title="replication/logical/reorderbuffer.c:3359">ReorderBufferExecuteInvalidations</a>(uint32 nmsgs, SharedInvalidationMessage *msgs);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> * Disk serialization support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L3608" title="replication/logical/reorderbuffer.c:3608">ReorderBufferCheckMemoryLimit</a>(ReorderBuffer *rb);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3681" title="replication/logical/reorderbuffer.c:3681">ReorderBufferSerializeTXN</a>(ReorderBuffer *rb, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3776" title="replication/logical/reorderbuffer.c:3776">ReorderBufferSerializeChange</a>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> fd, ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> Size <a href="#L4228" title="replication/logical/reorderbuffer.c:4228">ReorderBufferRestoreChanges</a>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="replication/logical/reorderbuffer.c:138">TXNEntryFile</a> *file, XLogSegNo *segno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4371" title="replication/logical/reorderbuffer.c:4371">ReorderBufferRestoreChange</a>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *data);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4539" title="replication/logical/reorderbuffer.c:4539">ReorderBufferRestoreCleanup</a>(ReorderBuffer *rb, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1616" title="replication/logical/reorderbuffer.c:1616">ReorderBufferTruncateTXN</a>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> txn_prepared);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4569" title="replication/logical/reorderbuffer.c:4569">ReorderBufferCleanupSerializedTXNs</a>(<span class="Type">const</span> <span class="Type">char</span> *slotname);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4608" title="replication/logical/reorderbuffer.c:4608">ReorderBufferSerializedPath</a>(<span class="Type">char</span> *path, ReplicationSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid, XLogSegNo segno);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3508" title="replication/logical/reorderbuffer.c:3508">ReorderBufferTXNSizeCompare</a>(<span class="Type">const</span> pairingheap_node *a, <span class="Type">const</span> pairingheap_node *b, <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1866" title="replication/logical/reorderbuffer.c:1866">ReorderBufferFreeSnap</a>(ReorderBuffer *rb, Snapshot snap);<br/></li>
<li><span class="Type">static</span> Snapshot <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>(ReorderBuffer *rb, Snapshot orig_snap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn, CommandId cid);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> * Streaming support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3991" title="replication/logical/reorderbuffer.c:3991">ReorderBufferCanStream</a>(ReorderBuffer *rb);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4000" title="replication/logical/reorderbuffer.c:4000">ReorderBufferCanStartStreaming</a>(ReorderBuffer *rb);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4026" title="replication/logical/reorderbuffer.c:4026">ReorderBufferStreamTXN</a>(ReorderBuffer *rb, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1881" title="replication/logical/reorderbuffer.c:1881">ReorderBufferStreamCommit</a>(ReorderBuffer *rb, ReorderBufferTXN *txn);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------<br/></li>
<li></span><span class="Comment"> * toast reassembly support<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L4659" title="replication/logical/reorderbuffer.c:4659">ReorderBufferToastInitHash</a>(ReorderBuffer *rb, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4953" title="replication/logical/reorderbuffer.c:4953">ReorderBufferToastReset</a>(ReorderBuffer *rb, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4762" title="replication/logical/reorderbuffer.c:4762">ReorderBufferToastReplace</a>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4679" title="replication/logical/reorderbuffer.c:4679">ReorderBufferToastAppendChunk</a>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, ReorderBufferChange *change);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> * memory accounting<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size <a href="#L4143" title="replication/logical/reorderbuffer.c:4143">ReorderBufferChangeSize</a>(ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(ReorderBuffer *rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> addition, Size sz);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new ReorderBuffer and clean out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old serialized state from<br/></li>
<li></span><span class="Comment"> * prior ReorderBuffer instances for the same slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ReorderBuffer *<br/></li>
<li><a id="L309">&#x200c;</a><span class="linkable">ReorderBufferAllocate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBuffer *buffer;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li>&nbsp; &nbsp; MemoryContext new_ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate memory in own context, to have better accountability */<br/></li>
<li></span>&nbsp; &nbsp; new_ctx = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ReorderBuffer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ReorderBuffer *) <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(new_ctx, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBuffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;hash_ctl, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hash_ctl));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;context = new_ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;change_context = <a href="../../utils/mmgr/slab.c.html#L322" title="utils/mmgr/slab.c:322">SlabContextCreate</a>(new_ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Change&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SLAB_DEFAULT_BLOCK_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferChange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;txn_context = <a href="../../utils/mmgr/slab.c.html#L322" title="utils/mmgr/slab.c:322">SlabContextCreate</a>(new_ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;TXN&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SLAB_DEFAULT_BLOCK_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferTXN));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> the allocation sizes used below pre-date generation context's block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * growing code.&nbsp; These <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> should likely be benchmarked and set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more suitable <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buffer-&gt;tup_context = <a href="../../utils/mmgr/generation.c.html#L160" title="utils/mmgr/generation.c:160">GenerationContextCreate</a>(new_ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Tuples&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SLAB_LARGE_BLOCK_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SLAB_LARGE_BLOCK_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SLAB_LARGE_BLOCK_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L116" title="replication/logical/reorderbuffer.c:116">ReorderBufferTXNByIdEnt</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = buffer-&gt;context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;by_txn = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;ReorderBufferByXid&quot;</span>, <span class="Constant">1000</span>, &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;by_txn_last_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;by_txn_last_txn = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;outbuf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;outbufsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* txn_heap is ordered by transaction size */<br/></li>
<li></span>&nbsp; &nbsp; buffer-&gt;txn_heap = <a href="../../lib/pairingheap.c.html#L42" title="lib/pairingheap.c:42">pairingheap_allocate</a>(<a href="#L3508" title="replication/logical/reorderbuffer.c:3508">ReorderBufferTXNSizeCompare</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;spillTxns = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;spillCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;spillBytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;streamTxns = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;streamCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;streamBytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;totalTxns = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buffer-&gt;totalBytes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer-&gt;current_restart_decoding_lsn = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;buffer-&gt;toplevel_by_lsn);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;buffer-&gt;txns_by_base_snapshot_lsn);<br/></li>
<li>&nbsp; &nbsp; dclist_init(&amp;buffer-&gt;catchange_txns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure there's no stale data from prior uses of this slot, in case some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prior exit avoided calling <a href="#L396" title="replication/logical/reorderbuffer.c:396">ReorderBufferFree</a>. Failure to do this can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * produce duplicated txns, and it's very cheap if there's nothing there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4569" title="replication/logical/reorderbuffer.c:4569">ReorderBufferCleanupSerializedTXNs</a>(NameStr(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a ReorderBuffer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L396">&#x200c;</a></span><span class="linkable">ReorderBufferFree</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext context = rb-&gt;context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We free separately allocated data by entirely scrapping reorderbuffer's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free disk space used by unconsumed reorder buffers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4569" title="replication/logical/reorderbuffer.c:4569">ReorderBufferCleanupSerializedTXNs</a>(NameStr(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get an unused, possibly preallocated, ReorderBufferTXN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ReorderBufferTXN *<br/></li>
<li><a id="L414">&#x200c;</a><span class="linkable">ReorderBufferGetTXN</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = (ReorderBufferTXN *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;txn_context, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferTXN));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(txn, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferTXN));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;txn-&gt;changes);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;txn-&gt;tuplecids);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;txn-&gt;subtxns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* InvalidCommandId is not zero, so set it explicitly */<br/></li>
<li></span>&nbsp; &nbsp; txn-&gt;command_id = InvalidCommandId;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;output_plugin_private = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> txn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a ReorderBufferTXN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L438">&#x200c;</a></span><span class="linkable">ReorderBufferReturnTXN</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean the lookup cache if we were cached (quite likely) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rb-&gt;by_txn_last_xid == txn-&gt;xid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;by_txn_last_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;by_txn_last_txn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free data that's contained */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;gid != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(txn-&gt;gid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;gid = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;tuplecid_hash != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(txn-&gt;tuplecid_hash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;tuplecid_hash = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;invalidations)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(txn-&gt;invalidations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;invalidations = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the toast <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4953" title="replication/logical/reorderbuffer.c:4953">ReorderBufferToastReset</a>(rb, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(txn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a fresh ReorderBufferChange.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ReorderBufferChange *<br/></li>
<li><a id="L477">&#x200c;</a><span class="linkable">ReorderBufferGetChange</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change = (ReorderBufferChange *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;change_context, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferChange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(change, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferChange));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> change;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a ReorderBufferChange and update memory accounting, if requested.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L492">&#x200c;</a></span><span class="linkable">ReorderBufferReturnChange</span>(ReorderBuffer *rb, ReorderBufferChange *change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> upd_mem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update memory accounting info */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (upd_mem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, change, <span class="Constant">NULL</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4143" title="replication/logical/reorderbuffer.c:4143">ReorderBufferChangeSize</a>(change));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free contained data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (change-&gt;action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.tp.newtuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L580" title="replication/logical/reorderbuffer.c:580">ReorderBufferReturnTupleBuf</a>(change-&gt;data.tp.newtuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.newtuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.tp.oldtuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L580" title="replication/logical/reorderbuffer.c:580">ReorderBufferReturnTupleBuf</a>(change-&gt;data.tp.oldtuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.oldtuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_MESSAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.msg.prefix != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(change-&gt;data.msg.prefix);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.prefix = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.msg.message != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(change-&gt;data.msg.message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.message = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INVALIDATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.inval.invalidations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(change-&gt;data.inval.invalidations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.inval.invalidations = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1866" title="replication/logical/reorderbuffer.c:1866">ReorderBufferFreeSnap</a>(rb, change-&gt;data.snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.snapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no data in addition to the struct itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.truncate.relids != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L611" title="replication/logical/reorderbuffer.c:611">ReorderBufferReturnRelids</a>(rb, change-&gt;data.truncate.relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.truncate.relids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(change);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a fresh HeapTuple fitting a tuple of size tuple_len (excluding header<br/></li>
<li></span><span class="Comment"> * overhead).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L562">&#x200c;</a><span class="linkable">ReorderBufferGetTupleBuf</span>(ReorderBuffer *rb, Size tuple_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; alloc_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; alloc_len = tuple_len + SizeofHeapTupleHeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = (HeapTuple) <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;tup_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAPTUPLESIZE + alloc_len);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) tuple + HEAPTUPLESIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a HeapTuple returned by <a href="#L562" title="replication/logical/reorderbuffer.c:562">ReorderBufferGetTupleBuf</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L580">&#x200c;</a></span><span class="linkable">ReorderBufferReturnTupleBuf</span>(HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get an array for relids of truncated relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use the global memory context (for the whole reorder buffer), because<br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the existing ones seems like a good match (some are SLAB, so we<br/></li>
<li></span><span class="Comment"> * can't use those, and tup_context is meant for tuple data, not relids). We<br/></li>
<li></span><span class="Comment"> * could add yet another context, but it seems like an overkill - TRUNCATE is<br/></li>
<li></span><span class="Comment"> * not particularly common operation, so it does not seem worth it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid *<br/></li>
<li><a id="L595">&#x200c;</a><span class="linkable">ReorderBufferGetRelids</span>(ReorderBuffer *rb, <span class="Type">int</span> nrelids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *relids;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; alloc_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; alloc_len = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * nrelids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relids = (Oid *) <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;context, alloc_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free an array of relids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L611">&#x200c;</a></span><span class="linkable">ReorderBufferReturnRelids</span>(ReorderBuffer *rb, Oid *relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relids);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the ReorderBufferTXN from the given buffer, specified by Xid.<br/></li>
<li></span><span class="Comment"> * If create is true, and a transaction doesn't already exist, create it<br/></li>
<li></span><span class="Comment"> * (with the given LSN, and as top transaction if that's specified);<br/></li>
<li></span><span class="Comment"> * when this happens, is_new is set to true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ReorderBufferTXN *<br/></li>
<li><a id="L623">&#x200c;</a><span class="linkable">ReorderBufferTXNByXid</span>(ReorderBuffer *rb, TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_new, XLogRecPtr lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> create_as_top)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li>&nbsp; &nbsp; <a href="#L116" title="replication/logical/reorderbuffer.c:116">ReorderBufferTXNByIdEnt</a> *ent;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the one-entry lookup cache first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(rb-&gt;by_txn_last_xid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;by_txn_last_xid == xid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = rb-&gt;by_txn_last_txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txn != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found it, and it's valid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *is_new = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> txn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cached as non-existent, and asked not to create? Then nothing else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!create)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise fall through to create it */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the cache wasn't hit or it yielded a &quot;does-not-exist&quot; and we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create an entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* search the lookup table */<br/></li>
<li></span>&nbsp; &nbsp; ent = (<a href="#L116" title="replication/logical/reorderbuffer.c:116">ReorderBufferTXNByIdEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(rb-&gt;by_txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; create ? HASH_ENTER : HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = ent-&gt;txn;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (create)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the new entry, if creation was requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ent != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;txn = <a href="#L414" title="replication/logical/reorderbuffer.c:414">ReorderBufferGetTXN</a>(rb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;txn-&gt;xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = ent-&gt;txn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;first_lsn = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;restart_decoding_lsn = rb-&gt;current_restart_decoding_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (create_as_top)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;rb-&gt;toplevel_by_lsn, &amp;txn-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L912" title="replication/logical/reorderbuffer.c:912">AssertTXNLsnOrder</a>(rb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; txn = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not found and not asked to create */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update cache */<br/></li>
<li></span>&nbsp; &nbsp; rb-&gt;by_txn_last_xid = xid;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;by_txn_last_txn = txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *is_new = !found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!create || txn != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> txn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the partial change for the streaming of in-progress transactions.&nbsp; We<br/></li>
<li></span><span class="Comment"> * can stream only complete changes so if we have a partial change like toast<br/></li>
<li></span><span class="Comment"> * table insert or speculative insert then we mark such a 'txn' so that it<br/></li>
<li></span><span class="Comment"> * can't be streamed.&nbsp; We also ensure that if the changes in such a 'txn' can<br/></li>
<li></span><span class="Comment"> * be streamed and are above <a href="#L212" title="replication/logical/reorderbuffer.c:212">logical_decoding_work_mem</a> threshold then we stream<br/></li>
<li></span><span class="Comment"> * them as soon as we have a complete change.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L711">&#x200c;</a></span><span class="linkable">ReorderBufferProcessPartialChange</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> toast_insert)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *toptxn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The partial changes need to be processed only while streaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-progress transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3991" title="replication/logical/reorderbuffer.c:3991">ReorderBufferCanStream</a>(rb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the top transaction. */<br/></li>
<li></span>&nbsp; &nbsp; toptxn = rbtxn_get_toptxn(txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Indicate a partial change for toast inserts.&nbsp; The change will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered as complete once we get the insert or update on the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table and we are sure that the pending toast chunks are not required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we allow streaming when there are pending toast chunks then such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chunks won't be released till the insert (multi_insert) is complete and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we expect the txn to have streamed all changes after streaming.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction is mainly to ensure the correctness of streamed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions and it doesn't seem worth uplifting such a restriction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just to allow this case because anyway we will stream the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once such an insert is complete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (toast_insert)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;txn_flags |= RBTXN_HAS_PARTIAL_CHANGE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rbtxn_has_partial_change(toptxn) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L193" title="replication/logical/reorderbuffer.c:193">IsInsertOrUpdate</a>(change-&gt;action) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; change-&gt;data.tp.clear_toast_afterwards)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;txn_flags &amp;= ~RBTXN_HAS_PARTIAL_CHANGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Indicate a partial change for speculative inserts.&nbsp; The change will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered as complete once we get the speculative confirm or abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * token.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L184" title="replication/logical/reorderbuffer.c:184">IsSpecInsert</a>(change-&gt;action))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;txn_flags |= RBTXN_HAS_PARTIAL_CHANGE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rbtxn_has_partial_change(toptxn) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L188" title="replication/logical/reorderbuffer.c:188">IsSpecConfirmOrAbort</a>(change-&gt;action))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;txn_flags &amp;= ~RBTXN_HAS_PARTIAL_CHANGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stream the transaction if it is serialized <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and the changes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> complete in the top-level transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The reason for doing the streaming of such a transaction as soon as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the complete change for it is that previously it would have reached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the memory threshold and wouldn't get streamed because of incomplete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes.&nbsp; Delaying such transactions would increase apply lag for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4000" title="replication/logical/reorderbuffer.c:4000">ReorderBufferCanStartStreaming</a>(rb) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(rbtxn_has_partial_change(toptxn)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rbtxn_is_serialized(txn) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rbtxn_has_streamable_change(toptxn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4026" title="replication/logical/reorderbuffer.c:4026">ReorderBufferStreamTXN</a>(rb, toptxn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Queue a change into a transaction so it can be replayed upon commit or will be<br/></li>
<li></span><span class="Comment"> * streamed when we reach <a href="#L212" title="replication/logical/reorderbuffer.c:212">logical_decoding_work_mem</a> threshold.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L780">&#x200c;</a></span><span class="linkable">ReorderBufferQueueChange</span>(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferChange *change, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> toast_insert)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, <span class="Constant">NULL</span>, lsn, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While streaming the previous changes we have detected that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction is aborted.&nbsp; So there is no point in collecting further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;concurrent_abort)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to update memory accounting for this change as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have not added it to the queue yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The changes that are sent downstream are considered streamable.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remember such transactions so that only those will later be considered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for streaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;action == REORDER_BUFFER_CHANGE_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;action == REORDER_BUFFER_CHANGE_UPDATE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;action == REORDER_BUFFER_CHANGE_DELETE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;action == REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;action == REORDER_BUFFER_CHANGE_TRUNCATE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;action == REORDER_BUFFER_CHANGE_MESSAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *toptxn = rbtxn_get_toptxn(txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;txn_flags |= RBTXN_HAS_STREAMABLE_CHANGE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change-&gt;lsn = lsn;<br/></li>
<li>&nbsp; &nbsp; change-&gt;txn = txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(InvalidXLogRecPtr != lsn);<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;txn-&gt;changes, &amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; txn-&gt;nentries++;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;nentries_mem++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update memory accounting information */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, change, <span class="Constant">NULL</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4143" title="replication/logical/reorderbuffer.c:4143">ReorderBufferChangeSize</a>(change));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process partial change */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L711" title="replication/logical/reorderbuffer.c:711">ReorderBufferProcessPartialChange</a>(rb, txn, change, toast_insert);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the memory limits and evict something if needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3608" title="replication/logical/reorderbuffer.c:3608">ReorderBufferCheckMemoryLimit</a>(rb);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A transactional message is queued to be processed upon commit and a<br/></li>
<li></span><span class="Comment"> * non-transactional message gets processed immediately.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L843">&#x200c;</a></span><span class="linkable">ReorderBufferQueueMessage</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snap, XLogRecPtr lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional, <span class="Type">const</span> <span class="Type">char</span> *prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size message_size, <span class="Type">const</span> <span class="Type">char</span> *message)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (transactional)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(xid != InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't expect snapshots for transactional changes - we'll use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot derived later during apply (unless the change gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * skipped).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!snap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(rb-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = <a href="#L477" title="replication/logical/reorderbuffer.c:477">ReorderBufferGetChange</a>(rb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;action = REORDER_BUFFER_CHANGE_MESSAGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.prefix = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(prefix);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.message_size = message_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.message = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(message_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.msg.message, message, message_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L780" title="replication/logical/reorderbuffer.c:780">ReorderBufferQueueChange</a>(rb, xid, lsn, change, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> Snapshot snapshot_now = snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-transactional changes require a valid snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(snapshot_now);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xid != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, <span class="Constant">NULL</span>, lsn, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* setup snapshot to allow catalog access */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1649" title="utils/time/snapmgr.c:1649">SetupHistoricSnapshot</a>(snapshot_now, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;message(rb, txn, lsn, <span class="Constant">false</span>, prefix, message_size, message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1665" title="utils/time/snapmgr.c:1665">TeardownHistoricSnapshot</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1665" title="utils/time/snapmgr.c:1665">TeardownHistoricSnapshot</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L912" title="replication/logical/reorderbuffer.c:912">AssertTXNLsnOrder</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Verify LSN ordering of transaction lists in the reorderbuffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Other LSN-related invariants are checked too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No-op if assertions are not in use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L912">&#x200c;</a></span><span class="linkable">AssertTXNLsnOrder</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; LogicalDecodingContext *ctx = rb-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prev_first_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prev_base_snap_lsn = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Skip the verification if we don't reach the LSN at which we start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoding the contents of transactions yet because until we reach the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN, we could have transactions that don't have the association between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the top-level transaction and subtransaction yet and consequently have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same LSN.&nbsp; We don't guarantee this association until we try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decode the actual contents of transaction. The ordering of the <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prior to the start_decoding_at LSN should have been checked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="snapbuild.c.html#L433" title="replication/logical/snapbuild.c:433">SnapBuildXactNeedsSkip</a>(ctx-&gt;snapshot_builder, ctx-&gt;reader-&gt;EndRecPtr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;rb-&gt;toplevel_by_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *cur_txn = dlist_container(ReorderBufferTXN, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start LSN must be set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_txn-&gt;first_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there is an end LSN, it must be higher than start LSN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_txn-&gt;end_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_txn-&gt;first_lsn &lt;= cur_txn-&gt;end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Current initial LSN must be strictly higher than previous */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev_first_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(prev_first_lsn &lt; cur_txn-&gt;first_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* known-as-subtxn txns must not be listed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!rbtxn_is_known_subxact(cur_txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_first_lsn = cur_txn-&gt;first_lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;rb-&gt;txns_by_base_snapshot_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *cur_txn = dlist_container(ReorderBufferTXN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_snapshot_node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base snapshot (and its LSN) must be set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_txn-&gt;base_snapshot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_txn-&gt;base_snapshot_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current LSN must be strictly higher than previous */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev_base_snap_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(prev_base_snap_lsn &lt; cur_txn-&gt;base_snapshot_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* known-as-subtxn txns must not be listed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!rbtxn_is_known_subxact(cur_txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_base_snap_lsn = cur_txn-&gt;base_snapshot_lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L983" title="replication/logical/reorderbuffer.c:983">AssertChangeLsnOrder</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check ordering of changes in the (sub)transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L983">&#x200c;</a></span><span class="linkable">AssertChangeLsnOrder</span>(ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prev_lsn = txn-&gt;first_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;txn-&gt;changes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *cur_change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_change = dlist_container(ReorderBufferChange, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;first_lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_change-&gt;lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;first_lsn &lt;= cur_change-&gt;lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;end_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur_change-&gt;lsn &lt;= txn-&gt;end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(prev_lsn &lt;= cur_change-&gt;lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_lsn = cur_change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1014" title="replication/logical/reorderbuffer.c:1014">ReorderBufferGetOldestTXN</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return oldest transaction in reorderbuffer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ReorderBufferTXN *<br/></li>
<li><a id="L1014">&#x200c;</a><span class="linkable">ReorderBufferGetOldestTXN</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L912" title="replication/logical/reorderbuffer.c:912">AssertTXNLsnOrder</a>(rb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;rb-&gt;toplevel_by_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = dlist_head_element(ReorderBufferTXN, node, &amp;rb-&gt;toplevel_by_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!rbtxn_is_known_subxact(txn));<br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;first_lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> txn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1042" title="replication/logical/reorderbuffer.c:1042">ReorderBufferGetOldestXmin</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return oldest Xmin in reorderbuffer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns oldest possibly running Xid from the point of view of snapshots<br/></li>
<li></span><span class="Comment"> * used in the transactions kept by reorderbuffer, or InvalidTransactionId if<br/></li>
<li></span><span class="Comment"> * there are <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since snapshots are assigned monotonically, this equals the Xmin of the<br/></li>
<li></span><span class="Comment"> * base snapshot with minimal base_snapshot_lsn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L1042">&#x200c;</a><span class="linkable">ReorderBufferGetOldestXmin</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L912" title="replication/logical/reorderbuffer.c:912">AssertTXNLsnOrder</a>(rb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;rb-&gt;txns_by_base_snapshot_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = dlist_head_element(ReorderBufferTXN, base_snapshot_node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;rb-&gt;txns_by_base_snapshot_lsn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> txn-&gt;base_snapshot-&gt;xmin;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1057">&#x200c;</a></span><span class="linkable">ReorderBufferSetRestartPoint</span>(ReorderBuffer *rb, XLogRecPtr ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; rb-&gt;current_restart_decoding_lsn = ptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1069" title="replication/logical/reorderbuffer.c:1069">ReorderBufferAssignChild</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Make note that we know that subxid is a subtransaction of xid, seen as of<br/></li>
<li></span><span class="Comment"> * the given lsn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1069">&#x200c;</a></span><span class="linkable">ReorderBufferAssignChild</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId subxid, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *subtxn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; new_top;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; new_sub;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, &amp;new_top, lsn, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; subtxn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, subxid, <span class="Constant">true</span>, &amp;new_sub, lsn, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!new_sub)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_known_subxact(subtxn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already associated, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We already saw this transaction, but initially added it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list of top-level txns.&nbsp; Now that we know it's not top-level,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove it from there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;subtxn-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subtxn-&gt;txn_flags |= RBTXN_IS_SUBXACT;<br/></li>
<li>&nbsp; &nbsp; subtxn-&gt;toplevel_xid = xid;<br/></li>
<li>&nbsp; &nbsp; Assert(subtxn-&gt;nsubtxns == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set the reference to top-level transaction */<br/></li>
<li></span>&nbsp; &nbsp; subtxn-&gt;toptxn = txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add to subtransaction list */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_tail(&amp;txn-&gt;subtxns, &amp;subtxn-&gt;node);<br/></li>
<li>&nbsp; &nbsp; txn-&gt;nsubtxns++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Possibly transfer the subtxn's snapshot to its top-level txn. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1135" title="replication/logical/reorderbuffer.c:1135">ReorderBufferTransferSnapToParent</a>(txn, subtxn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify LSN-ordering invariant */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L912" title="replication/logical/reorderbuffer.c:912">AssertTXNLsnOrder</a>(rb);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1135" title="replication/logical/reorderbuffer.c:1135">ReorderBufferTransferSnapToParent</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transfer base snapshot from subtxn to top-level txn, if needed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is done if the top-level txn doesn't have a base snapshot, or if the<br/></li>
<li></span><span class="Comment"> * subtxn's base snapshot has an earlier LSN than the top-level txn's base<br/></li>
<li></span><span class="Comment"> * snapshot's LSN.&nbsp; This can happen if there are no changes in the toplevel<br/></li>
<li></span><span class="Comment"> * txn but there are some in the subtxn, or the first change in subtxn has<br/></li>
<li></span><span class="Comment"> * earlier LSN than first change in the top-level txn and we learned about<br/></li>
<li></span><span class="Comment"> * their kinship only <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The subtransaction's snapshot is cleared regardless of the transfer<br/></li>
<li></span><span class="Comment"> * happening, since it's not needed anymore in either case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do this as soon as we become aware of their kinship, to avoid queueing<br/></li>
<li></span><span class="Comment"> * extra snapshots to txns known-as-subtxns -- only top-level txns will<br/></li>
<li></span><span class="Comment"> * receive further snapshots.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1135">&#x200c;</a></span><span class="linkable">ReorderBufferTransferSnapToParent</span>(ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *subtxn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(subtxn-&gt;toplevel_xid == txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subtxn-&gt;base_snapshot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;base_snapshot == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtxn-&gt;base_snapshot_lsn &lt; txn-&gt;base_snapshot_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the toplevel transaction already has a base snapshot but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's newer than the subxact's, purge it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;base_snapshot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="snapbuild.c.html#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a>(txn-&gt;base_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;txn-&gt;base_snapshot_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The snapshot is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the top transaction's; transfer it, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjust the list position of the top transaction in the list by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * moving it to where the subtransaction is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;base_snapshot = subtxn-&gt;base_snapshot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;base_snapshot_lsn = subtxn-&gt;base_snapshot_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_insert_before(&amp;subtxn-&gt;base_snapshot_node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;txn-&gt;base_snapshot_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The subtransaction doesn't have a snapshot anymore (so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mustn't be in the list.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtxn-&gt;base_snapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtxn-&gt;base_snapshot_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;subtxn-&gt;base_snapshot_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Base snap of toplevel is fine, so subxact's is not needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="snapbuild.c.html#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a>(subtxn-&gt;base_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;subtxn-&gt;base_snapshot_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtxn-&gt;base_snapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtxn-&gt;base_snapshot_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Associate a subtransaction with its toplevel transaction at commit<br/></li>
<li></span><span class="Comment"> * time. There may be no further changes added after this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1189">&#x200c;</a></span><span class="linkable">ReorderBufferCommitChild</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId subxid, XLogRecPtr commit_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr end_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *subtxn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subtxn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, subxid, <span class="Constant">false</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidXLogRecPtr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need to do anything if that subtxn didn't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!subtxn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; subtxn-&gt;final_lsn = commit_lsn;<br/></li>
<li>&nbsp; &nbsp; subtxn-&gt;end_lsn = end_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assign this subxact as a child of the toplevel xact (no-op if already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1069" title="replication/logical/reorderbuffer.c:1069">ReorderBufferAssignChild</a>(rb, xid, subxid, InvalidXLogRecPtr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support for efficiently iterating over a transaction's and its<br/></li>
<li></span><span class="Comment"> * subtransactions' changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do by doing a k-way <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> between transactions/subtransactions. For that<br/></li>
<li></span><span class="Comment"> * we model the current heads of the different transactions as a binary heap<br/></li>
<li></span><span class="Comment"> * so we easily know which (sub-)transaction has the change with the smallest<br/></li>
<li></span><span class="Comment"> * lsn <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the changes in individual transactions are already sorted by LSN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary heap comparison function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1231">&#x200c;</a></span><span class="linkable">ReorderBufferIterCompare</span>(Datum a, Datum b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *state = (<a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; pos_a = state-&gt;entries[DatumGetInt32(a)].lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; pos_b = state-&gt;entries[DatumGetInt32(b)].lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pos_a &lt; pos_b)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pos_a == pos_b)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate &amp; <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> an iterator which iterates in lsn order over a<br/></li>
<li></span><span class="Comment"> * transaction and all its subtransactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: The iterator state is returned through iter_state parameter rather<br/></li>
<li></span><span class="Comment"> * than the function's return value.&nbsp; This is because the state gets cleaned up<br/></li>
<li></span><span class="Comment"> * in a PG_CATCH block in the caller, so we want to make sure the caller gets<br/></li>
<li></span><span class="Comment"> * back the state even if this function throws an exception.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1254">&#x200c;</a></span><span class="linkable">ReorderBufferIterTXNInit</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *<span class="Type">volatile</span> *iter_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nr_txns = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *state;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; cur_txn_i;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *iter_state = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check ordering of changes in the toplevel transaction. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L983" title="replication/logical/reorderbuffer.c:983">AssertChangeLsnOrder</a>(txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the size of our heap: one <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> for every transaction that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains changes.&nbsp; (Besides the transactions already in the reorder<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer, we count the one we were directly passed.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;nentries &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nr_txns++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(cur_txn_i, &amp;txn-&gt;subtxns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *cur_txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check ordering of changes in this subtransaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L983" title="replication/logical/reorderbuffer.c:983">AssertChangeLsnOrder</a>(cur_txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_txn-&gt;nentries &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nr_txns++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate iteration state */<br/></li>
<li></span>&nbsp; &nbsp; state = (<a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(rb-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L146" title="replication/logical/reorderbuffer.c:146">ReorderBufferIterTXNEntry</a>) * nr_txns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;nr_txns = nr_txns;<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;state-&gt;old_change);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (off = <span class="Constant">0</span>; off &lt; state-&gt;nr_txns; off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].file.<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].segno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate heap */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;heap = binaryheap_allocate(state-&gt;nr_txns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1231" title="replication/logical/reorderbuffer.c:1231">ReorderBufferIterCompare</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now that the state fields are initialized, it is safe to return it. */<br/></li>
<li></span>&nbsp; &nbsp; *iter_state = state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now insert items into the binary heap, in an unordered fashion.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will run a heap assembly step at the end; this is more efficient.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; off = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add toplevel transaction if it contains changes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;nentries &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *cur_change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_serialized(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* serialize remaining changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3681" title="replication/logical/reorderbuffer.c:3681">ReorderBufferSerializeTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4228" title="replication/logical/reorderbuffer.c:4228">ReorderBufferRestoreChanges</a>(rb, txn, &amp;state-&gt;entries[off].file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;entries[off].segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_change = dlist_head_element(ReorderBufferChange, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;txn-&gt;changes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].lsn = cur_change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].change = cur_change;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].txn = txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; binaryheap_add_unordered(state-&gt;heap, Int32GetDatum(off++));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add subtransactions if they contain changes */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(cur_txn_i, &amp;txn-&gt;subtxns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *cur_txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_txn-&gt;nentries &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *cur_change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_serialized(cur_txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* serialize remaining changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3681" title="replication/logical/reorderbuffer.c:3681">ReorderBufferSerializeTXN</a>(rb, cur_txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4228" title="replication/logical/reorderbuffer.c:4228">ReorderBufferRestoreChanges</a>(rb, cur_txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;entries[off].file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;entries[off].segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_change = dlist_head_element(ReorderBufferChange, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;cur_txn-&gt;changes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].lsn = cur_change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].change = cur_change;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].txn = cur_txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_add_unordered(state-&gt;heap, Int32GetDatum(off++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* assemble a valid binary heap */<br/></li>
<li></span>&nbsp; &nbsp; binaryheap_build(state-&gt;heap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> change when iterating over a transaction and its<br/></li>
<li></span><span class="Comment"> * subtransactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL when no further changes exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ReorderBufferChange *<br/></li>
<li><a id="L1382">&#x200c;</a><span class="linkable">ReorderBufferIterTXNNext</span>(ReorderBuffer *rb, <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="replication/logical/reorderbuffer.c:146">ReorderBufferIterTXNEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing there anymore */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;heap-&gt;bh_size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; off = DatumGetInt32(binaryheap_first(state-&gt;heap));<br/></li>
<li>&nbsp; &nbsp; entry = &amp;state-&gt;entries[off];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free memory we might have &quot;leaked&quot; in the previous *Next call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!dlist_is_empty(&amp;state-&gt;old_change))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dlist_pop_head_node(&amp;state-&gt;old_change));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;state-&gt;old_change));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change = entry-&gt;change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update heap with information about which transaction has the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relevant change in LSN order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* there are in-memory changes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_has_next(&amp;entry-&gt;txn-&gt;changes, &amp;entry-&gt;change-&gt;node))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_node *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = dlist_next_node(&amp;entry-&gt;txn-&gt;changes, &amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *next_change =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(ReorderBufferChange, node, <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* txn stays the same */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].lsn = next_change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].change = next_change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; binaryheap_replace_first(state-&gt;heap, Int32GetDatum(off));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> change;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* try to load changes from disk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;txn-&gt;nentries != entry-&gt;txn-&gt;nentries_mem)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ugly: restoring changes will reuse *Change <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, thus delete the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current one from the per-tx list and only free in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_tail(&amp;state-&gt;old_change, &amp;change-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the total bytes processed by the txn for which we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * releasing the current set of changes and restoring the new set of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;totalBytes += entry-&gt;txn-&gt;size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4228" title="replication/logical/reorderbuffer.c:4228">ReorderBufferRestoreChanges</a>(rb, entry-&gt;txn, &amp;entry-&gt;file,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;entries[off].segno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successfully restored changes from disk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *next_change =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_head_element(ReorderBufferChange, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;entry-&gt;txn-&gt;changes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;restored </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> changes from disk&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) entry-&gt;txn-&gt;nentries_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) entry-&gt;txn-&gt;nentries);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(entry-&gt;txn-&gt;nentries_mem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* txn stays the same */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].lsn = next_change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;entries[off].change = next_change;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_replace_first(state-&gt;heap, Int32GetDatum(off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> change;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ok, no changes there anymore, remove */<br/></li>
<li></span>&nbsp; &nbsp; binaryheap_remove_first(state-&gt;heap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> change;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Deallocate the iterator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1474">&#x200c;</a></span><span class="linkable">ReorderBufferIterTXNFinish</span>(ReorderBuffer *rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (off = <span class="Constant">0</span>; off &lt; state-&gt;nr_txns; off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;entries[off].file.<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a> != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(state-&gt;entries[off].file.<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free memory we might have &quot;leaked&quot; in the last *Next call */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!dlist_is_empty(&amp;state-&gt;old_change))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dlist_pop_head_node(&amp;state-&gt;old_change));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(dlist_is_empty(&amp;state-&gt;old_change));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; binaryheap_free(state-&gt;heap);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup the contents of a transaction, usually after the transaction<br/></li>
<li></span><span class="Comment"> * committed or aborted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1505">&#x200c;</a></span><span class="linkable">ReorderBufferCleanupTXN</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> subtransactions &amp; their changes */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;txn-&gt;subtxns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *subtxn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subtxn = dlist_container(ReorderBufferTXN, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subtransactions are always associated to the toplevel TXN, even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they originally were happening inside another subtxn, so we won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ever recurse more than one level deep here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rbtxn_is_known_subxact(subtxn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subtxn-&gt;nsubtxns == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, subtxn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> changes in the txn */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;txn-&gt;changes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check we're not mixing changes from different transactions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;txn == txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cleanup the tuplecids we stored for decoding catalog snapshot access.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * They are always stored in the toplevel transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;txn-&gt;tuplecids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check we're not mixing changes from different transactions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;txn == txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cleanup the base snapshot, if set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;base_snapshot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="snapbuild.c.html#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a>(txn-&gt;base_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;txn-&gt;base_snapshot_node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cleanup the snapshot for the last streamed run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;snapshot_now != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rbtxn_is_streamed(txn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1866" title="replication/logical/reorderbuffer.c:1866">ReorderBufferFreeSnap</a>(rb, txn-&gt;snapshot_now);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove TXN from its containing lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if txn is known as subxact, we are deleting the TXN from its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent's list of known subxacts; this leaves the parent's nsubxacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count too high, but we don't care.&nbsp; Otherwise, we are deleting the TXN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the LSN-ordered list of toplevel TXNs. We remove the TXN from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list of catalog modifying transactions as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_delete(&amp;txn-&gt;node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_has_catalog_changes(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_delete_from(&amp;rb-&gt;catchange_txns, &amp;txn-&gt;catchange_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> remove reference from buffer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(rb-&gt;by_txn, &amp;txn-&gt;xid, HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove entries spilled to disk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_serialized(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4539" title="replication/logical/reorderbuffer.c:4539">ReorderBufferRestoreCleanup</a>(rb, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the memory counter */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, <span class="Constant">NULL</span>, txn, <span class="Constant">false</span>, txn-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deallocate */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L438" title="replication/logical/reorderbuffer.c:438">ReorderBufferReturnTXN</a>(rb, txn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Discard changes from a transaction (and subtransactions), either after<br/></li>
<li></span><span class="Comment"> * streaming or decoding them at PREPARE. Keep the remaining info -<br/></li>
<li></span><span class="Comment"> * transactions, tuplecids, invalidations and snapshots.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We additionally remove tuplecids after decoding the transaction at prepare<br/></li>
<li></span><span class="Comment"> * time as we only need to perform invalidation at rollback or commit prepared.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'txn_prepared' indicates that we have decoded the transaction at prepare<br/></li>
<li></span><span class="Comment"> * time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1616">&#x200c;</a></span><span class="linkable">ReorderBufferTruncateTXN</span>(ReorderBuffer *rb, ReorderBufferTXN *txn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> txn_prepared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> subtransactions &amp; their changes */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;txn-&gt;subtxns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *subtxn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subtxn = dlist_container(ReorderBufferTXN, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subtransactions are always associated to the toplevel TXN, even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they originally were happening inside another subtxn, so we won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ever recurse more than one level deep here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rbtxn_is_known_subxact(subtxn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subtxn-&gt;nsubtxns == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1616" title="replication/logical/reorderbuffer.c:1616">ReorderBufferTruncateTXN</a>(rb, subtxn, txn_prepared);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> changes in the txn */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;txn-&gt;changes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check we're not mixing changes from different transactions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;txn == txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove the change from it's containing list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;change-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the memory counter */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, <span class="Constant">NULL</span>, txn, <span class="Constant">false</span>, txn-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the transaction as streamed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The top-level transaction, is marked as streamed always, even if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does not contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes (that is, when all the changes are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransactions).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For subtransactions, we only mark them as streamed when there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes in them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do it this way because of aborts - we don't want to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> aborts for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XIDs the downstream is not aware of. And of course, it always knows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about the toplevel xact (we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the XID in all messages), but we never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stream XIDs of empty subxacts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((!txn_prepared) &amp;&amp; (rbtxn_is_toptxn(txn) || (txn-&gt;nentries_mem != <span class="Constant">0</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;txn_flags |= RBTXN_IS_STREAMED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn_prepared)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a prepared txn, <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> the tuplecids we stored for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoding catalog snapshot access. They are always stored in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * toplevel transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(iter, &amp;txn-&gt;tuplecids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check we're not mixing changes from different transactions. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;txn == txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove the change from its containing list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;change-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Destroy the (relfilelocator, ctid) hashtable, so that we don't leak <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory. We could also keep the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table and update it with new ctid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, but this seems simpler and good enough for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;tuplecid_hash != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(txn-&gt;tuplecid_hash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;tuplecid_hash = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this txn is serialized then clean the disk space. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_serialized(txn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4539" title="replication/logical/reorderbuffer.c:4539">ReorderBufferRestoreCleanup</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;txn_flags &amp;= ~RBTXN_IS_SERIALIZED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We set this flag to indicate if the transaction is ever serialized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need this to accurately update the stats as otherwise the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction can be counted as serialized multiple times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;txn_flags |= RBTXN_IS_SERIALIZED_CLEAR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* also reset the number of entries in the transaction */<br/></li>
<li></span>&nbsp; &nbsp; txn-&gt;nentries_mem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;nentries = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> with a (relfilelocator, ctid) -&gt; (cmin, cmax) mapping for use by<br/></li>
<li></span><span class="Comment"> * <a href="../../access/heap/heapam_visibility.c.html#L1587" title="access/heap/heapam_visibility.c:1587">HeapTupleSatisfiesHistoricMVCC</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1734">&#x200c;</a></span><span class="linkable">ReorderBufferBuildTupleCidHash</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!rbtxn_has_catalog_changes(txn) || dlist_is_empty(&amp;txn-&gt;tuplecids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L123" title="replication/logical/reorderbuffer.c:123">ReorderBufferTupleCidKey</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = rb-&gt;context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> with the exact number of to-be-stored tuplecids from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; txn-&gt;tuplecid_hash =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;ReorderBufferTupleCid&quot;</span>, txn-&gt;ntuplecids, &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;txn-&gt;tuplecids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/logical/reorderbuffer.c:123">ReorderBufferTupleCidKey</a> key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *ent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be careful about padding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;key, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L123" title="replication/logical/reorderbuffer.c:123">ReorderBufferTupleCidKey</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key.rlocator = change-&gt;data.tuplecid.locator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(&amp;change-&gt;data.tuplecid.tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;key.tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent = (<a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(txn-&gt;tuplecid_hash, &amp;key, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;cmin = change-&gt;data.tuplecid.cmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;cmax = change-&gt;data.tuplecid.cmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;combocid = change-&gt;data.tuplecid.combocid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Maybe we already saw this tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> in this transaction, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if so it must have the same cmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ent-&gt;cmin == change-&gt;data.tuplecid.cmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cmax may be initially invalid, but once set it can only grow,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and never become invalid again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((ent-&gt;cmax == InvalidCommandId) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((change-&gt;data.tuplecid.cmax != InvalidCommandId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (change-&gt;data.tuplecid.cmax &gt; ent-&gt;cmax)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;cmax = change-&gt;data.tuplecid.cmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy a provided snapshot so we can modify it privately. This is needed so<br/></li>
<li></span><span class="Comment"> * that catalog modifying transactions can look into intermediate catalog<br/></li>
<li></span><span class="Comment"> * states.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Snapshot<br/></li>
<li><a id="L1807">&#x200c;</a><span class="linkable">ReorderBufferCopySnap</span>(ReorderBuffer *rb, Snapshot orig_snap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn, CommandId cid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * orig_snap-&gt;xcnt +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * (txn-&gt;nsubtxns + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(rb-&gt;context, size);<br/></li>
<li>&nbsp; &nbsp; memcpy(snap, orig_snap, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snap-&gt;copied = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; snap-&gt;active_count = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark as active so nobody frees it */<br/></li>
<li></span>&nbsp; &nbsp; snap-&gt;regd_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snap-&gt;xip = (TransactionId *) (snap + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(snap-&gt;xip, orig_snap-&gt;xip, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;xcnt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snap-&gt;subxip contains all txids that belong to our transaction which we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to check via cmin/cmax. That's why we store the toplevel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction in there as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snap-&gt;subxip = snap-&gt;xip + snap-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; snap-&gt;subxip[i++] = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subxcnt isn't decreased when subtransactions abort, so count manually.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since it's an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> boundary it is safe to use it for the allocation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snap-&gt;subxcnt = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;txn-&gt;subtxns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *sub_txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_txn = dlist_container(ReorderBufferTXN, node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snap-&gt;subxip[i++] = sub_txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snap-&gt;subxcnt++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort so we can bsearch() later */<br/></li>
<li></span>&nbsp; &nbsp; qsort(snap-&gt;subxip, snap-&gt;subxcnt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store the specified current CommandId */<br/></li>
<li></span>&nbsp; &nbsp; snap-&gt;curcid = cid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a previously <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>'ed snapshot<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1866">&#x200c;</a></span><span class="linkable">ReorderBufferFreeSnap</span>(ReorderBuffer *rb, Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(snap);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="snapbuild.c.html#L457" title="replication/logical/snapbuild.c:457">SnapBuildSnapDecRefcount</a>(snap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the transaction was (partially) streamed, we need to prepare or commit<br/></li>
<li></span><span class="Comment"> * it in a 'streamed' way.&nbsp; That is, we first stream the remaining part of the<br/></li>
<li></span><span class="Comment"> * transaction, and then invoke stream_prepare or stream_commit message as per<br/></li>
<li></span><span class="Comment"> * the case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1881">&#x200c;</a></span><span class="linkable">ReorderBufferStreamCommit</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we should only call this for previously streamed transactions */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rbtxn_is_streamed(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4026" title="replication/logical/reorderbuffer.c:4026">ReorderBufferStreamTXN</a>(rb, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_prepared(txn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note, we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> stream prepare even if a concurrent abort is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detected. See <a href="decode.c.html#L762" title="replication/logical/decode.c:762">DecodePrepare</a> for more information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_prepare(rb, txn, txn-&gt;final_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a PREPARED transaction, part of a two-phase commit. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> will happen as part of the COMMIT PREPAREDs, so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just truncate txn by removing changes and tuplecids.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1616" title="replication/logical/reorderbuffer.c:1616">ReorderBufferTruncateTXN</a>(rb, txn, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_commit(rb, txn, txn-&gt;final_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set xid to detect concurrent aborts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While streaming an in-progress transaction or decoding a prepared<br/></li>
<li></span><span class="Comment"> * transaction there is a possibility that the (sub)transaction might get<br/></li>
<li></span><span class="Comment"> * aborted concurrently.&nbsp; In such case if the (sub)transaction has catalog<br/></li>
<li></span><span class="Comment"> * update then we might decode the tuple using wrong catalog version.&nbsp; For<br/></li>
<li></span><span class="Comment"> * example, suppose there is one catalog tuple with (xmin: 500, xmax: 0).&nbsp; Now,<br/></li>
<li></span><span class="Comment"> * the transaction 501 updates the catalog tuple and after that we will have<br/></li>
<li></span><span class="Comment"> * two tuples (xmin: 500, xmax: 501) and (xmin: 501, xmax: 0).&nbsp; Now, if 501 is<br/></li>
<li></span><span class="Comment"> * aborted and some other transaction say 502 updates the same catalog tuple<br/></li>
<li></span><span class="Comment"> * then the first tuple will be changed to (xmin: 500, xmax: 502).&nbsp; So, the<br/></li>
<li></span><span class="Comment"> * problem is that when we try to decode the tuple inserted/updated in 501<br/></li>
<li></span><span class="Comment"> * after the catalog update, we will see the catalog tuple with (xmin: 500,<br/></li>
<li></span><span class="Comment"> * xmax: 502) as visible because it will consider that the tuple is deleted by<br/></li>
<li></span><span class="Comment"> * xid 502 which is not visible to our snapshot.&nbsp; And when we will try to<br/></li>
<li></span><span class="Comment"> * decode with that catalog tuple, it can lead to a wrong result or a crash.<br/></li>
<li></span><span class="Comment"> * So, it is necessary to detect concurrent aborts to allow streaming of<br/></li>
<li></span><span class="Comment"> * in-progress transactions or decoding of prepared transactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For detecting the concurrent abort we set <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> to the current<br/></li>
<li></span><span class="Comment"> * (sub)transaction's xid for which this change belongs to.&nbsp; And, during<br/></li>
<li></span><span class="Comment"> * catalog scan we can check the status of the xid and if it is aborted we will<br/></li>
<li></span><span class="Comment"> * report a specific error so that we can stop streaming current transaction<br/></li>
<li></span><span class="Comment"> * and discard the already streamed changes on such an error.&nbsp; We might have<br/></li>
<li></span><span class="Comment"> * already streamed some of the changes for the aborted (sub)transaction, but<br/></li>
<li></span><span class="Comment"> * that is fine because when we decode the abort we will stream abort message<br/></li>
<li></span><span class="Comment"> * to truncate the changes in the subscriber. Similarly, for prepared<br/></li>
<li></span><span class="Comment"> * transactions, we stop decoding if concurrent abort is detected and then<br/></li>
<li></span><span class="Comment"> * rollback the changes when rollback prepared is encountered. See<br/></li>
<li></span><span class="Comment"> * <a href="decode.c.html#L762" title="replication/logical/decode.c:762">DecodePrepare</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1945">&#x200c;</a></span><span class="linkable">SetupCheckXidLive</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input transaction id is already set as a <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(<a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a>, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setup <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> if it's not committed yet.&nbsp; We don't check if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xid is aborted.&nbsp; That will happen during catalog access.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> = xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> = InvalidTransactionId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L2080" title="replication/logical/reorderbuffer.c:2080">ReorderBufferProcessTXN</a> for applying change.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1968">&#x200c;</a></span><span class="linkable">ReorderBufferApplyChange</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation relation, ReorderBufferChange *change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> streaming)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_change(rb, txn, relation, change);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;apply_change(rb, txn, relation, change);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L2080" title="replication/logical/reorderbuffer.c:2080">ReorderBufferProcessTXN</a> for applying the truncate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1982">&#x200c;</a></span><span class="linkable">ReorderBufferApplyTruncate</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nrelations, Relation *relations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferChange *change, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> streaming)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_truncate(rb, txn, nrelations, relations, change);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;apply_truncate(rb, txn, nrelations, relations, change);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L2080" title="replication/logical/reorderbuffer.c:2080">ReorderBufferProcessTXN</a> for applying the message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1996">&#x200c;</a></span><span class="linkable">ReorderBufferApplyMessage</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> streaming)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_message(rb, txn, change-&gt;lsn, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; change-&gt;data.msg.prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; change-&gt;data.msg.message_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; change-&gt;data.msg.message);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;message(rb, txn, change-&gt;lsn, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.message_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.message);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Function to store the command id and snapshot at the end of the current<br/></li>
<li></span><span class="Comment"> * stream so that we can reuse the same while sending the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> stream.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L2016">&#x200c;</a></span><span class="linkable">ReorderBufferSaveTXNSnapshot</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Snapshot snapshot_now, CommandId command_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; txn-&gt;command_id = command_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid copying if it's already copied. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot_now-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;snapshot_now = snapshot_now;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;snapshot_now = <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>(rb, snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn, command_id);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L2080" title="replication/logical/reorderbuffer.c:2080">ReorderBufferProcessTXN</a> to handle the concurrent<br/></li>
<li></span><span class="Comment"> * abort of the streaming transaction.&nbsp; This resets the TXN such that it<br/></li>
<li></span><span class="Comment"> * can be used to stream the remaining data of transaction being processed.<br/></li>
<li></span><span class="Comment"> * This can happen when the subtransaction is aborted and we still want to<br/></li>
<li></span><span class="Comment"> * continue processing the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> or other subtransactions data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2037">&#x200c;</a></span><span class="linkable">ReorderBufferResetTXN</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId command_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr last_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *specinsert)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Discard the changes that we just streamed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1616" title="replication/logical/reorderbuffer.c:1616">ReorderBufferTruncateTXN</a>(rb, txn, rbtxn_prepared(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free all resources allocated for toast reconstruction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4953" title="replication/logical/reorderbuffer.c:4953">ReorderBufferToastReset</a>(rb, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the spec insert change if it is not NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (specinsert != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, specinsert, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; specinsert = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the streaming case, stop the stream and remember the command ID and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot for the streaming run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_streamed(txn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_stop(rb, txn, last_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2016" title="replication/logical/reorderbuffer.c:2016">ReorderBufferSaveTXNSnapshot</a>(rb, txn, snapshot_now, command_id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L2650" title="replication/logical/reorderbuffer.c:2650">ReorderBufferReplay</a> and <a href="#L4026" title="replication/logical/reorderbuffer.c:4026">ReorderBufferStreamTXN</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Send data of a transaction (and its subtransactions) to the<br/></li>
<li></span><span class="Comment"> * output plugin. We iterate over the top and subtransactions (using a k-way<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>) and replay the changes in lsn order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If streaming is true then data will be sent using stream API.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: &quot;volatile&quot; markers on some parameters are to avoid trouble with<br/></li>
<li></span><span class="Comment"> * PG_TRY inside the function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2080">&#x200c;</a></span><span class="linkable">ReorderBufferProcessTXN</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> Snapshot snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> CommandId command_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> streaming)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; using_subtxn;<br/></li>
<li>&nbsp; &nbsp; MemoryContext ccxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="replication/logical/reorderbuffer.c:155">ReorderBufferIterTXNState</a> *<span class="Type">volatile</span> iterstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> XLogRecPtr prev_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *<span class="Type">volatile</span> specinsert = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> stream_started = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *<span class="Type">volatile</span> curtxn = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build data to be able to lookup the CommandIds of catalog tuples */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1734" title="replication/logical/reorderbuffer.c:1734">ReorderBufferBuildTupleCidHash</a>(rb, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setup the initial snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1649" title="utils/time/snapmgr.c:1649">SetupHistoricSnapshot</a>(snapshot_now, txn-&gt;tuplecid_hash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decoding needs access to syscaches et al., which in turn use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heavyweight locks and such. Thus we need to have enough state around to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep track of those.&nbsp; The easiest way is to simply use a transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * internally.&nbsp; That also allows us to easily enforce that nothing writes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the database by checking for xid assignments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we're called via the SQL SRF there's already a transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * started, so start an explicit subtransaction there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; using_subtxn = <a href="../../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changes_count = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* used to accumulate the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (using_subtxn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4643" title="access/transam/xact.c:4643">BeginInternalSubTransaction</a>(streaming ? <span class="Constant">&quot;stream&quot;</span> : <span class="Constant">&quot;replay&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> begin/begin-prepare for non-streamed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_prepared(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;begin_prepare(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;begin(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1254" title="replication/logical/reorderbuffer.c:1254">ReorderBufferIterTXNInit</a>(rb, txn, &amp;iterstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((change = <a href="#L1382" title="replication/logical/reorderbuffer.c:1382">ReorderBufferIterTXNNext</a>(rb, iterstate)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't call start stream callback <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> processing first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;origin_id = change-&gt;origin_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_start(rb, txn, change-&gt;lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream_started = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Enforce correct ordering of changes, merged from multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransactions. The changes may have the same LSN due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MULTI_INSERT xlog <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(prev_lsn == InvalidXLogRecPtr || prev_lsn &lt;= change-&gt;lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_lsn = change-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the current xid to detect concurrent aborts. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required for the cases when we decode the changes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * COMMIT record is processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (streaming || rbtxn_prepared(change-&gt;txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curtxn = change-&gt;txn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1945" title="replication/logical/reorderbuffer.c:1945">SetupCheckXidLive</a>(curtxn-&gt;xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (change-&gt;action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Confirmation for speculative insertion arrived. Simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use as a normal record. It'll be cleaned up at the end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of INSERT processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (specinsert == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid ordering of speculative insertion changes&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(specinsert-&gt;data.tp.oldtuple == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change = specinsert;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;action = REORDER_BUFFER_CHANGE_INSERT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* intentionally fall through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(snapshot_now);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid = <a href="../../utils/cache/relfilenumbermap.c.html#L136" title="utils/cache/relfilenumbermap.c:136">RelidByRelfilenumber</a>(change-&gt;data.tp.rlocator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.rlocator.relNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mapped catalog tuple without data, emitted while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog table was in the process of being rewritten. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can fail to look up the relfilenumber, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relmapper has no &quot;historic&quot; view, in contrast to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * normal catalog during decoding. Thus repeated rewrites<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can cause a lookup failure. That's OK because we do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decode catalog changes anyway. Normally such tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be skipped over below, but we can't identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the table should be logically logged without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mapping the relfilenumber to the oid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reloid == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.newtuple == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.oldtuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> change_done;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (reloid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not map filenumber </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to relation OID&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relpathperm(change-&gt;data.tp.rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAIN_FORKNUM));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(reloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsValid(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not open relation with OID </span><span class="Special">%u</span><span class="Constant"> (for filenumber </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relpathperm(change-&gt;data.tp.rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAIN_FORKNUM));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsLogicallyLogged(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> change_done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore temporary heaps created during DDL unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plugin has asked for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relrewrite &amp;&amp; !rb-&gt;output_rewrites)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> change_done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> ignore sequence changes entirely. Most of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time they don't log changes using <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * understand, so it doesn't make sense to handle the few<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases we do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_SEQUENCE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> change_done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* user-triggered change */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/catalog.c.html#L145" title="catalog/catalog.c:145">IsToastRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4762" title="replication/logical/reorderbuffer.c:4762">ReorderBufferToastReplace</a>(rb, txn, relation, change);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1968" title="replication/logical/reorderbuffer.c:1968">ReorderBufferApplyChange</a>(rb, txn, relation, change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only clear reassembled toast chunks if we're sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they're not required anymore. The creator of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple tells us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.tp.clear_toast_afterwards)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4953" title="replication/logical/reorderbuffer.c:4953">ReorderBufferToastReset</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're not interested in toast deletions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (change-&gt;action == REORDER_BUFFER_CHANGE_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need to reassemble the full toasted Datum in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory, to ensure the chunks don't get reused till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're done remove it from the list of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction's changes. Otherwise it will get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * freed/reused while restoring spooled data from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;data.tp.newtuple != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4679" title="replication/logical/reorderbuffer.c:4679">ReorderBufferToastAppendChunk</a>(rb, txn, relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">change_done</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If speculative insertion was confirmed, the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't needed anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (specinsert != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, specinsert, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specinsert = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsValid(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Speculative insertions are dealt with by delaying the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing of the insert until the confirmation record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrives. For that we simply unlink the record from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chain, so it does not get freed/reused while restoring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spooled data from disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is safe in the face of concurrent catalog changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the relevant relation can't be changed between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * speculative insertion and confirmation due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/tablecmds.c.html#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>() and locking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clear out a pending (and thus failed) speculation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (specinsert != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, specinsert, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specinsert = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and memorize the pending insertion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specinsert = change;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abort for speculative insertion arrived. So <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specinsert tuple and toast <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we get the spec abort change for each toast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry but we need to perform the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> only the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time we get it for the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (specinsert != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must clean the toast <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> processing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completely new tuple to avoid confusion about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous tuple's toast chunks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;data.tp.clear_toast_afterwards);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4953" title="replication/logical/reorderbuffer.c:4953">ReorderBufferToastReset</a>(rb, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't need this record anymore. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, specinsert, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specinsert = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrelids = change-&gt;data.truncate.nrelids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrelations = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp;&nbsp; *relations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relations = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nrelids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrelids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = change-&gt;data.truncate.relids[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsValid(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not open relation with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsLogicallyLogged(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relations[nrelations++] = rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply the truncate. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1982" title="replication/logical/reorderbuffer.c:1982">ReorderBufferApplyTruncate</a>(rb, txn, nrelations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relations, change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrelations; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(relations[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_MESSAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1996" title="replication/logical/reorderbuffer.c:1996">ReorderBufferApplyMessage</a>(rb, txn, change, streaming);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INVALIDATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Execute the invalidation messages locally */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3359" title="replication/logical/reorderbuffer.c:3359">ReorderBufferExecuteInvalidations</a>(change-&gt;data.inval.ninvalidations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.inval.invalidations);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get rid of the old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1665" title="utils/time/snapmgr.c:1665">TeardownHistoricSnapshot</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot_now-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1866" title="replication/logical/reorderbuffer.c:1866">ReorderBufferFreeSnap</a>(rb, snapshot_now);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_now =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>(rb, change-&gt;data.snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn, command_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Restored from disk, need to be careful not to double<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free. We could introduce refcounting for that, but for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> this seems infrequent enough not to care.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (change-&gt;data.snapshot-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_now =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>(rb, change-&gt;data.snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn, command_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_now = change-&gt;data.snapshot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and continue with the new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1649" title="utils/time/snapmgr.c:1649">SetupHistoricSnapshot</a>(snapshot_now, txn-&gt;tuplecid_hash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;data.command_id != InvalidCommandId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (command_id &lt; change-&gt;data.command_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command_id = change-&gt;data.command_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!snapshot_now-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't use the global one anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_now = <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>(rb, snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txn, command_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_now-&gt;curcid = command_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1665" title="utils/time/snapmgr.c:1665">TeardownHistoricSnapshot</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1649" title="utils/time/snapmgr.c:1649">SetupHistoricSnapshot</a>(snapshot_now, txn-&gt;tuplecid_hash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuplecid value in changequeue&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is possible that the data is not sent to downstream for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * long time either because the output plugin filtered it or there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a DDL that generates a lot of data that is not processed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the plugin. So, in such cases, the downstream can timeout. To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid that we try to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a keepalive message if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Trying to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a keepalive message after every change has some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overhead, but testing showed there is no noticeable overhead if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we do it after every ~100 changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L2468">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CHANGES_THRESHOLD</span> </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++changes_count &gt;= <a href="#L2468" title="replication/logical/reorderbuffer.c:2468">CHANGES_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;update_progress_txn(rb, txn, change-&gt;lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; changes_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* speculative insertion record must be freed by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!specinsert);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clean up the iterator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="replication/logical/reorderbuffer.c:1474">ReorderBufferIterTXNFinish</a>(rb, iterstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iterstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update total transaction count and total bytes processed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction and its subtransactions. Ensure to not count the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * streamed transaction multiple times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that the statistics computation has to be done after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1474" title="replication/logical/reorderbuffer.c:1474">ReorderBufferIterTXNFinish</a> as it releases the serialized change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which we have already accounted in <a href="#L1382" title="replication/logical/reorderbuffer.c:1382">ReorderBufferIterTXNNext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rbtxn_is_streamed(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;totalTxns++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;totalBytes += txn-&gt;total_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done with current changes, <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the last message for this set of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes depending upon streaming mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stream_started)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_stop(rb, txn, prev_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stream_started = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Call either PREPARE (for two-phase transactions) or COMMIT (for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regular ones).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_prepared(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;prepare(rb, txn, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;commit(rb, txn, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this is just a sanity check against bad output plugin behaviour */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L468" title="access/transam/xact.c:468">GetCurrentTransactionIdIfAny</a>() != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;output plugin used XID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the command ID and snapshot for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set of changes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * streaming mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2016" title="replication/logical/reorderbuffer.c:2016">ReorderBufferSaveTXNSnapshot</a>(rb, txn, snapshot_now, command_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (snapshot_now-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1866" title="replication/logical/reorderbuffer.c:1866">ReorderBufferFreeSnap</a>(rb, snapshot_now);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1665" title="utils/time/snapmgr.c:1665">TeardownHistoricSnapshot</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Aborting the current (sub-)transaction as a whole has the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * semantics. We want all locks acquired in here to be released, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reassigned to the parent and we do not want <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> database access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have persistent effects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure there's no cache pollution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3359" title="replication/logical/reorderbuffer.c:3359">ReorderBufferExecuteInvalidations</a>(txn-&gt;ninvalidations, txn-&gt;invalidations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (using_subtxn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4745" title="access/transam/xact.c:4745">RollbackAndReleaseCurrentSubTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are here due to one of the four reasons: 1. Decoding an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in-progress txn. 2. Decoding a prepared txn. 3. Decoding of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepared txn that was (partially) streamed. 4. Decoding a committed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * txn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For 1, we allow truncation of txn data by removing the changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already streamed but still keeping other things like invalidations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot, and tuplecids. For 2 and 3, we indicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1616" title="replication/logical/reorderbuffer.c:1616">ReorderBufferTruncateTXN</a> to do more elaborate truncation of txn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data as the entire transaction has been decoded except for commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For 4, as the entire txn has been decoded, we can fully clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the TXN reorder buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (streaming || rbtxn_prepared(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1616" title="replication/logical/reorderbuffer.c:1616">ReorderBufferTruncateTXN</a>(rb, txn, rbtxn_prepared(txn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext ecxt = MemoryContextSwitchTo(ccxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ErrorData&nbsp; *errdata = <a href="../../utils/error/elog.c.html#L1731" title="utils/error/elog.c:1731">CopyErrorData</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">TODO</span><span class="Comment">: Encapsulate <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> from the PG_TRY and PG_CATCH blocks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iterstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="replication/logical/reorderbuffer.c:1474">ReorderBufferIterTXNFinish</a>(rb, iterstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1665" title="utils/time/snapmgr.c:1665">TeardownHistoricSnapshot</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force cache invalidation to happen outside of a valid transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to prevent catalog access as we just caught an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure there's no cache pollution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3359" title="replication/logical/reorderbuffer.c:3359">ReorderBufferExecuteInvalidations</a>(txn-&gt;ninvalidations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;invalidations);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (using_subtxn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4745" title="access/transam/xact.c:4745">RollbackAndReleaseCurrentSubTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The error code ERRCODE_TRANSACTION_ROLLBACK indicates a concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort of the (sub)transaction we are streaming or preparing. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to do the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> and return gracefully on this error, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1945" title="replication/logical/reorderbuffer.c:1945">SetupCheckXidLive</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This error code can be thrown by one of the callbacks we call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during decoding so we need to ensure that we return gracefully only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we are sending the data in streaming mode and the streaming is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not finished yet or when we are sending the data out on a PREPARE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during a two-phase commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errdata-&gt;sqlerrcode == ERRCODE_TRANSACTION_ROLLBACK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (stream_started || rbtxn_prepared(txn)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* curtxn must be set for streaming or prepared transactions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(curtxn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cleanup the temporary error state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1787" title="utils/error/elog.c:1787">FreeErrorData</a>(errdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errdata = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curtxn-&gt;concurrent_abort = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the TXN so that it is allowed to stream remaining data. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2037" title="replication/logical/reorderbuffer.c:2037">ReorderBufferResetTXN</a>(rb, txn, snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command_id, prev_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; specinsert);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(ecxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform the replay of a transaction and its non-aborted subtransactions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Subtransactions previously have to be processed by<br/></li>
<li></span><span class="Comment"> * <a href="#L1189" title="replication/logical/reorderbuffer.c:1189">ReorderBufferCommitChild</a>(), even if previously assigned to the toplevel<br/></li>
<li></span><span class="Comment"> * transaction with <a href="#L1069" title="replication/logical/reorderbuffer.c:1069">ReorderBufferAssignChild</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This interface is called once a prepare or toplevel commit is read for both<br/></li>
<li></span><span class="Comment"> * streamed as well as non-streamed transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2650">&#x200c;</a></span><span class="linkable">ReorderBufferReplay</span>(ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn, XLogRecPtr end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz commit_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RepOriginId origin_id, XLogRecPtr origin_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot_now;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; command_id = FirstCommandId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn-&gt;final_lsn = commit_lsn;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;end_lsn = end_lsn;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;xact_time.commit_time = commit_time;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;origin_id = origin_id;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;origin_lsn = origin_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the transaction was (partially) streamed, we need to commit it in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'streamed' way. That is, we first stream the remaining part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, and then invoke stream_commit message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Called after everything (origin ID, LSN, ...) is stored in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction to avoid passing that information directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_streamed(txn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1881" title="replication/logical/reorderbuffer.c:1881">ReorderBufferStreamCommit</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this transaction has no snapshot, it didn't make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database, so there's nothing to decode.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1189" title="replication/logical/reorderbuffer.c:1189">ReorderBufferCommitChild</a> will have transferred <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshots from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransactions if there were <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;base_snapshot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;ninvalidations == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Removing this txn <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> a commit might result in the computation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of an incorrect restart_lsn. See <a href="snapbuild.c.html#L1217" title="replication/logical/snapbuild.c:1217">SnapBuildProcessRunningXacts</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rbtxn_prepared(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot_now = txn-&gt;base_snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the changes to output plugin. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2080" title="replication/logical/reorderbuffer.c:2080">ReorderBufferProcessTXN</a>(rb, txn, commit_lsn, snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command_id, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Commit a transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="#L2650" title="replication/logical/reorderbuffer.c:2650">ReorderBufferReplay</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2711">&#x200c;</a></span><span class="linkable">ReorderBufferCommit</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn, XLogRecPtr end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz commit_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RepOriginId origin_id, XLogRecPtr origin_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown transaction, nothing to replay */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2650" title="replication/logical/reorderbuffer.c:2650">ReorderBufferReplay</a>(txn, rb, xid, commit_lsn, end_lsn, commit_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origin_id, origin_lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the prepare information for a transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2733">&#x200c;</a></span><span class="linkable">ReorderBufferRememberPrepareInfo</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_lsn, XLogRecPtr end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz prepare_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RepOriginId origin_id, XLogRecPtr origin_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown transaction, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the prepare information to be later used by commit prepared in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing prepare.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; txn-&gt;final_lsn = prepare_lsn;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;end_lsn = end_lsn;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;xact_time.prepare_time = prepare_time;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;origin_id = origin_id;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;origin_lsn = origin_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Remember that we have skipped prepare */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2761">&#x200c;</a></span><span class="linkable">ReorderBufferSkipPrepare</span>(ReorderBuffer *rb, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown transaction, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn-&gt;txn_flags |= RBTXN_SKIPPED_PREPARE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare a two-phase transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See comments for <a href="#L2650" title="replication/logical/reorderbuffer.c:2650">ReorderBufferReplay</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2780">&#x200c;</a></span><span class="linkable">ReorderBufferPrepare</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *gid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown transaction, nothing to replay */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn-&gt;txn_flags |= RBTXN_PREPARE;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;gid = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The prepare info must have been updated in txn by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(txn-&gt;final_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2650" title="replication/logical/reorderbuffer.c:2650">ReorderBufferReplay</a>(txn, rb, xid, txn-&gt;final_lsn, txn-&gt;end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;xact_time.prepare_time, txn-&gt;origin_id, txn-&gt;origin_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the prepare for the concurrently aborted xacts so that later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when rollback prepared is decoded and sent, the downstream should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to rollback such a xact. See comments atop <a href="decode.c.html#L762" title="replication/logical/decode.c:762">DecodePrepare</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note, for the concurrent_abort + streaming case a stream_prepare was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already sent within the <a href="#L2650" title="replication/logical/reorderbuffer.c:2650">ReorderBufferReplay</a> call above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;concurrent_abort &amp;&amp; !rbtxn_is_streamed(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;prepare(rb, txn, txn-&gt;final_lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is used to handle COMMIT/ROLLBACK PREPARED.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2817">&#x200c;</a></span><span class="linkable">ReorderBufferFinishPrepared</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn, XLogRecPtr end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr two_phase_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz commit_time, RepOriginId origin_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr origin_lsn, <span class="Type">char</span> *gid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_commit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prepare_end_lsn;<br/></li>
<li>&nbsp; &nbsp; TimestampTz prepare_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, commit_lsn, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown transaction, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By this time the txn has the prepare record information, remember it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be later used for rollback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prepare_end_lsn = txn-&gt;end_lsn;<br/></li>
<li>&nbsp; &nbsp; prepare_time = txn-&gt;xact_time.prepare_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add the gid in the txn */<br/></li>
<li></span>&nbsp; &nbsp; txn-&gt;gid = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is possible that this transaction is not decoded at prepare time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either because by that time we didn't have a consistent snapshot, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * two_phase was not enabled, or it was decoded earlier but we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restarted. We only need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the prepare if it was not decoded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earlier. We don't need to decode the xact for aborts if it is not done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((txn-&gt;final_lsn &lt; two_phase_at) &amp;&amp; is_commit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;txn_flags |= RBTXN_PREPARE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The prepare info must have been updated in txn even if we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepare.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;final_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By this time the txn has the prepare record information and it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important to use that so that downstream gets the accurate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information. If instead, we have passed commit information here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then downstream can behave as it has already replayed commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepared after the restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2650" title="replication/logical/reorderbuffer.c:2650">ReorderBufferReplay</a>(txn, rb, xid, txn-&gt;final_lsn, txn-&gt;end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;xact_time.prepare_time, txn-&gt;origin_id, txn-&gt;origin_lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn-&gt;final_lsn = commit_lsn;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;end_lsn = end_lsn;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;xact_time.commit_time = commit_time;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;origin_id = origin_id;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;origin_lsn = origin_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_commit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;commit_prepared(rb, txn, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;rollback_prepared(rb, txn, prepare_end_lsn, prepare_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>: make sure there's no cache pollution */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3359" title="replication/logical/reorderbuffer.c:3359">ReorderBufferExecuteInvalidations</a>(txn-&gt;ninvalidations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;invalidations);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abort a transaction that possibly has previous changes. Needs to be first<br/></li>
<li></span><span class="Comment"> * called for subtransactions and then for the toplevel xid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Transactions handled here have to have actively aborted (i.e. have<br/></li>
<li></span><span class="Comment"> * produced an abort record). Implicitly aborted transactions are handled via<br/></li>
<li></span><span class="Comment"> * <a href="#L2947" title="replication/logical/reorderbuffer.c:2947">ReorderBufferAbortOld</a>(); transactions we're just not interested in, but<br/></li>
<li></span><span class="Comment"> * which have committed are handled in <a href="#L2994" title="replication/logical/reorderbuffer.c:2994">ReorderBufferForget</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function purges this transaction and its contents from memory and<br/></li>
<li></span><span class="Comment"> * disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2902">&#x200c;</a></span><span class="linkable">ReorderBufferAbort</span>(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz abort_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown, nothing to remove */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn-&gt;xact_time.abort_time = abort_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For streamed transactions notify the remote node about the abort. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_streamed(txn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_abort(rb, txn, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might have decoded changes for this transaction that could load<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cache as per the current transaction's view (consider DDL's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happened in this transaction). We don't want the decoding of future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions to use those cache entries so execute invalidations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;ninvalidations &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3066" title="replication/logical/reorderbuffer.c:3066">ReorderBufferImmediateInvalidation</a>(rb, txn-&gt;ninvalidations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txn-&gt;invalidations);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cosmetic... */<br/></li>
<li></span>&nbsp; &nbsp; txn-&gt;final_lsn = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove potential on-disk data, and deallocate */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abort all transactions that aren't actually running anymore because the<br/></li>
<li></span><span class="Comment"> * server restarted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: These really have to be transactions that have aborted due to a server<br/></li>
<li></span><span class="Comment"> * crash/immediate restart, as we don't deal with invalidations here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2947">&#x200c;</a></span><span class="linkable">ReorderBufferAbortOld</span>(ReorderBuffer *rb, TransactionId oldestRunningXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter it;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate through all (potential) toplevel TXNs and abort all that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * older than what possibly can be running. Once we've found the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that is alive we stop, there might be some that acquired an xid earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but started writing later, but it's unlikely and they will be cleaned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up in a later call to this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(it, &amp;rb-&gt;toplevel_by_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = dlist_container(ReorderBufferTXN, node, it.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(txn-&gt;xid, oldestRunningXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;aborting old transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Notify the remote node about the crash/immediate restart. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_streamed(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;stream_abort(rb, txn, InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove potential on-disk data, and deallocate this tx */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Forget the contents of a transaction if we aren't interested in its<br/></li>
<li></span><span class="Comment"> * contents. Needs to be first called for subtransactions and then for the<br/></li>
<li></span><span class="Comment"> * toplevel xid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is significantly different to <a href="#L2902" title="replication/logical/reorderbuffer.c:2902">ReorderBufferAbort</a>() because<br/></li>
<li></span><span class="Comment"> * transactions that have committed need to be treated differently from aborted<br/></li>
<li></span><span class="Comment"> * ones since they may have modified the catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this is only allowed to be called in the moment a transaction<br/></li>
<li></span><span class="Comment"> * commit has just been read, not earlier; otherwise later <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> referring<br/></li>
<li></span><span class="Comment"> * to this xid might re-create the transaction incompletely.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2994">&#x200c;</a></span><span class="linkable">ReorderBufferForget</span>(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown, nothing to forget */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this transaction mustn't be streamed */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!rbtxn_is_streamed(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cosmetic... */<br/></li>
<li></span>&nbsp; &nbsp; txn-&gt;final_lsn = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process cache invalidation messages if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. Even if we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interested in the transaction's contents, it could have manipulated the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog and we need to update the caches according to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;base_snapshot != <span class="Constant">NULL</span> &amp;&amp; txn-&gt;ninvalidations &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3066" title="replication/logical/reorderbuffer.c:3066">ReorderBufferImmediateInvalidation</a>(rb, txn-&gt;ninvalidations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txn-&gt;invalidations);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;ninvalidations == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove potential on-disk data, and deallocate */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1505" title="replication/logical/reorderbuffer.c:1505">ReorderBufferCleanupTXN</a>(rb, txn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Invalidate cache for those transactions that need to be skipped just in case<br/></li>
<li></span><span class="Comment"> * catalogs were manipulated as part of the transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this is a special-purpose function for prepared transactions where<br/></li>
<li></span><span class="Comment"> * we don't want to clean up the TXN even when we decide to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it. See<br/></li>
<li></span><span class="Comment"> * <a href="decode.c.html#L762" title="replication/logical/decode.c:762">DecodePrepare</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3035">&#x200c;</a></span><span class="linkable">ReorderBufferInvalidate</span>(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* unknown, nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process cache invalidation messages if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. Even if we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interested in the transaction's contents, it could have manipulated the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog and we need to update the caches according to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;base_snapshot != <span class="Constant">NULL</span> &amp;&amp; txn-&gt;ninvalidations &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3066" title="replication/logical/reorderbuffer.c:3066">ReorderBufferImmediateInvalidation</a>(rb, txn-&gt;ninvalidations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txn-&gt;invalidations);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;ninvalidations == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute invalidations happening outside the context of a decoded<br/></li>
<li></span><span class="Comment"> * transaction. That currently happens either for xid-less commits<br/></li>
<li></span><span class="Comment"> * (cf. <a href="../../access/transam/xact.c.html#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a>()) or for invalidations in uninteresting<br/></li>
<li></span><span class="Comment"> * transactions (via <a href="#L2994" title="replication/logical/reorderbuffer.c:2994">ReorderBufferForget</a>()).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3066">&#x200c;</a></span><span class="linkable">ReorderBufferImmediateInvalidation</span>(ReorderBuffer *rb, uint32 ninvalidations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SharedInvalidationMessage *invalidations)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_subtxn = <a href="../../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_subtxn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4643" title="access/transam/xact.c:4643">BeginInternalSubTransaction</a>(<span class="Constant">&quot;replay&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force invalidations to happen outside of a valid transaction - that way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries will just be marked as invalid without accessing the catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's advantageous because we don't need to setup the full state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary for catalog access.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_subtxn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ninvalidations; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L705" title="utils/cache/inval.c:705">LocalExecuteInvalidationMessage</a>(&amp;invalidations[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_subtxn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4745" title="access/transam/xact.c:4745">RollbackAndReleaseCurrentSubTransaction</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tell reorderbuffer about an xid seen in the WAL stream. Has to be called at<br/></li>
<li></span><span class="Comment"> * least once for every xid in XLogRecord-&gt;xl_xid (other places in <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> * may, but do not have to be passed through here).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reorderbuffer keeps some data structures about transactions in LSN order,<br/></li>
<li></span><span class="Comment"> * for efficiency. To do that it has to know about when transactions are seen<br/></li>
<li></span><span class="Comment"> * first in the WAL. As many types of <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are not actually interesting for<br/></li>
<li></span><span class="Comment"> * logical decoding, they do not necessarily pass through here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3102">&#x200c;</a></span><span class="linkable">ReorderBufferProcessXid</span>(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* many <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> won't have an xid assigned, centralize check here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xid != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, <span class="Constant">NULL</span>, lsn, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a new snapshot to this transaction that may only used after lsn 'lsn'<br/></li>
<li></span><span class="Comment"> * because the previous snapshot doesn't describe the catalog correctly for<br/></li>
<li></span><span class="Comment"> * following rows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3115">&#x200c;</a></span><span class="linkable">ReorderBufferAddSnapshot</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change = <a href="#L477" title="replication/logical/reorderbuffer.c:477">ReorderBufferGetChange</a>(rb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change-&gt;data.snapshot = snap;<br/></li>
<li>&nbsp; &nbsp; change-&gt;action = REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L780" title="replication/logical/reorderbuffer.c:780">ReorderBufferQueueChange</a>(rb, xid, lsn, change, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up the transaction's base snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we know that xid is a subtransaction, set the base snapshot on the<br/></li>
<li></span><span class="Comment"> * top-level transaction instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3133">&#x200c;</a></span><span class="linkable">ReorderBufferSetBaseSnapshot</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_new;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snap != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch the transaction to operate on.&nbsp; If we know it's a subtransaction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operate on its top-level transaction instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, &amp;is_new, lsn, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_known_subxact(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, txn-&gt;toplevel_xid, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, InvalidXLogRecPtr, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;base_snapshot == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn-&gt;base_snapshot = snap;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;base_snapshot_lsn = lsn;<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;rb-&gt;txns_by_base_snapshot_lsn, &amp;txn-&gt;base_snapshot_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L912" title="replication/logical/reorderbuffer.c:912">AssertTXNLsnOrder</a>(rb);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Access the catalog with this CommandId at this point in the changestream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * May only be called for command ids &gt; 1<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3164">&#x200c;</a></span><span class="linkable">ReorderBufferAddNewCommandId</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, CommandId cid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change = <a href="#L477" title="replication/logical/reorderbuffer.c:477">ReorderBufferGetChange</a>(rb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change-&gt;data.command_id = cid;<br/></li>
<li>&nbsp; &nbsp; change-&gt;action = REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L780" title="replication/logical/reorderbuffer.c:780">ReorderBufferQueueChange</a>(rb, xid, lsn, change, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update memory counters to account for the new or removed change.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We update two counters - in the reorder buffer, and in the transaction<br/></li>
<li></span><span class="Comment"> * containing the change. The reorder buffer counter allows us to quickly<br/></li>
<li></span><span class="Comment"> * decide if we reached the memory limit, the transaction counter allows<br/></li>
<li></span><span class="Comment"> * us to quickly pick the largest transaction for eviction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Either txn or change must be non-NULL at least. We update the memory<br/></li>
<li></span><span class="Comment"> * counter of txn if it's non-NULL, otherwise change-&gt;txn.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When streaming is enabled, we need to update the toplevel transaction<br/></li>
<li></span><span class="Comment"> * counters instead - we don't really care about subtransactions as we<br/></li>
<li></span><span class="Comment"> * can't stream them individually anyway, and we only pick toplevel<br/></li>
<li></span><span class="Comment"> * transactions for eviction. So only toplevel transactions matter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3192">&#x200c;</a></span><span class="linkable">ReorderBufferChangeMemoryUpdate</span>(ReorderBuffer *rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> addition, Size sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *toptxn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(txn || change);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore tuple CID changes, because those are not evicted when reaching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory limit. So we just don't count them, because it might easily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a pointless attempt to spill.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (change &amp;&amp; change-&gt;action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sz == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = change-&gt;txn;<br/></li>
<li>&nbsp; &nbsp; Assert(txn != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the total size in top level as well. This is later used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compute the decoding stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; toptxn = rbtxn_get_toptxn(txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (addition)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; oldsize = txn-&gt;size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;size += sz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;size += sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the total size in the top transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;total_size += sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the max-heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldsize != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L170" title="lib/pairingheap.c:170">pairingheap_remove</a>(rb-&gt;txn_heap, &amp;txn-&gt;txn_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L112" title="lib/pairingheap.c:112">pairingheap_add</a>(rb-&gt;txn_heap, &amp;txn-&gt;txn_node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((rb-&gt;size &gt;= sz) &amp;&amp; (txn-&gt;size &gt;= sz));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;size -= sz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;size -= sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the total size in the top transaction. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;total_size -= sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the max-heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L170" title="lib/pairingheap.c:170">pairingheap_remove</a>(rb-&gt;txn_heap, &amp;txn-&gt;txn_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;size != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L112" title="lib/pairingheap.c:112">pairingheap_add</a>(rb-&gt;txn_heap, &amp;txn-&gt;txn_node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;size &lt;= rb-&gt;size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add new (relfilelocator, tid) -&gt; (cmin, cmax) mappings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not include this change type in memory accounting, because we<br/></li>
<li></span><span class="Comment"> * keep CIDs in a separate list and do not evict them when reaching<br/></li>
<li></span><span class="Comment"> * the memory limit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3263">&#x200c;</a></span><span class="linkable">ReorderBufferAddNewTupleCids</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, RelFileLocator locator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerData tid, CommandId cmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CommandId cmax, CommandId combocid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change = <a href="#L477" title="replication/logical/reorderbuffer.c:477">ReorderBufferGetChange</a>(rb);<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, <span class="Constant">NULL</span>, lsn, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change-&gt;data.tuplecid.locator = locator;<br/></li>
<li>&nbsp; &nbsp; change-&gt;data.tuplecid.tid = tid;<br/></li>
<li>&nbsp; &nbsp; change-&gt;data.tuplecid.cmin = cmin;<br/></li>
<li>&nbsp; &nbsp; change-&gt;data.tuplecid.cmax = cmax;<br/></li>
<li>&nbsp; &nbsp; change-&gt;data.tuplecid.combocid = combocid;<br/></li>
<li>&nbsp; &nbsp; change-&gt;lsn = lsn;<br/></li>
<li>&nbsp; &nbsp; change-&gt;txn = txn;<br/></li>
<li>&nbsp; &nbsp; change-&gt;action = REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;txn-&gt;tuplecids, &amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; txn-&gt;ntuplecids++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accumulate the invalidations for executing them later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This needs to be called for each XLOG_XACT_INVALIDATIONS message and<br/></li>
<li></span><span class="Comment"> * accumulates all the invalidation messages in the toplevel transaction, if<br/></li>
<li></span><span class="Comment"> * available, otherwise in the current transaction, as well as in the form of<br/></li>
<li></span><span class="Comment"> * change in reorder buffer.&nbsp; We require to record it in form of the change<br/></li>
<li></span><span class="Comment"> * so that we can execute only the required invalidations instead of executing<br/></li>
<li></span><span class="Comment"> * all the invalidations on each CommandId increment.&nbsp; We also need to<br/></li>
<li></span><span class="Comment"> * accumulate these in the txn buffer because in some cases where we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment"> * processing the transaction (see <a href="#L2994" title="replication/logical/reorderbuffer.c:2994">ReorderBufferForget</a>), we need to execute<br/></li>
<li></span><span class="Comment"> * all the invalidations together.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3300">&#x200c;</a></span><span class="linkable">ReorderBufferAddInvalidations</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr lsn, Size nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SharedInvalidationMessage *msgs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, <span class="Constant">NULL</span>, lsn, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(rb-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect all the invalidations under the top transaction, if available,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that we can execute them all together.&nbsp; See comments atop this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; txn = rbtxn_get_toptxn(txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nmsgs &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate invalidations. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;ninvalidations == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;ninvalidations = nmsgs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;invalidations = (SharedInvalidationMessage *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) * nmsgs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(txn-&gt;invalidations, msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) * nmsgs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;invalidations = (SharedInvalidationMessage *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(txn-&gt;invalidations, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (txn-&gt;ninvalidations + nmsgs));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(txn-&gt;invalidations + txn-&gt;ninvalidations, msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmsgs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;ninvalidations += nmsgs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change = <a href="#L477" title="replication/logical/reorderbuffer.c:477">ReorderBufferGetChange</a>(rb);<br/></li>
<li>&nbsp; &nbsp; change-&gt;action = REORDER_BUFFER_CHANGE_INVALIDATION;<br/></li>
<li>&nbsp; &nbsp; change-&gt;data.inval.ninvalidations = nmsgs;<br/></li>
<li>&nbsp; &nbsp; change-&gt;data.inval.invalidations = (SharedInvalidationMessage *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) * nmsgs);<br/></li>
<li>&nbsp; &nbsp; memcpy(change-&gt;data.inval.invalidations, msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) * nmsgs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L780" title="replication/logical/reorderbuffer.c:780">ReorderBufferQueueChange</a>(rb, xid, lsn, change, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Apply all invalidations we know. Possibly we only need parts at this point<br/></li>
<li></span><span class="Comment"> * in the changestream but we don't know which those are.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3359">&#x200c;</a></span><span class="linkable">ReorderBufferExecuteInvalidations</span>(uint32 nmsgs, SharedInvalidationMessage *msgs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmsgs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L705" title="utils/cache/inval.c:705">LocalExecuteInvalidationMessage</a>(&amp;msgs[i]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark a transaction as containing catalog changes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3371">&#x200c;</a></span><span class="linkable">ReorderBufferXidSetCatalogChanges</span>(ReorderBuffer *rb, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">true</span>, <span class="Constant">NULL</span>, lsn, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!rbtxn_has_catalog_changes(txn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;txn_flags |= RBTXN_HAS_CATALOG_CHANGES;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_push_tail(&amp;rb-&gt;catchange_txns, &amp;txn-&gt;catchange_node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark top-level transaction as having catalog changes too if one of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * children has so that the <a href="#L1734" title="replication/logical/reorderbuffer.c:1734">ReorderBufferBuildTupleCidHash</a> can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conveniently check just top-level transaction and decide whether to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_subtxn(txn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *toptxn = rbtxn_get_toptxn(txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rbtxn_has_catalog_changes(toptxn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toptxn-&gt;txn_flags |= RBTXN_HAS_CATALOG_CHANGES;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_push_tail(&amp;rb-&gt;catchange_txns, &amp;toptxn-&gt;catchange_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ed array of the transactions that have changed catalogs.<br/></li>
<li></span><span class="Comment"> * The returned array is sorted in <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a> order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must free the returned array when done with it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId *<br/></li>
<li><a id="L3409">&#x200c;</a><span class="linkable">ReorderBufferGetCatalogChangesXacts</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; TransactionId *xids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; xcnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick return if the list is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dclist_count(&amp;rb-&gt;catchange_txns) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize XID array */<br/></li>
<li></span>&nbsp; &nbsp; xids = (TransactionId *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_count(&amp;rb-&gt;catchange_txns));<br/></li>
<li>&nbsp; &nbsp; dclist_foreach(iter, &amp;rb-&gt;catchange_txns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn = dclist_container(ReorderBufferTXN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; catchange_node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rbtxn_has_catalog_changes(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xids[xcnt++] = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qsort(xids, xcnt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(xcnt == dclist_count(&amp;rb-&gt;catchange_txns));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Query whether a transaction is already *known* to contain catalog<br/></li>
<li></span><span class="Comment"> * changes. This can be wrong until directly <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the commit!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3444">&#x200c;</a></span><span class="linkable">ReorderBufferXidHasCatalogChanges</span>(ReorderBuffer *rb, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>, <span class="Constant">NULL</span>, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rbtxn_has_catalog_changes(txn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3461" title="replication/logical/reorderbuffer.c:3461">ReorderBufferXidHasBaseSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Have we already set the base snapshot for the given txn/subtxn?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3461">&#x200c;</a></span><span class="linkable">ReorderBufferXidHasBaseSnapshot</span>(ReorderBuffer *rb, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, xid, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, InvalidXLogRecPtr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction isn't known yet, ergo no snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* a known subtxn? operate on top-level txn instead */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_known_subxact(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = <a href="#L623" title="replication/logical/reorderbuffer.c:623">ReorderBufferTXNByXid</a>(rb, txn-&gt;toplevel_xid, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, InvalidXLogRecPtr, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> txn-&gt;base_snapshot != <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> * Disk serialization support<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure the IO buffer is &gt;= sz.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3491">&#x200c;</a></span><span class="linkable">ReorderBufferSerializeReserve</span>(ReorderBuffer *rb, Size sz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!rb-&gt;outbufsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;outbuf = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;context, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;outbufsize = sz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rb-&gt;outbufsize &lt; sz)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;outbuf = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(rb-&gt;outbuf, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;outbufsize = sz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Compare two transactions by size */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3508">&#x200c;</a></span><span class="linkable">ReorderBufferTXNSizeCompare</span>(<span class="Type">const</span> pairingheap_node *a, <span class="Type">const</span> pairingheap_node *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ReorderBufferTXN *ta = pairingheap_const_container(ReorderBufferTXN, txn_node, a);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> ReorderBufferTXN *tb = pairingheap_const_container(ReorderBufferTXN, txn_node, b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ta-&gt;size &lt; tb-&gt;size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ta-&gt;size &gt; tb-&gt;size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the largest transaction (toplevel or subxact) to evict (spill to disk).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ReorderBufferTXN *<br/></li>
<li><a id="L3524">&#x200c;</a><span class="linkable">ReorderBufferLargestTXN</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *largest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the largest transaction from the max-heap */<br/></li>
<li></span>&nbsp; &nbsp; largest = pairingheap_container(ReorderBufferTXN, txn_node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L130" title="lib/pairingheap.c:130">pairingheap_first</a>(rb-&gt;txn_heap));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(largest);<br/></li>
<li>&nbsp; &nbsp; Assert(largest-&gt;size &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(largest-&gt;size &lt;= rb-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> largest;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the largest streamable toplevel transaction to evict (by streaming).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be seen as an optimized version of <a href="#L3524" title="replication/logical/reorderbuffer.c:3524">ReorderBufferLargestTXN</a>, which<br/></li>
<li></span><span class="Comment"> * should give us the same transaction (because we don't update memory account<br/></li>
<li></span><span class="Comment"> * for subtransaction with streaming, so it's always 0). But we can simply<br/></li>
<li></span><span class="Comment"> * iterate over the limited number of toplevel transactions that have a base<br/></li>
<li></span><span class="Comment"> * snapshot. There is no use of selecting a transaction that doesn't have base<br/></li>
<li></span><span class="Comment"> * snapshot because we don't decode such transactions.&nbsp; Also, we do not <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a><br/></li>
<li></span><span class="Comment"> * the transaction which doesn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> streamable change.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that, we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> transactions that contain incomplete changes. There<br/></li>
<li></span><span class="Comment"> * is a scope of optimization here such that we can <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the largest<br/></li>
<li></span><span class="Comment"> * transaction which has incomplete changes.&nbsp; But that will make the code and<br/></li>
<li></span><span class="Comment"> * design quite complex and that might not be worth the benefit.&nbsp; If we plan to<br/></li>
<li></span><span class="Comment"> * stream the transactions that contain incomplete changes then we need to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a way to partially stream/truncate the transaction changes in-memory<br/></li>
<li></span><span class="Comment"> * and build a mechanism to partially truncate the spilled files.<br/></li>
<li></span><span class="Comment"> * Additionally, whenever we partially stream the transaction we need to<br/></li>
<li></span><span class="Comment"> * maintain the last streamed lsn and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time we need to restore from that<br/></li>
<li></span><span class="Comment"> * segment and the offset in WAL.&nbsp; As we stream the changes from the top<br/></li>
<li></span><span class="Comment"> * transaction and restore them subtransaction wise, we need to even remember<br/></li>
<li></span><span class="Comment"> * the subxact from where we streamed the last change.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ReorderBufferTXN *<br/></li>
<li><a id="L3564">&#x200c;</a><span class="linkable">ReorderBufferLargestStreamableTopTXN</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; largest_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *largest = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the largest top-level transaction having a base snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;rb-&gt;txns_by_base_snapshot_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn = dlist_container(ReorderBufferTXN, base_snapshot_node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must not be a subtxn */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!rbtxn_is_known_subxact(txn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* base_snapshot must be set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;base_snapshot != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((largest == <span class="Constant">NULL</span> || txn-&gt;total_size &gt; largest_size) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (txn-&gt;total_size &gt; <span class="Constant">0</span>) &amp;&amp; !(rbtxn_has_partial_change(txn)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rbtxn_has_streamable_change(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; largest = txn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; largest_size = txn-&gt;total_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> largest;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the <a href="#L212" title="replication/logical/reorderbuffer.c:212">logical_decoding_work_mem</a> limit was reached, and if yes<br/></li>
<li></span><span class="Comment"> * pick the largest (sub)transaction at-a-time to evict and spill its changes to<br/></li>
<li></span><span class="Comment"> * disk or <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to the output plugin until we reach under the memory limit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="#L216" title="replication/logical/reorderbuffer.c:216">debug_logical_replication_streaming</a> is set to &quot;immediate&quot;, stream or<br/></li>
<li></span><span class="Comment"> * serialize the changes immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> At this point we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the transactions until we reach under the memory<br/></li>
<li></span><span class="Comment"> * limit, but we might also adapt a more elaborate eviction strategy - for example<br/></li>
<li></span><span class="Comment"> * evicting enough transactions to free certain fraction (e.g. 50%) of the memory<br/></li>
<li></span><span class="Comment"> * limit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3608">&#x200c;</a></span><span class="linkable">ReorderBufferCheckMemoryLimit</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bail out if <a href="#L216" title="replication/logical/reorderbuffer.c:216">debug_logical_replication_streaming</a> is buffered and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * haven't exceeded the memory limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L216" title="replication/logical/reorderbuffer.c:216">debug_logical_replication_streaming</a> == DEBUG_LOGICAL_REP_STREAMING_BUFFERED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;size &lt; <a href="#L212" title="replication/logical/reorderbuffer.c:212">logical_decoding_work_mem</a> * <span class="Constant">1024L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L216" title="replication/logical/reorderbuffer.c:216">debug_logical_replication_streaming</a> is immediate, loop until there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no change. Otherwise, loop until we reach under the memory limit. One<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might think that just by evicting the largest (sub)transaction we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * come under the memory limit based on assumption that the selected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction is at least as large as the most recent change (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caused us to go over the memory limit). However, that is not true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because a user can reduce the <a href="#L212" title="replication/logical/reorderbuffer.c:212">logical_decoding_work_mem</a> to a smaller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the most recent change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (rb-&gt;size &gt;= <a href="#L212" title="replication/logical/reorderbuffer.c:212">logical_decoding_work_mem</a> * <span class="Constant">1024L</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L216" title="replication/logical/reorderbuffer.c:216">debug_logical_replication_streaming</a> == DEBUG_LOGICAL_REP_STREAMING_IMMEDIATE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;size &gt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pick the largest transaction and evict it from memory by streaming,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if possible.&nbsp; Otherwise, spill to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4000" title="replication/logical/reorderbuffer.c:4000">ReorderBufferCanStartStreaming</a>(rb) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (txn = <a href="#L3564" title="replication/logical/reorderbuffer.c:3564">ReorderBufferLargestStreamableTopTXN</a>(rb)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we know there has to be one, because the size is not zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(txn &amp;&amp; rbtxn_is_toptxn(txn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;total_size &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rb-&gt;size &gt;= txn-&gt;total_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4026" title="replication/logical/reorderbuffer.c:4026">ReorderBufferStreamTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pick the largest transaction (or subtransaction) and evict it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from memory by serializing it to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn = <a href="#L3524" title="replication/logical/reorderbuffer.c:3524">ReorderBufferLargestTXN</a>(rb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we know there has to be one, because the size is not zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;size &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rb-&gt;size &gt;= txn-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3681" title="replication/logical/reorderbuffer.c:3681">ReorderBufferSerializeTXN</a>(rb, txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After eviction, the transaction should have no entries in memory,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and should use 0 bytes for changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;size == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;nentries_mem == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must be under the memory limit <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rb-&gt;size &lt; <a href="#L212" title="replication/logical/reorderbuffer.c:212">logical_decoding_work_mem</a> * <span class="Constant">1024L</span>);<br/></li>
<li><br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Spill data of a large transaction (and its subtransactions) to disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3681">&#x200c;</a></span><span class="linkable">ReorderBufferSerializeTXN</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; subtxn_i;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter change_i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; curOpenSegNo = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; spilled = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = txn-&gt;size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;spill </span><span class="Special">%u</span><span class="Constant"> changes in XID </span><span class="Special">%u</span><span class="Constant"> to disk&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) txn-&gt;nentries_mem, txn-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the same to all child TXs */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(subtxn_i, &amp;txn-&gt;subtxns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *subtxn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subtxn = dlist_container(ReorderBufferTXN, node, subtxn_i.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3681" title="replication/logical/reorderbuffer.c:3681">ReorderBufferSerializeTXN</a>(rb, subtxn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* serialize changestream */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(change_i, &amp;txn-&gt;changes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; change = dlist_container(ReorderBufferChange, node, change_i.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * store in segment in which it belongs by start lsn, don't split over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple segments tho<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd == -<span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !XLByteInSeg(change-&gt;lsn, curOpenSegNo, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(change-&gt;lsn, curOpenSegNo, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to care about TLIs here, only used during a single run,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so each LSN only <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> to a specific WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4608" title="replication/logical/reorderbuffer.c:4608">ReorderBufferSerializedPath</a>(path, <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>, txn-&gt;xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curOpenSegNo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* open segment, create it if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_CREAT | O_WRONLY | O_APPEND | PG_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3776" title="replication/logical/reorderbuffer.c:3776">ReorderBufferSerializeChange</a>(rb, txn, fd, change);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spilled++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the memory counter */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, <span class="Constant">NULL</span>, txn, <span class="Constant">false</span>, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the statistics iff we have spilled anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (spilled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;spillCount += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;spillBytes += size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't consider already serialized transactions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rb-&gt;spillTxns += (rbtxn_is_serialized(txn) || rbtxn_is_serialized_clear(txn)) ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the decoding stats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical.c.html#L1931" title="replication/logical/logical.c:1931">UpdateDecodingStats</a>((LogicalDecodingContext *) rb-&gt;private_data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(spilled == txn-&gt;nentries_mem);<br/></li>
<li>&nbsp; &nbsp; Assert(dlist_is_empty(&amp;txn-&gt;changes));<br/></li>
<li>&nbsp; &nbsp; txn-&gt;nentries_mem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;txn_flags |= RBTXN_IS_SERIALIZED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Serialize individual change to disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3776">&#x200c;</a></span><span class="linkable">ReorderBufferSerializeChange</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> fd, ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *ondisk;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb, sz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;ondisk-&gt;change, change, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferChange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (change-&gt;action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through these, they're all similar enough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; oldlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newlen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup = change-&gt;data.tp.oldtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup = change-&gt;data.tp.newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldlen = oldtup-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += oldlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen = newtup-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += newlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we have enough space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb, sz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = ((<span class="Type">char</span> *) rb-&gt;outbuf) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have been reallocated above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, oldtup, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, oldtup-&gt;t_data, oldlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += oldlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, newtup, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, newtup-&gt;t_data, newlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += newlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_MESSAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; prefix_size = strlen(change-&gt;data.msg.prefix) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += prefix_size + change-&gt;data.msg.message_size +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb, sz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = ((<span class="Type">char</span> *) rb-&gt;outbuf) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have been reallocated above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the prefix including the size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, &amp;prefix_size, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, change-&gt;data.msg.prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefix_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += prefix_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write the message including the size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, &amp;change-&gt;data.msg.message_size, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, change-&gt;data.msg.message,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; change-&gt;data.msg.message_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += change-&gt;data.msg.message_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INVALIDATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; inval_size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.inval.ninvalidations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += inval_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = ((<span class="Type">char</span> *) rb-&gt;outbuf) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have been reallocated above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, change-&gt;data.inval.invalidations, inval_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += inval_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snap = change-&gt;data.snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;xcnt +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;subxcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we have enough space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb, sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = ((<span class="Type">char</span> *) rb-&gt;outbuf) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have been reallocated above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, snap, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;xcnt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, snap-&gt;xip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;xcnt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;subxcnt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, snap-&gt;subxip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;subxcnt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;subxcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* account for the OIDs of truncated relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * change-&gt;data.truncate.nrelids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we have enough space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb, sz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = ((<span class="Type">char</span> *) rb-&gt;outbuf) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might have been reallocated above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, change-&gt;data.truncate.relids, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ReorderBufferChange contains everything important */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ondisk-&gt;size = sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_REORDER_BUFFER_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write(fd, rb-&gt;outbuf, ondisk-&gt;size) != ondisk-&gt;size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno ? save_errno : <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to data file for XID </span><span class="Special">%u</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;xid)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep the transaction's final_lsn up to date with each change we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk, so that <a href="#L4539" title="replication/logical/reorderbuffer.c:4539">ReorderBufferRestoreCleanup</a> works correctly.&nbsp; (We used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only do this on commit and abort <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, but that doesn't work if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system crash leaves a transaction without its abort record).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure not to move it backwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;final_lsn &lt; change-&gt;lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;final_lsn = change-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ondisk-&gt;change.action == change-&gt;action);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Returns true, if the output plugin supports streaming, false, otherwise. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3991">&#x200c;</a></span><span class="linkable">ReorderBufferCanStream</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = rb-&gt;private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ctx-&gt;streaming;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Returns true, if the streaming can be started <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, false, otherwise. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4000">&#x200c;</a></span><span class="linkable">ReorderBufferCanStartStreaming</span>(ReorderBuffer *rb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = rb-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="snapbuild.c.html#L152" title="replication/logical/snapbuild.c:152">SnapBuild</a>&nbsp; *builder = ctx-&gt;snapshot_builder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can't start streaming unless a consistent state is reached. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="snapbuild.c.html#L406" title="replication/logical/snapbuild.c:406">SnapBuildCurrentState</a>(builder) &lt; SNAPBUILD_CONSISTENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't start streaming immediately even if the streaming is enabled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we previously decoded this transaction and <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> just are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restarting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3991" title="replication/logical/reorderbuffer.c:3991">ReorderBufferCanStream</a>(rb) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="snapbuild.c.html#L433" title="replication/logical/snapbuild.c:433">SnapBuildXactNeedsSkip</a>(builder, ctx-&gt;reader-&gt;ReadRecPtr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send data of a large transaction (and its subtransactions) to the<br/></li>
<li></span><span class="Comment"> * output plugin, but using the stream API.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4026">&#x200c;</a></span><span class="linkable">ReorderBufferStreamTXN</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot_now;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; command_id;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; stream_bytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; txn_is_streamed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can never reach here for a subtransaction. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rbtxn_is_toptxn(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> assumptions about base snapshot here, similar to what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2711" title="replication/logical/reorderbuffer.c:2711">ReorderBufferCommit</a>() does. That relies on base_snapshot getting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transferred from subxact in <a href="#L1189" title="replication/logical/reorderbuffer.c:1189">ReorderBufferCommitChild</a>(), but that was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not yet called as the transaction is in-progress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So just walk the subxacts and use the same logic here. But we only need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do that once, when the transaction is streamed for the first time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After that we need to reuse the snapshot from the previous run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="decode.c.html#L666" title="replication/logical/decode.c:666">DecodeCommit</a> which adds xids of all the subtransactions in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot's xip array via <a href="snapbuild.c.html#L1024" title="replication/logical/snapbuild.c:1024">SnapBuildCommitTxn</a>, we can't do that here but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do add them to subxip array instead via <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows the catalog changes made in subtransactions decoded till <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;snapshot_now == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; subxact_i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure this transaction is streamed for the first time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!rbtxn_is_streamed(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* at the beginning we should have invalid command ID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;command_id == InvalidCommandId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(subxact_i, &amp;txn-&gt;subtxns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *subtxn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtxn = dlist_container(ReorderBufferTXN, node, subxact_i.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1135" title="replication/logical/reorderbuffer.c:1135">ReorderBufferTransferSnapToParent</a>(txn, subtxn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this transaction has no snapshot, it didn't make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> changes to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the database till <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so there's nothing to decode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;base_snapshot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;ninvalidations == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; command_id = FirstCommandId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_now = <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>(rb, txn-&gt;base_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txn, command_id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the transaction must have been already streamed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rbtxn_is_streamed(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nah, we already have snapshot from the previous streaming run. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume new subxacts can't move the LSN backwards, and so can't beat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the LSN condition in the previous branch (so no need to walk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through subxacts again). In fact, we must not do that as we may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using snapshot half-way through the subxact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; command_id = txn-&gt;command_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't use txn-&gt;snapshot_now directly because after the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * streaming run, we might have got some new sub-transactions. So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to add them to the snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_now = <a href="#L1807" title="replication/logical/reorderbuffer.c:1807">ReorderBufferCopySnap</a>(rb, txn-&gt;snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txn, command_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free the previously copied snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(txn-&gt;snapshot_now-&gt;copied);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1866" title="replication/logical/reorderbuffer.c:1866">ReorderBufferFreeSnap</a>(rb, txn-&gt;snapshot_now);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;snapshot_now = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember this information to be used later to update stats. We can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the stats here as an error while processing the changes would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lead to the accumulation of stats even though we haven't streamed all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; txn_is_streamed = rbtxn_is_streamed(txn);<br/></li>
<li>&nbsp; &nbsp; stream_bytes = txn-&gt;total_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the changes to output plugin. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2080" title="replication/logical/reorderbuffer.c:2080">ReorderBufferProcessTXN</a>(rb, txn, InvalidXLogRecPtr, snapshot_now,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command_id, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rb-&gt;streamCount += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;streamBytes += stream_bytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't consider already streamed transaction. */<br/></li>
<li></span>&nbsp; &nbsp; rb-&gt;streamTxns += (txn_is_streamed) ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the decoding stats */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logical.c.html#L1931" title="replication/logical/logical.c:1931">UpdateDecodingStats</a>((LogicalDecodingContext *) rb-&gt;private_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(dlist_is_empty(&amp;txn-&gt;changes));<br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;nentries == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;nentries_mem == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Size of a change in memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L4143">&#x200c;</a><span class="linkable">ReorderBufferChangeSize</span>(ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferChange);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (change-&gt;action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through these, they're all similar enough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; oldlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newlen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup = change-&gt;data.tp.oldtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup = change-&gt;data.tp.newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldlen = oldtup-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += oldlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen = newtup-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += newlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_MESSAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; prefix_size = strlen(change-&gt;data.msg.prefix) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += prefix_size + change-&gt;data.msg.message_size +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INVALIDATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.inval.ninvalidations;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snap = change-&gt;data.snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;xcnt +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * snap-&gt;subxcnt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * change-&gt;data.truncate.nrelids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ReorderBufferChange contains everything important */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sz;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Restore a number of changes spilled to disk back into memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L4228">&#x200c;</a><span class="linkable">ReorderBufferRestoreChanges</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="replication/logical/reorderbuffer.c:138">TXNEntryFile</a> *file, XLogSegNo *segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; restored = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; last_segno;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter cleanup_iter;<br/></li>
<li>&nbsp; &nbsp; File&nbsp; &nbsp; &nbsp;&nbsp; *fd = &amp;file-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;first_lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;final_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free current entries, so we have memory for more */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(cleanup_iter, &amp;txn-&gt;changes)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(ReorderBufferChange, node, cleanup_iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; txn-&gt;nentries_mem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(dlist_is_empty(&amp;txn-&gt;changes));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(txn-&gt;final_lsn, last_segno, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (restored &lt; <a href="#L213" title="replication/logical/reorderbuffer.c:213">max_changes_in_memory</a> &amp;&amp; *segno &lt;= last_segno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readBytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *ondisk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*fd == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first time in */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*segno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(txn-&gt;first_lsn, *segno, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*segno != <span class="Constant">0</span> || dlist_is_empty(&amp;txn-&gt;changes));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to care about TLIs here, only used during a single run,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so each LSN only <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> to a specific WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4608" title="replication/logical/reorderbuffer.c:4608">ReorderBufferSerializedPath</a>(path, <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>, txn-&gt;xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fd = <a href="../../storage/file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No harm in resetting the offset even in case of failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*fd &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fd = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*segno)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read the statically sized part of a change which has information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about the total size. If we couldn't read a record, we're at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of this file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readBytes = FileRead(file-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>, rb-&gt;outbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file-&gt;curOffset, WAIT_EVENT_REORDER_BUFFER_READ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* eof */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(*fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fd = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*segno)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (readBytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from reorderbuffer spill file: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (readBytes != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from reorderbuffer spill file: read </span><span class="Special">%d</span><span class="Constant"> instead of </span><span class="Special">%u</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readBytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (uint32) <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset += readBytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3491" title="replication/logical/reorderbuffer.c:3491">ReorderBufferSerializeReserve</a>(rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>) + ondisk-&gt;size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) rb-&gt;outbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readBytes = FileRead(file-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rb-&gt;outbuf + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ondisk-&gt;size - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file-&gt;curOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_REORDER_BUFFER_READ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from reorderbuffer spill file: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (readBytes != ondisk-&gt;size - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from reorderbuffer spill file: read </span><span class="Special">%d</span><span class="Constant"> instead of </span><span class="Special">%u</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readBytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (uint32) (ondisk-&gt;size - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file-&gt;curOffset += readBytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ok, read a full change from disk, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> restore it into proper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in-memory format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4371" title="replication/logical/reorderbuffer.c:4371">ReorderBufferRestoreChange</a>(rb, txn, rb-&gt;outbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; restored++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> restored;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert change from its on-disk format to in-memory format and queue it onto<br/></li>
<li></span><span class="Comment"> * the TXN's -&gt;changes list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: although &quot;data&quot; is declared char*, at entry it points to a<br/></li>
<li></span><span class="Comment"> * maxalign'd buffer, making it safe in most of this function to assume<br/></li>
<li></span><span class="Comment"> * that the pointed-to data is suitably aligned for direct access.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4371">&#x200c;</a></span><span class="linkable">ReorderBufferRestoreChange</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *ondisk;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChange *change;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ondisk = (<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a> *) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; change = <a href="#L477" title="replication/logical/reorderbuffer.c:477">ReorderBufferGetChange</a>(rb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy static part */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(change, &amp;ondisk-&gt;change, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ReorderBufferChange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="replication/logical/reorderbuffer.c:177">ReorderBufferDiskChange</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore individual stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (change-&gt;action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through these, they're all similar enough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.tp.oldtuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tuplelen = ((HeapTuple) data)-&gt;t_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.oldtuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L562" title="replication/logical/reorderbuffer.c:562">ReorderBufferGetTupleBuf</a>(rb, tuplelen - SizeofHeapTupleHeader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore -&gt;tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.tp.oldtuple, data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset t_data pointer into the new tuplebuf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.oldtuple-&gt;t_data =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (HeapTupleHeader) ((<span class="Type">char</span> *) change-&gt;data.tp.oldtuple + HEAPTUPLESIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore tuple data itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.tp.oldtuple-&gt;t_data, data, tuplelen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += tuplelen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.tp.newtuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* here, data might not be suitably aligned! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tuplelen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;tuplelen, data + offsetof(HeapTupleData, t_len),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.newtuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L562" title="replication/logical/reorderbuffer.c:562">ReorderBufferGetTupleBuf</a>(rb, tuplelen - SizeofHeapTupleHeader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore -&gt;tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.tp.newtuple, data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset t_data pointer into the new tuplebuf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.tp.newtuple-&gt;t_data =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (HeapTupleHeader) ((<span class="Type">char</span> *) change-&gt;data.tp.newtuple + HEAPTUPLESIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restore tuple data itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.tp.newtuple-&gt;t_data, data, tuplelen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += tuplelen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_MESSAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; prefix_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read prefix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;prefix_size, data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.prefix = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefix_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.msg.prefix, data, prefix_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(change-&gt;data.msg.prefix[prefix_size - <span class="Constant">1</span>] == <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += prefix_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;change-&gt;data.msg.message_size, data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.message = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.msg.message_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.msg.message, data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; change-&gt;data.msg.message_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += change-&gt;data.msg.message_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INVALIDATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; inval_size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.inval.ninvalidations;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.inval.invalidations =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rb-&gt;context, inval_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(change-&gt;data.inval.invalidations, data, inval_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; oldsnap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; newsnap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldsnap = (Snapshot) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * oldsnap-&gt;xcnt +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId) * (oldsnap-&gt;subxcnt + <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.snapshot = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(rb-&gt;context, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsnap = change-&gt;data.snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newsnap, data, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsnap-&gt;xip = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (((<span class="Type">char</span> *) newsnap) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsnap-&gt;subxip = newsnap-&gt;xip + newsnap-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsnap-&gt;copied = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the base struct contains all the data, easy peasy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="#L595" title="replication/logical/reorderbuffer.c:595">ReorderBufferGetRelids</a>(rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.truncate.nrelids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(relids, data, change-&gt;data.truncate.nrelids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.truncate.relids = relids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;txn-&gt;changes, &amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; txn-&gt;nentries_mem++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update memory accounting for the restored change.&nbsp; We need to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * although we don't check the memory limit when restoring the changes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this branch (we only do that when initially queueing the changes after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoding), because we will release the changes later, and that will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the accounting too (subtracting the size from the counters). And<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't want to underflow there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, change, <span class="Constant">NULL</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4143" title="replication/logical/reorderbuffer.c:4143">ReorderBufferChangeSize</a>(change));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all on-disk stored for the passed in transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4539">&#x200c;</a></span><span class="linkable">ReorderBufferRestoreCleanup</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; first;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; cur;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; last;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;first_lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;final_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(txn-&gt;first_lsn, first, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(txn-&gt;final_lsn, last, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterate over all possible filenames, and delete them */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (cur = first; cur &lt;= last; cur++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4608" title="replication/logical/reorderbuffer.c:4608">ReorderBufferSerializedPath</a>(path, <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>, txn-&gt;xid, cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(path) != <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leftover serialized reorder buffers from a slot directory after a<br/></li>
<li></span><span class="Comment"> * prior crash or decoding session exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4569">&#x200c;</a></span><span class="linkable">ReorderBufferCleanupSerializedTXNs</span>(<span class="Type">const</span> <span class="Type">char</span> *slotname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *spill_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *spill_de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat statbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH * <span class="Constant">2</span> + <span class="Constant">12</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sprintf(path, <span class="Constant">&quot;pg_replslot/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, slotname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we're only handling directories here, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> if it's not ours */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lstat(path, &amp;statbuf) == <span class="Constant">0</span> &amp;&amp; !S_ISDIR(statbuf.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; spill_dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((spill_de = <a href="../../storage/file/fd.c.html#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(spill_dir, path, INFO)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only look at names that can be ours */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(spill_de-&gt;d_name, <span class="Constant">&quot;xid&quot;</span>, <span class="Constant">3</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;pg_replslot/</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, slotname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; spill_de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(path) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> during removal of pg_replslot/</span><span class="Special">%s</span><span class="Constant">/xid*: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, slotname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(spill_dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a replication slot, transaction ID and segment number, fill in the<br/></li>
<li></span><span class="Comment"> * corresponding spill file into 'path', which is a caller-owned buffer of size<br/></li>
<li></span><span class="Comment"> * at least MAXPGPATH.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4608">&#x200c;</a></span><span class="linkable">ReorderBufferSerializedPath</span>(<span class="Type">char</span> *path, ReplicationSlot *slot, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogSegNoOffsetToRecPtr(segno, <span class="Constant">0</span>, <a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(path, MAXPGPATH, <span class="Constant">&quot;pg_replslot/</span><span class="Special">%s</span><span class="Constant">/xid-</span><span class="Special">%u</span><span class="Constant">-lsn-</span><span class="Special">%X</span><span class="Constant">-</span><span class="Special">%X</span><span class="Constant">.spill&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, LSN_FORMAT_ARGS(recptr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all data spilled to disk after we've restarted/crashed. It will be<br/></li>
<li></span><span class="Comment"> * recreated when the respective slots are reused.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4625">&#x200c;</a></span><span class="linkable">StartupReorderBuffer</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *logical_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *logical_de;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; logical_dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_replslot&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((logical_de = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(logical_dir, <span class="Constant">&quot;pg_replslot&quot;</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(logical_de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(logical_de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it cannot be a slot, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the directory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../slot.c.html#L252" title="replication/slot.c:252">ReplicationSlotValidateName</a>(logical_de-&gt;d_name, DEBUG2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ok, has to be a surviving logical slot, iterate and delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * everything starting with xid-*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4569" title="replication/logical/reorderbuffer.c:4569">ReorderBufferCleanupSerializedTXNs</a>(logical_de-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(logical_dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------<br/></li>
<li></span><span class="Comment"> * toast reassembly support<br/></li>
<li></span><span class="Comment"> * ---------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize per tuple toast reconstruction support.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4659">&#x200c;</a></span><span class="linkable">ReorderBufferToastInitHash</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(txn-&gt;toast_hash == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L164" title="replication/logical/reorderbuffer.c:164">ReorderBufferToastEnt</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = rb-&gt;context;<br/></li>
<li>&nbsp; &nbsp; txn-&gt;toast_hash = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;ReorderBufferToastHash&quot;</span>, <span class="Constant">5</span>, &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per toast-chunk handling for toast reconstruction<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Appends a toast chunk so we can reconstruct it when the tuple &quot;owning&quot; the<br/></li>
<li></span><span class="Comment"> * toasted Datum comes along.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4679">&#x200c;</a></span><span class="linkable">ReorderBufferToastAppendChunk</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L164" title="replication/logical/reorderbuffer.c:164">ReorderBufferToastEnt</a> *ent;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; chunksize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; chunk;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc = RelationGetDescr(relation);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_id;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; chunk_seq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;toast_hash == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4659" title="replication/logical/reorderbuffer.c:4659">ReorderBufferToastInitHash</a>(rb, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../catalog/catalog.c.html#L145" title="catalog/catalog.c:145">IsToastRelation</a>(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newtup = change-&gt;data.tp.newtuple;<br/></li>
<li>&nbsp; &nbsp; chunk_id = DatumGetObjectId(fastgetattr(newtup, <span class="Constant">1</span>, desc, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; chunk_seq = DatumGetInt32(fastgetattr(newtup, <span class="Constant">2</span>, desc, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ent = (<a href="#L164" title="replication/logical/reorderbuffer.c:164">ReorderBufferToastEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(txn-&gt;toast_hash, &amp;chunk_id, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ent-&gt;chunk_id == chunk_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;num_chunks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;last_chunk_seq = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;reconstructed = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;ent-&gt;chunks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chunk_seq != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;got sequence entry </span><span class="Special">%d</span><span class="Constant"> for toast chunk </span><span class="Special">%u</span><span class="Constant"> instead of seq 0&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chunk_seq, chunk_id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (found &amp;&amp; chunk_seq != ent-&gt;last_chunk_seq + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;got sequence entry </span><span class="Special">%d</span><span class="Constant"> for toast chunk </span><span class="Special">%u</span><span class="Constant"> instead of seq </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chunk_seq, chunk_id, ent-&gt;last_chunk_seq + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; chunk = DatumGetPointer(fastgetattr(newtup, <span class="Constant">3</span>, desc, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* calculate size so we can allocate the right size at once later */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_IS_EXTENDED(chunk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunksize = VARSIZE(chunk) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_SHORT(chunk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* could happen due to <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> doing its thing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunksize = VARSIZE_SHORT(chunk) - VARHDRSZ_SHORT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected type of toast chunk&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ent-&gt;size += chunksize;<br/></li>
<li>&nbsp; &nbsp; ent-&gt;last_chunk_seq = chunk_seq;<br/></li>
<li>&nbsp; &nbsp; ent-&gt;num_chunks++;<br/></li>
<li>&nbsp; &nbsp; dlist_push_tail(&amp;ent-&gt;chunks, &amp;change-&gt;node);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Rejigger change-&gt;newtuple to point to in-memory toast tuples instead of<br/></li>
<li></span><span class="Comment"> * on-disk toast tuples that may no longer exist (think DROP TABLE or VACUUM).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We cannot replace unchanged toast tuples though, so those will still point<br/></li>
<li></span><span class="Comment"> * to on-disk toast data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While updating the existing change with detoasted tuple data, we need to<br/></li>
<li></span><span class="Comment"> * update the memory accounting info, because the change size will differ.<br/></li>
<li></span><span class="Comment"> * Otherwise the accounting may get out of sync, triggering serialization<br/></li>
<li></span><span class="Comment"> * at unexpected times.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We simply subtract size of the change <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> rejiggering the tuple, and<br/></li>
<li></span><span class="Comment"> * then add the new size. This makes it look like the change was removed<br/></li>
<li></span><span class="Comment"> * and then added back, except it only tweaks the accounting info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In particular it can't <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> serialization, which would be pointless<br/></li>
<li></span><span class="Comment"> * anyway as it happens during commit processing right <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> handing<br/></li>
<li></span><span class="Comment"> * the change to the output plugin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4762">&#x200c;</a></span><span class="linkable">ReorderBufferToastReplace</span>(ReorderBuffer *rb, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natt;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *attrs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *free;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tmphtup;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; toast_rel;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; toast_desc;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtup;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; old_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no toast tuples changed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;toast_hash == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're going to modify the size of the change. So, to make sure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accounting is correct we record the current change size and then after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-computing the change we'll subtract the recorded size and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-add the new change size at the end. We don't immediately subtract<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the old size because if there is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we add the new size,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we will release the changes and that will update the accounting info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (subtracting the size from the counters). And we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * underflow there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_size = <a href="#L4143" title="replication/logical/reorderbuffer.c:4143">ReorderBufferChangeSize</a>(change);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(rb-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we should only have toast tuples in an INSERT or UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; Assert(change-&gt;data.tp.newtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; desc = RelationGetDescr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; toast_rel = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(relation-&gt;rd_rel-&gt;reltoastrelid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsValid(toast_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not open toast relation with OID </span><span class="Special">%u</span><span class="Constant"> (base relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation-&gt;rd_rel-&gt;reltoastrelid, RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; toast_desc = RelationGetDescr(toast_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should we allocate from stack instead? */<br/></li>
<li></span>&nbsp; &nbsp; attrs = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * desc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; isnull = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * desc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; free = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * desc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newtup = change-&gt;data.tp.newtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(newtup, desc, attrs, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (natt = <span class="Constant">0</span>; natt &lt; desc-&gt;natts; natt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(desc, natt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L164" title="replication/logical/reorderbuffer.c:164">ReorderBufferToastEnt</a> *ent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *varlena;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* va_rawsize is the size of the original datum -- including header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_indirect redirect_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *new_datum = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *reconstructed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; it;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_done = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* system columns aren't toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attnum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not a varlena datatype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attlen != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull[natt])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, we know we have a toast datum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; varlena = (<span class="Type">struct</span> varlena *) DatumGetPointer(attrs[natt]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to do anything if the tuple isn't external */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_IS_EXTERNAL(varlena))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, varlena);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether the toast tuple changed, replace if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ent = (<a href="#L164" title="replication/logical/reorderbuffer.c:164">ReorderBufferToastEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(txn-&gt;toast_hash,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;toast_pointer.va_valueid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_datum =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(INDIRECT_POINTER_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; free[natt] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reconstructed = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(toast_pointer.va_rawsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent-&gt;reconstructed = reconstructed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stitch toast tuple back together from its parts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(it, &amp;ent-&gt;chunks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cisnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *cchange;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ctup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cchange = dlist_container(ReorderBufferChange, node, it.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctup = cchange-&gt;data.tp.newtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk = DatumGetPointer(fastgetattr(ctup, <span class="Constant">3</span>, toast_desc, &amp;cisnull));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!cisnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL(chunk));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_SHORT(chunk));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(reconstructed) + data_done,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA(chunk),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE(chunk) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_done += VARSIZE(chunk) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(data_done == VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure its marked as compressed or not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE_COMPRESSED(reconstructed, data_done + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(reconstructed, data_done + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;redirect_pointer, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(redirect_pointer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; redirect_pointer.pointer = reconstructed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARTAG_EXTERNAL(new_datum, VARTAG_INDIRECT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA_EXTERNAL(new_datum), &amp;redirect_pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(redirect_pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrs[natt] = PointerGetDatum(new_datum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build tuple in separate memory &amp; copy tuple back into the tuplebuf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed to the output plugin. We can't directly <a href="../../access/common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>() into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tuplebuf because attrs[] will point back into the current content.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmphtup = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(desc, attrs, isnull);<br/></li>
<li>&nbsp; &nbsp; Assert(newtup-&gt;t_len &lt;= MaxHeapTupleSize);<br/></li>
<li>&nbsp; &nbsp; Assert(newtup-&gt;t_data == (HeapTupleHeader) ((<span class="Type">char</span> *) newtup + HEAPTUPLESIZE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(newtup-&gt;t_data, tmphtup-&gt;t_data, tmphtup-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; newtup-&gt;t_len = tmphtup-&gt;t_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free resources we won't further need, more persistent stuff will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * free'd in <a href="#L4953" title="replication/logical/reorderbuffer.c:4953">ReorderBufferToastReset</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(toast_rel);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmphtup);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (natt = <span class="Constant">0</span>; natt &lt; desc-&gt;natts; natt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (free[natt])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(attrs[natt]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(attrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(free);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* subtract the old change size */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, change, <span class="Constant">NULL</span>, <span class="Constant">false</span>, old_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> add the change back, with the correct size */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3192" title="replication/logical/reorderbuffer.c:3192">ReorderBufferChangeMemoryUpdate</a>(rb, change, <span class="Constant">NULL</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4143" title="replication/logical/reorderbuffer.c:4143">ReorderBufferChangeSize</a>(change));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free all resources allocated for toast reconstruction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4953">&#x200c;</a></span><span class="linkable">ReorderBufferToastReset</span>(ReorderBuffer *rb, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS hstat;<br/></li>
<li>&nbsp; &nbsp; <a href="#L164" title="replication/logical/reorderbuffer.c:164">ReorderBufferToastEnt</a> *ent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (txn-&gt;toast_hash == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sequentially walk over the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and free everything */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hstat, txn-&gt;toast_hash);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ent = (<a href="#L164" title="replication/logical/reorderbuffer.c:164">ReorderBufferToastEnt</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_mutable_iter it;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ent-&gt;reconstructed != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ent-&gt;reconstructed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach_modify(it, &amp;ent-&gt;chunks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_container(ReorderBufferChange, node, it.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;change-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="replication/logical/reorderbuffer.c:492">ReorderBufferReturnChange</a>(rb, change, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(txn-&gt;toast_hash);<br/></li>
<li>&nbsp; &nbsp; txn-&gt;toast_hash = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ---------------------------------------<br/></li>
<li></span><span class="Comment"> * Visibility support for logical decoding<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lookup actual cmin/cmax <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> when using decoding snapshot. We can't<br/></li>
<li></span><span class="Comment"> * always rely on stored cmin/cmax <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> because of two scenarios:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * A tuple got changed multiple times during a single transaction and thus<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; has got a combo CID. Combo CIDs are only valid for the duration of a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; single transaction.<br/></li>
<li></span><span class="Comment"> * * A tuple with a cmin but no cmax (and thus no combo CID) got<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; deleted/updated in another transaction than the one which created it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; which we are looking at right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. As only one of cmin, cmax or combo CID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; is actually stored in the heap we don't have access to the value we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; need anymore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To resolve those problems we have a per-transaction <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of (cmin,<br/></li>
<li></span><span class="Comment"> * cmax) tuples keyed by (relfilelocator, ctid) which contains the actual<br/></li>
<li></span><span class="Comment"> * (cmin, cmax) <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. That also takes care of combo CIDs by simply<br/></li>
<li></span><span class="Comment"> * not caring about them at all. As we have the real cmin/cmax <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * combo CIDs aren't interesting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As we only care about catalog tuples here the overhead of this<br/></li>
<li></span><span class="Comment"> * hashtable should be acceptable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Heap rewrites complicate this a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, check rewriteheap.c for<br/></li>
<li></span><span class="Comment"> * details.<br/></li>
<li></span><span class="Comment"> * -------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* struct for sorting mapping files by LSN efficiently */<br/></li>
<li><a id="L5016">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RewriteMappingFile</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXPGPATH];<br/></li>
<li><a id="L5020">&#x200c;</a>} <span class="linkable">RewriteMappingFile</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5024">&#x200c;</a></span><span class="linkable">DisplayMapping</span>(<a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS hstat;<br/></li>
<li>&nbsp; &nbsp; <a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *ent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hstat, <a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ent = (<a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hstat)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;mapping: node: </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> tid: </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> cmin: </span><span class="Special">%u</span><span class="Constant">, cmax: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ent-&gt;key.rlocator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ent-&gt;key.rlocator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ent-&gt;key.rlocator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(&amp;ent-&gt;key.tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetOffsetNumber(&amp;ent-&gt;key.tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ent-&gt;cmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ent-&gt;cmax<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Apply a single mapping file to <a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The mapping file has to have been verified to be a) committed b) for our<br/></li>
<li></span><span class="Comment"> * transaction c) applied in LSN order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5052">&#x200c;</a></span><span class="linkable">ApplyLogicalMappingFile</span>(<a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>, Oid relid, <span class="Type">const</span> <span class="Type">char</span> *fname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readBytes;<br/></li>
<li>&nbsp; &nbsp; LogicalRewriteMappingData map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sprintf(path, <span class="Constant">&quot;pg_logical/mappings/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, fname);<br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="replication/logical/reorderbuffer.c:123">ReorderBufferTupleCidKey</a> key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *ent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *new_ent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be careful about padding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;key, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L123" title="replication/logical/reorderbuffer.c:123">ReorderBufferTupleCidKey</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read all mappings till the end of the file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readBytes = read(fd, &amp;map, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRewriteMappingData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readBytes &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (readBytes == <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* EOF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (readBytes != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRewriteMappingData))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> instead of </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, readBytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (int32) <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRewriteMappingData))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key.rlocator = map.old_locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(&amp;map.old_tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;key.tid);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ent = (<a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>, &amp;key, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no existing mapping, no need to update */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key.rlocator = map.new_locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(&amp;map.new_tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;key.tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_ent = (<a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>, &amp;key, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure the existing mapping makes sense. We sometime update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that did not yet have a cmax (e.g. pg_class' own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry while rewriting it) during rewrites, so allow that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ent-&gt;cmin == InvalidCommandId || ent-&gt;cmin == new_ent-&gt;cmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ent-&gt;cmax == InvalidCommandId || ent-&gt;cmax == new_ent-&gt;cmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update mapping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_ent-&gt;cmin = ent-&gt;cmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_ent-&gt;cmax = ent-&gt;cmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_ent-&gt;combocid = ent-&gt;combocid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether the TransactionId 'xid' is in the pre-sorted array 'xip'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5144">&#x200c;</a></span><span class="linkable">TransactionIdInArray</span>(TransactionId xid, TransactionId *xip, Size num)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bsearch(&amp;xid, xip, num,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a>) != <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>() comparator for sorting RewriteMappingFiles in LSN order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L5154">&#x200c;</a></span><span class="linkable">file_sort_by_lsn</span>(<span class="Type">const</span> ListCell *a_p, <span class="Type">const</span> ListCell *b_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *a = (<a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *) lfirst(a_p);<br/></li>
<li>&nbsp; &nbsp; <a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *b = (<a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *) lfirst(b_p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u64(a-&gt;lsn, b-&gt;lsn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Apply <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing logical remapping files if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> targeted at our<br/></li>
<li></span><span class="Comment"> * transaction for relid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5167">&#x200c;</a></span><span class="linkable">UpdateLogicalMappings</span>(<a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>, Oid relid, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mapping_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *mapping_de;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *files = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *file;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = <a href="../../catalog/catalog.c.html#L243" title="catalog/catalog.c:243">IsSharedRelation</a>(relid) ? InvalidOid : <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mapping_dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_logical/mappings&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((mapping_de = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(mapping_dir, <span class="Constant">&quot;pg_logical/mappings&quot;</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f_dboid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId f_mapped_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId f_create_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; f_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; f_hi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f_lo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(mapping_de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(mapping_de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore files that aren't ours */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(mapping_de-&gt;d_name, <span class="Constant">&quot;map-&quot;</span>, <span class="Constant">4</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sscanf(mapping_de-&gt;d_name, LOGICAL_REWRITE_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;f_dboid, &amp;f_relid, &amp;f_hi, &amp;f_lo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;f_mapped_xid, &amp;f_create_xid) != <span class="Constant">6</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> filename </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, mapping_de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f_lsn = ((uint64) f_hi) &lt;&lt; <span class="Constant">32</span> | f_lo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mapping for another database */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (f_dboid != dboid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mapping for another relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (f_relid != relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* did the creating transaction abort? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(f_create_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not for our transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L5144" title="replication/logical/reorderbuffer.c:5144">TransactionIdInArray</a>(f_mapped_xid, snapshot-&gt;subxip, snapshot-&gt;subxcnt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, relevant, queue for apply */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; f = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; f-&gt;lsn = f_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(f-&gt;fname, mapping_de-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; files = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(files, f);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(mapping_dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort files so we apply them in LSN order */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1674" title="nodes/list.c:1674">list_sort</a>(files, <a href="#L5154" title="replication/logical/reorderbuffer.c:5154">file_sort_by_lsn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(file, files)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *f = (<a href="#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *) lfirst(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;applying mapping: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in </span><span class="Special">%u</span><span class="Constant">&quot;</span>, f-&gt;fname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot-&gt;subxip[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5052" title="replication/logical/reorderbuffer.c:5052">ApplyLogicalMappingFile</a>(<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>, relid, f-&gt;fname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(f);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lookup cmin/cmax of a tuple, during logical decoding where we can't rely on<br/></li>
<li></span><span class="Comment"> * combo CIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5245">&#x200c;</a></span><span class="linkable">ResolveCminCmaxDuringDecoding</span>(<a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple htup, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId *cmin, CommandId *cmax)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="replication/logical/reorderbuffer.c:123">ReorderBufferTupleCidKey</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *ent;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blockno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_mapping = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return unresolved if <a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a> is not valid.&nbsp; That's because when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming in-progress transactions we may run into tuples with the CID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually decoding them.&nbsp; Think e.g. about INSERT followed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TRUNCATE, where the TRUNCATE may not be decoded yet when applying the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INSERT.&nbsp; So in such cases, we assume the CID is from the future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* be careful about padding */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;key, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(key));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BufferIsLocal(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get relfilelocator from the buffer, no convenient way to access it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other than that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3688" title="storage/buffer/bufmgr.c:3688">BufferGetTag</a>(buffer, &amp;key.rlocator, &amp;forkno, &amp;blockno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tuples can only be in the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork */<br/></li>
<li></span>&nbsp; &nbsp; Assert(forkno == MAIN_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; Assert(blockno == ItemPointerGetBlockNumber(&amp;htup-&gt;t_self));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerCopy(&amp;htup-&gt;t_self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;key.tid);<br/></li>
<li><br/></li>
<li><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ent = (<a href="#L129" title="replication/logical/reorderbuffer.c:129">ReorderBufferTupleCidEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>, &amp;key, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a mapping, check whether the table was rewritten and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * apply mapping if so, but only do that once - there can be no new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mappings while we are in here since we have to hold a lock on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ent == <span class="Constant">NULL</span> &amp;&amp; !updated_mapping)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5167" title="replication/logical/reorderbuffer.c:5167">UpdateLogicalMappings</a>(<a href="../../utils/time/snapmgr.c.html#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>, htup-&gt;t_tableOid, snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> check but don't update for a mapping again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_mapping = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cmin = ent-&gt;cmin;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cmax = ent-&gt;cmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
