<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/logical/logical.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/logical/logical.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L48">LogicalErrorCallbackState</a></li>
<li><a href="#L53">LogicalErrorCallbackState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L109">CheckLogicalDecodingRequirements</a></li>
<li><a href="#L495">CreateDecodingContext</a></li>
<li><a href="#L329">CreateInitDecodingContext</a></li>
<li><a href="#L649">DecodingContextFindStartpoint</a></li>
<li><a href="#L640">DecodingContextReady</a></li>
<li><a href="#L693">FreeDecodingContext</a></li>
<li><a href="#L749">LoadOutputPlugin</a></li>
<li><a href="#L1834">LogicalConfirmReceivedLocation</a></li>
<li><a href="#L1760">LogicalIncreaseRestartDecodingForSlot</a></li>
<li><a href="#L1692">LogicalIncreaseXminForSlot</a></li>
<li><a href="#L1978">LogicalReplicationSlotHasPendingWal</a></li>
<li><a href="#L2060">LogicalSlotAdvanceAndCheckSnapState</a></li>
<li><a href="#L708">OutputPluginPrepareWrite</a></li>
<li><a href="#L734">OutputPluginUpdateProgress</a></li>
<li><a href="#L721">OutputPluginWrite</a></li>
<li><a href="#L1921">ResetLogicalStreamingState</a></li>
<li><a href="#L150">StartupDecodingContext</a></li>
<li><a href="#L1931">UpdateDecodingStats</a></li>
<li><a href="#L851">begin_cb_wrapper</a></li>
<li><a href="#L921">begin_prepare_cb_wrapper</a></li>
<li><a href="#L1102">change_cb_wrapper</a></li>
<li><a href="#L882">commit_cb_wrapper</a></li>
<li><a href="#L1010">commit_prepared_cb_wrapper</a></li>
<li><a href="#L1215">filter_by_origin_cb_wrapper</a></li>
<li><a href="#L1183">filter_prepare_cb_wrapper</a></li>
<li><a href="#L1246">message_cb_wrapper</a></li>
<li><a href="#L771">output_plugin_error_callback</a></li>
<li><a href="#L965">prepare_cb_wrapper</a></li>
<li><a href="#L1055">rollback_prepared_cb_wrapper</a></li>
<li><a href="#L818">shutdown_cb_wrapper</a></li>
<li><a href="#L790">startup_cb_wrapper</a></li>
<li><a href="#L1381">stream_abort_cb_wrapper</a></li>
<li><a href="#L1508">stream_change_cb_wrapper</a></li>
<li><a href="#L1467">stream_commit_cb_wrapper</a></li>
<li><a href="#L1557">stream_message_cb_wrapper</a></li>
<li><a href="#L1422">stream_prepare_cb_wrapper</a></li>
<li><a href="#L1283">stream_start_cb_wrapper</a></li>
<li><a href="#L1332">stream_stop_cb_wrapper</a></li>
<li><a href="#L1598">stream_truncate_cb_wrapper</a></li>
<li><a href="#L1141">truncate_cb_wrapper</a></li>
<li><a href="#L1645">update_progress_txn_cb_wrapper</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * logical.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; PostgreSQL logical decoding coordination<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2012-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/logical/logical.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file coordinates interaction between the various modules that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; together provide logical decoding, primarily by providing so<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; called LogicalDecodingContexts. The goal is to encapsulate most of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> complexity for consumers of logical decoding, so they can<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; create and consume a changestream with a low amount of code. Builtin<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; consumers are the walsender and SQL SRF interface, but it's possible to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; add further ones without changing core code, e.g. to consume changes in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; a bgworker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The idea is that a consumer provides three callbacks, one to read WAL,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; one to prepare a data write, and a final one for actually writing since<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; their implementation depends on the type of consumer.&nbsp; Check<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; logicalfuncs.c for an example implementation of a fairly simple consumer<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and an implementation of a WAL reading callback that's suitable for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; simple consumers.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;fmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/decode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/reorderbuffer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/snapbuild.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* data for errcontext callback */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LogicalErrorCallbackState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *callback_name;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; report_location;<br/></li>
<li><a id="L53">&#x200c;</a>} <span class="linkable">LogicalErrorCallbackState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* wrappers around output plugin callbacks */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L790" title="replication/logical/logical.c:790">startup_cb_wrapper</a>(LogicalDecodingContext *ctx, OutputPluginOptions *opt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_init);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L818" title="replication/logical/logical.c:818">shutdown_cb_wrapper</a>(LogicalDecodingContext *ctx);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L851" title="replication/logical/logical.c:851">begin_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L882" title="replication/logical/logical.c:882">commit_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L921" title="replication/logical/logical.c:921">begin_prepare_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L965" title="replication/logical/logical.c:965">prepare_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1010" title="replication/logical/logical.c:1010">commit_prepared_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1055" title="replication/logical/logical.c:1055">rollback_prepared_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_end_lsn, TimestampTz prepare_time);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1102" title="replication/logical/logical.c:1102">change_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1141" title="replication/logical/logical.c:1141">truncate_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nrelations, Relation relations[], ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1246" title="replication/logical/logical.c:1246">message_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr message_lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *prefix, Size message_size, <span class="Type">const</span> <span class="Type">char</span> *message);<br/></li>
<li><br/></li>
<li><span class="Comment">/* streaming callbacks */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1283" title="replication/logical/logical.c:1283">stream_start_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr first_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1332" title="replication/logical/logical.c:1332">stream_stop_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr last_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1381" title="replication/logical/logical.c:1381">stream_abort_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr abort_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1422" title="replication/logical/logical.c:1422">stream_prepare_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr prepare_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1467" title="replication/logical/logical.c:1467">stream_commit_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1508" title="replication/logical/logical.c:1508">stream_change_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation relation, ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1557" title="replication/logical/logical.c:1557">stream_message_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr message_lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *prefix, Size message_size, <span class="Type">const</span> <span class="Type">char</span> *message);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1598" title="replication/logical/logical.c:1598">stream_truncate_cb_wrapper</a>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nrelations, Relation relations[], ReorderBufferChange *change);<br/></li>
<li><br/></li>
<li><span class="Comment">/* callback to update txn's progress */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1645" title="replication/logical/logical.c:1645">update_progress_txn_cb_wrapper</a>(ReorderBuffer *cache,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L749" title="replication/logical/logical.c:749">LoadOutputPlugin</a>(OutputPluginCallbacks *callbacks, <span class="Type">const</span> <span class="Type">char</span> *plugin);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure the current settings &amp; environment are capable of doing logical<br/></li>
<li></span><span class="Comment"> * decoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="linkable">CheckLogicalDecodingRequirements</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../slot.c.html#L1362" title="replication/slot.c:1362">CheckSlotRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: Adding a new requirement likely means that <a href="../slot.c.html#L2175" title="replication/slot.c:2175">RestoreSlotFromDisk</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs the same check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &lt; WAL_LEVEL_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding requires <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= logical&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding requires a database connection&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This check may have race conditions, but whenever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLOG_PARAMETER_CHANGE indicates that <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> has changed, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * verify that there are no existing logical replication slots. And to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid races around creating a new slot,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L109" title="replication/logical/logical.c:109">CheckLogicalDecodingRequirements</a>() is called once <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> creating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the slot, and once when logical decoding is initially starting up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L4826" title="access/transam/xlog.c:4826">GetActiveWalLevelOnStandby</a>() &lt; WAL_LEVEL_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical decoding on standby requires <a href="../../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= logical on the primary&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L329" title="replication/logical/logical.c:329">CreateInitDecodingContext</a>() and<br/></li>
<li></span><span class="Comment"> * <a href="#L495" title="replication/logical/logical.c:495">CreateDecodingContext</a>() performing common tasks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> LogicalDecodingContext *<br/></li>
<li><a id="L150">&#x200c;</a><span class="linkable">StartupDecodingContext</span>(List *output_plugin_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId xmin_horizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> need_full_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fast_forward,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogReaderRoutine *xl_routine,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalOutputPluginWriterPrepareWrite prepare_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalOutputPluginWriterWrite do_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LogicalOutputPluginWriterUpdateProgress update_progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_context;<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* shorter lines... */<br/></li>
<li></span>&nbsp; &nbsp; slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Logical decoding context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(context);<br/></li>
<li>&nbsp; &nbsp; ctx = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalDecodingContext));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;context = context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (re-)load output plugins, so we detect a bad (removed) output plugin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!fast_forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L749" title="replication/logical/logical.c:749">LoadOutputPlugin</a>(&amp;ctx-&gt;callbacks, NameStr(slot-&gt;data.plugin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that the slot's xmin has been set, we can announce ourselves as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logical decoding backend which doesn't need to be checked individually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when computing the xmin horizon because the xmin is enforced via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can only do so if we're outside of a transaction (i.e. the case when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming changes via walsender), otherwise an already setup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot/xid would end up being ignored. That's not a particularly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bothersome restriction since the SQL interface can't be used for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags |= PROC_IN_LOGICAL_DECODING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff] = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;slot = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reader = <a href="../../access/transam/xlogreader.c.html#L106" title="access/transam/xlogreader.c:106">XLogReaderAllocate</a>(<a href="../../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Constant">NULL</span>, xl_routine, ctx);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ctx-&gt;reader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed while allocating a WAL reading processor.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder = <a href="reorderbuffer.c.html#L309" title="replication/logical/reorderbuffer.c:309">ReorderBufferAllocate</a>();<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;snapshot_builder =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="snapbuild.c.html#L316" title="replication/logical/snapbuild.c:316">AllocateSnapshotBuilder</a>(ctx-&gt;reorder, xmin_horizon, start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_full_snapshot, slot-&gt;data.two_phase_at);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;private_data = ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wrap output plugin callbacks, so we can add error context information */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;reorder-&gt;begin = <a href="#L851" title="replication/logical/logical.c:851">begin_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;apply_change = <a href="#L1102" title="replication/logical/logical.c:1102">change_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;apply_truncate = <a href="#L1141" title="replication/logical/logical.c:1141">truncate_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;commit = <a href="#L882" title="replication/logical/logical.c:882">commit_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;message = <a href="#L1246" title="replication/logical/logical.c:1246">message_cb_wrapper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To support streaming, we require start/stop/abort/commit/change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callbacks. The message and truncate callbacks are optional, similar to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular output plugins. We however enable streaming when at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the methods is enabled so that we can easily identify missing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * methods.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We decide it here, but only check it later in the wrappers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;streaming = (ctx-&gt;callbacks.stream_start_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.stream_stop_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.stream_abort_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.stream_commit_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.stream_change_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.stream_message_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.stream_truncate_cb != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming callbacks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stream_message and stream_truncate callbacks are optional, so we do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail with ERROR when missing, but the wrappers simply do nothing. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must set the ReorderBuffer callbacks to something, otherwise the calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from there will crash (we don't want to move the checks there).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_start = <a href="#L1283" title="replication/logical/logical.c:1283">stream_start_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_stop = <a href="#L1332" title="replication/logical/logical.c:1332">stream_stop_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_abort = <a href="#L1381" title="replication/logical/logical.c:1381">stream_abort_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_prepare = <a href="#L1422" title="replication/logical/logical.c:1422">stream_prepare_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_commit = <a href="#L1467" title="replication/logical/logical.c:1467">stream_commit_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_change = <a href="#L1508" title="replication/logical/logical.c:1508">stream_change_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_message = <a href="#L1557" title="replication/logical/logical.c:1557">stream_message_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;stream_truncate = <a href="#L1598" title="replication/logical/logical.c:1598">stream_truncate_cb_wrapper</a>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To support two-phase logical decoding, we require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * begin_prepare/prepare/commit-prepare/abort-prepare callbacks. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filter_prepare callback is optional. We however enable two-phase<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logical decoding when at least one of the methods is enabled so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can easily identify missing methods.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We decide it here, but only check it later in the wrappers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;twophase = (ctx-&gt;callbacks.begin_prepare_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.prepare_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.commit_prepared_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.rollback_prepared_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.stream_prepare_cb != <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ctx-&gt;callbacks.filter_prepare_cb != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Callback to support decoding at prepare time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;reorder-&gt;begin_prepare = <a href="#L921" title="replication/logical/logical.c:921">begin_prepare_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;prepare = <a href="#L965" title="replication/logical/logical.c:965">prepare_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;commit_prepared = <a href="#L1010" title="replication/logical/logical.c:1010">commit_prepared_cb_wrapper</a>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;rollback_prepared = <a href="#L1055" title="replication/logical/logical.c:1055">rollback_prepared_cb_wrapper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Callback to support updating progress during sending data of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction (and its subtransactions) to the output plugin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;reorder-&gt;update_progress_txn = <a href="#L1645" title="replication/logical/logical.c:1645">update_progress_txn_cb_wrapper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;out = makeStringInfo();<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;prepare_write = prepare_write;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write = do_write;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;update_progress = update_progress;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;output_plugin_options = output_plugin_options;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;fast_forward = fast_forward;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ctx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new decoding context, for a new logical slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * plugin -- contains the name of the output plugin<br/></li>
<li></span><span class="Comment"> * output_plugin_options -- contains options passed to the output plugin<br/></li>
<li></span><span class="Comment"> * need_full_snapshot -- if true, must obtain a snapshot able to read all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tables; if false, one that can read only catalogs is acceptable.<br/></li>
<li></span><span class="Comment"> * restart_lsn -- if given as invalid, it's this routine's responsibility to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; mark WAL as reserved by setting a convenient restart_lsn for the slot.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Otherwise, we set for decoding to start from the given LSN without<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; marking WAL reserved beforehand.&nbsp; In that scenario, it's up to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; caller to guarantee that WAL remains available.<br/></li>
<li></span><span class="Comment"> * xl_routine -- XLogReaderRoutine for underlying XLogReader<br/></li>
<li></span><span class="Comment"> * prepare_write, do_write, update_progress --<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; callbacks that perform the use-case dependent, actual, work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needs to be called while in a memory context that's at least as long lived<br/></li>
<li></span><span class="Comment"> * as the decoding context because further memory contexts will be created<br/></li>
<li></span><span class="Comment"> * inside it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an initialized decoding context after calling the output plugin's<br/></li>
<li></span><span class="Comment"> * startup function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalDecodingContext *<br/></li>
<li><a id="L329">&#x200c;</a><span class="linkable">CreateInitDecodingContext</span>(<span class="Type">const</span> <span class="Type">char</span> *plugin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *output_plugin_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> need_full_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr restart_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogReaderRoutine *xl_routine,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalOutputPluginWriterPrepareWrite prepare_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalOutputPluginWriterWrite do_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalOutputPluginWriterUpdateProgress update_progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin_horizon = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot;<br/></li>
<li>&nbsp; &nbsp; NameData&nbsp; &nbsp; plugin_name;<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On a standby, this check is also required while creating the slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the comments in the function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L109" title="replication/logical/logical.c:109">CheckLogicalDecodingRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* shorter lines... */<br/></li>
<li></span>&nbsp; &nbsp; slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first some sanity checks that are unlikely to be violated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot perform logical decoding without an acquired slot&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plugin == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> logical decoding without a specified plugin&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the passed slot is suitable. These are user facing errors. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SlotIsPhysical(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use physical replication slot for logical decoding&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.database != <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> was not created in this database&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(slot-&gt;data.name))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>() != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot create logical replication slot in transaction that has performed writes&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register output plugin name with slot.&nbsp; We need the mutex to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent reading of a partially copied string.&nbsp; But we don't want <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complicated code while holding a spinlock, so do <a href="../../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>() outside.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;plugin_name, plugin);<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;data.plugin = plugin_name;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1401" title="replication/slot.c:1401">ReplicationSlotReserveWal</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.restart_lsn = restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tricky: We need to determine a safe xmin horizon to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoding from, to avoid starting from a running xacts record referring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to xids whose rows have been vacuumed or pruned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already. <a href="../../storage/ipc/procarray.c.html#L2932" title="storage/ipc/procarray.c:2932">GetOldestSafeDecodingTransactionId</a>() returns such a value, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without further interlock its return value might immediately be out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we have to acquire the ProcArrayLock to prevent computation of new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmin horizons by other backends, get the safe decoding xid, and inform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the slot machinery about the new limit. Once that's done the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ProcArrayLock can be released as the slot machinery <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protecting against <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that, temporarily, the data, not just the catalog, xmin has to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserved if a data snapshot is to be exported.&nbsp; Otherwise the initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data snapshot created here is not guaranteed to be valid. After that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the data xmin doesn't need to be managed anymore and the global xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be recomputed. As we are fine with losing the pegged data xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after crash - no chance a snapshot would get exported anymore - we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get away with just setting the slot's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effective_xmin. <a href="../slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a> will reset it again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmin_horizon = <a href="../../storage/ipc/procarray.c.html#L2932" title="storage/ipc/procarray.c:2932">GetOldestSafeDecodingTransactionId</a>(!need_full_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;effective_catalog_xmin = xmin_horizon;<br/></li>
<li>&nbsp; &nbsp; slot-&gt;data.catalog_xmin = xmin_horizon;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (need_full_snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;effective_xmin = xmin_horizon;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../slot.c.html#L1049" title="replication/slot.c:1049">ReplicationSlotsComputeRequiredXmin</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx = <a href="#L150" title="replication/logical/logical.c:150">StartupDecodingContext</a>(NIL, restart_lsn, xmin_horizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; need_full_snapshot, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xl_routine, prepare_write, do_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; update_progress);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call output plugin initialization callback */<br/></li>
<li></span>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(ctx-&gt;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.startup_cb != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L790" title="replication/logical/logical.c:790">startup_cb_wrapper</a>(ctx, &amp;ctx-&gt;options, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allow decoding of prepared transactions when the two_phase is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enabled at the time of slot creation, or when the two_phase option is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * given at the streaming start, provided the plugin supports all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callbacks for two-phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;twophase &amp;= slot-&gt;data.two_phase;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;output_rewrites = ctx-&gt;options.receive_rewrites;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ctx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new decoding context, for a logical slot that has previously been<br/></li>
<li></span><span class="Comment"> * used already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * start_lsn<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The LSN at which to start decoding.&nbsp; If InvalidXLogRecPtr, restart<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from the slot's confirmed_flush; otherwise, start from the specified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; location (but move it forwards to confirmed_flush if it's older than<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that, see below).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * output_plugin_options<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; options passed to the output plugin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * fast_forward<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; bypass the generation of logical changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xl_routine<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; XLogReaderRoutine used by underlying <a href="../walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * prepare_write, do_write, update_progress<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; callbacks that have to be filled to perform the use-case dependent,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; actual work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needs to be called while in a memory context that's at least as long lived<br/></li>
<li></span><span class="Comment"> * as the decoding context because further memory contexts will be created<br/></li>
<li></span><span class="Comment"> * inside it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an initialized decoding context after calling the output plugin's<br/></li>
<li></span><span class="Comment"> * startup function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>LogicalDecodingContext *<br/></li>
<li><a id="L495">&#x200c;</a><span class="linkable">CreateDecodingContext</span>(XLogRecPtr start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *output_plugin_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fast_forward,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogReaderRoutine *xl_routine,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalOutputPluginWriterPrepareWrite prepare_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalOutputPluginWriterWrite do_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalOutputPluginWriterUpdateProgress update_progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* shorter lines... */<br/></li>
<li></span>&nbsp; &nbsp; slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first some sanity checks that are unlikely to be violated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot perform logical decoding without an acquired slot&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure the passed slot is suitable, these are user facing errors */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SlotIsPhysical(slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use physical replication slot for logical decoding&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to access the system tables during decoding to build the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logical changes unless we are in fast_forward mode where no changes are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.database != <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> &amp;&amp; !fast_forward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> was not created in this database&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(slot-&gt;data.name))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The slots being synced from the primary can't be used for decoding as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are used after failover. However, we do allow advancing the LSNs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during the synchronization of slots. See <a href="slotsync.c.html#L168" title="replication/logical/slotsync.c:168">update_local_synced_slot</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() &amp;&amp; slot-&gt;data.synced &amp;&amp; !<a href="slotsync.c.html#L1650" title="replication/logical/slotsync.c:1650">IsSyncingReplicationSlots</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for logical decoding&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(slot-&gt;data.name)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This slot is being synchronized from the primary server.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Specify another replication slot.&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if slot has been invalidated due to max_slot_wal_keep_size. Avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;cannot get changes&quot; wording in this <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a> because that'd be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confusingly ambiguous about no changes being available when called from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="logicalfuncs.c.html#L99" title="replication/logical/logicalfuncs.c:99">pg_logical_slot_get_changes_guts</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.invalidated == RS_INVAL_WAL_REMOVED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;can no longer get changes from replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This slot has been invalidated because it exceeded the maximum reserved size.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.invalidated != RS_INVAL_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;can no longer get changes from replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This slot has been invalidated because it was conflicting with recovery.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.invalidated == RS_INVAL_NONE);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (start_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continue from last position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; start_lsn = slot-&gt;data.confirmed_flush;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (start_lsn &lt; slot-&gt;data.confirmed_flush)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It might seem like we should error out in this case, but it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pretty common for a client to acknowledge a LSN it doesn't have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do anything for, and thus didn't store persistently, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xlog <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> didn't result in anything relevant for logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoding. Clients have to be able to do that to support synchronous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Starting at a different LSN than requested might not catch certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * kinds of client errors; so the client may wish to check that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confirmed_flush_lsn matches its expectations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> has been already streamed, forwarding to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(slot-&gt;data.confirmed_flush));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start_lsn = slot-&gt;data.confirmed_flush;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx = <a href="#L150" title="replication/logical/logical.c:150">StartupDecodingContext</a>(output_plugin_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; start_lsn, InvalidTransactionId, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fast_forward, xl_routine, prepare_write,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; do_write, update_progress);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call output plugin initialization callback */<br/></li>
<li></span>&nbsp; &nbsp; old_context = MemoryContextSwitchTo(ctx-&gt;context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.startup_cb != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L790" title="replication/logical/logical.c:790">startup_cb_wrapper</a>(ctx, &amp;ctx-&gt;options, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allow decoding of prepared transactions when the two_phase is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enabled at the time of slot creation, or when the two_phase option is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * given at the streaming start, provided the plugin supports all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callbacks for two-phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;twophase &amp;= (slot-&gt;data.two_phase || ctx-&gt;twophase_opt_given);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark slot to allow two_phase decoding if not already marked */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;twophase &amp;&amp; !slot-&gt;data.two_phase)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.two_phase = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.two_phase_at = start_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="snapbuild.c.html#L424" title="replication/logical/snapbuild.c:424">SnapBuildSetTwoPhaseAt</a>(ctx-&gt;snapshot_builder, start_lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;reorder-&gt;output_rewrites = ctx-&gt;options.receive_rewrites;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting logical decoding for slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(slot-&gt;data.name)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Streaming transactions committing after </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, reading WAL from </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(slot-&gt;data.confirmed_flush),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(slot-&gt;data.restart_lsn))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ctx;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if a consistent initial decoding snapshot has been built.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L640">&#x200c;</a></span><span class="linkable">DecodingContextReady</span>(LogicalDecodingContext *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="snapbuild.c.html#L406" title="replication/logical/snapbuild.c:406">SnapBuildCurrentState</a>(ctx-&gt;snapshot_builder) == SNAPBUILD_CONSISTENT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read from the decoding slot, until it is ready to start extracting changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L649">&#x200c;</a></span><span class="linkable">DecodingContextFindStartpoint</span>(LogicalDecodingContext *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot = ctx-&gt;slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize from where to start reading WAL. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(ctx-&gt;reader, slot-&gt;data.restart_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;searching for logical decoding starting point, starting at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(slot-&gt;data.restart_lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wait for a consistent starting point */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *err = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the read_page callback waits for new WAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; record = <a href="../../access/transam/xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>(ctx-&gt;reader, &amp;err);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (err)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> logical decoding starting point: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, err);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> logical decoding starting point&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="decode.c.html#L88" title="replication/logical/decode.c:88">LogicalDecodingProcessRecord</a>(ctx, ctx-&gt;reader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only continue till we found a consistent spot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L640" title="replication/logical/logical.c:640">DecodingContextReady</a>(ctx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; slot-&gt;data.confirmed_flush = ctx-&gt;reader-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;data.two_phase)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;data.two_phase_at = ctx-&gt;reader-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a previously allocated decoding context, invoking the shutdown<br/></li>
<li></span><span class="Comment"> * callback if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L693">&#x200c;</a></span><span class="linkable">FreeDecodingContext</span>(LogicalDecodingContext *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.shutdown_cb != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L818" title="replication/logical/logical.c:818">shutdown_cb_wrapper</a>(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="reorderbuffer.c.html#L396" title="replication/logical/reorderbuffer.c:396">ReorderBufferFree</a>(ctx-&gt;reorder);<br/></li>
<li>&nbsp; &nbsp; <a href="snapbuild.c.html#L362" title="replication/logical/snapbuild.c:362">FreeSnapshotBuilder</a>(ctx-&gt;snapshot_builder);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xlogreader.c.html#L161" title="access/transam/xlogreader.c:161">XLogReaderFree</a>(ctx-&gt;reader);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(ctx-&gt;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare a write using the context's output routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L708">&#x200c;</a></span><span class="linkable">OutputPluginPrepareWrite</span>(<span class="Type">struct</span> LogicalDecodingContext *ctx, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> last_write)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ctx-&gt;accept_writes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;writes are only accepted in commit, begin and change callbacks&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;prepare_write(ctx, ctx-&gt;write_location, ctx-&gt;write_xid, last_write);<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;prepared_write = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a write using the context's output routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L721">&#x200c;</a></span><span class="linkable">OutputPluginWrite</span>(<span class="Type">struct</span> LogicalDecodingContext *ctx, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> last_write)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ctx-&gt;prepared_write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a> needs to be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write(ctx, ctx-&gt;write_location, ctx-&gt;write_xid, last_write);<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;prepared_write = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update progress tracking (if supported).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L734">&#x200c;</a></span><span class="linkable">OutputPluginUpdateProgress</span>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipped_xact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ctx-&gt;update_progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;update_progress(ctx, ctx-&gt;write_location, ctx-&gt;write_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; skipped_xact);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load the output plugin, lookup its output plugin init function, and check<br/></li>
<li></span><span class="Comment"> * that it provides the required callbacks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L749">&#x200c;</a></span><span class="linkable">LoadOutputPlugin</span>(OutputPluginCallbacks *callbacks, <span class="Type">const</span> <span class="Type">char</span> *plugin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalOutputPluginInit plugin_init;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; plugin_init = (LogicalOutputPluginInit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>(plugin, <span class="Constant">&quot;<a href="../pgoutput/pgoutput.c.html#L247" title="replication/pgoutput/pgoutput.c:247">_PG_output_plugin_init</a>&quot;</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plugin_init == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;output plugins have to declare the <a href="../pgoutput/pgoutput.c.html#L247" title="replication/pgoutput/pgoutput.c:247">_PG_output_plugin_init</a> symbol&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ask the output plugin to fill the callback struct */<br/></li>
<li></span>&nbsp; &nbsp; plugin_init(callbacks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (callbacks-&gt;begin_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;output plugins have to register a begin callback&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (callbacks-&gt;change_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;output plugins have to register a change callback&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (callbacks-&gt;commit_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;output plugins have to register a commit callback&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L771">&#x200c;</a></span><span class="linkable">output_plugin_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> *state = (<a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not all callbacks have an associated LSN&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;report_location != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, output plugin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, in the </span><span class="Special">%s</span><span class="Constant"> callback, associated LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(state-&gt;ctx-&gt;slot-&gt;data.name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(state-&gt;ctx-&gt;slot-&gt;data.plugin),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;callback_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(state-&gt;report_location));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, output plugin </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, in the </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(state-&gt;ctx-&gt;slot-&gt;data.name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(state-&gt;ctx-&gt;slot-&gt;data.plugin),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;callback_name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L790">&#x200c;</a></span><span class="linkable">startup_cb_wrapper</span>(LogicalDecodingContext *ctx, OutputPluginOptions *opt, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_init)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;startup&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.startup_cb(ctx, opt, is_init);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L818">&#x200c;</a></span><span class="linkable">shutdown_cb_wrapper</span>(LogicalDecodingContext *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;shutdown&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.shutdown_cb(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callbacks for ReorderBuffer which add in some more information and then call<br/></li>
<li></span><span class="Comment"> * output_plugin.h plugins.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L851">&#x200c;</a></span><span class="linkable">begin_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;begin&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;first_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;first_lsn;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.begin_cb(ctx, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="linkable">commit_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;commit&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;final_lsn; <span class="Comment">/* beginning of commit record */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;end_lsn; <span class="Comment">/* points to the end of the record */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.commit_cb(ctx, txn, commit_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The functionality of begin_prepare is quite similar to begin with the<br/></li>
<li></span><span class="Comment"> * exception that this will have gid (global transaction id) information which<br/></li>
<li></span><span class="Comment"> * can be used by plugin. Now, we thought about extending the existing begin<br/></li>
<li></span><span class="Comment"> * but that would break the replication protocol and additionally this looks<br/></li>
<li></span><span class="Comment"> * cleaner.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L921">&#x200c;</a></span><span class="linkable">begin_prepare_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when two-phase commits are supported */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;twophase);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;begin_prepare&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;first_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;first_lsn;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the plugin supports two-phase commits then begin prepare callback is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mandatory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.begin_prepare_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication at prepare time requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;begin_prepare_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.begin_prepare_cb(ctx, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L965">&#x200c;</a></span><span class="linkable">prepare_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when two-phase commits are supported */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;twophase);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;prepare&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;final_lsn; <span class="Comment">/* beginning of prepare record */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;end_lsn; <span class="Comment">/* points to the end of the record */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the plugin supports two-phase commits then prepare callback is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mandatory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.prepare_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication at prepare time requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;prepare_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.prepare_cb(ctx, txn, prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1010">&#x200c;</a></span><span class="linkable">commit_prepared_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when two-phase commits are supported */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;twophase);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;commit_prepared&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;final_lsn; <span class="Comment">/* beginning of commit record */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;end_lsn; <span class="Comment">/* points to the end of the record */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the plugin support two-phase commits then commit prepared callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is mandatory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.commit_prepared_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication at prepare time requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commit_prepared_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.commit_prepared_cb(ctx, txn, commit_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1055">&#x200c;</a></span><span class="linkable">rollback_prepared_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz prepare_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when two-phase commits are supported */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;twophase);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;rollback_prepared&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;final_lsn; <span class="Comment">/* beginning of commit record */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;end_lsn; <span class="Comment">/* points to the end of the record */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the plugin support two-phase commits then rollback prepared callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is mandatory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.rollback_prepared_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical replication at prepare time requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;rollback_prepared_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.rollback_prepared_cb(ctx, txn, prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prepare_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1102">&#x200c;</a></span><span class="linkable">change_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;change&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report this change's lsn so replies from clients can give an up-to-date<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answer. This won't ever be enough (and shouldn't be!) to confirm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receipt of this transaction, but it might allow another transaction's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit to be confirmed with one message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;write_location = change-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.change_cb(ctx, txn, relation, change);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1141">&#x200c;</a></span><span class="linkable">truncate_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nrelations, Relation relations[], ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ctx-&gt;callbacks.truncate_cb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;truncate&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report this change's lsn so replies from clients can give an up-to-date<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answer. This won't ever be enough (and shouldn't be!) to confirm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receipt of this transaction, but it might allow another transaction's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit to be confirmed with one message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;write_location = change-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.truncate_cb(ctx, txn, nrelations, relations, change);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1183">&#x200c;</a></span><span class="linkable">filter_prepare_cb_wrapper</span>(LogicalDecodingContext *ctx, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;filter_prepare&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ret = ctx-&gt;callbacks.filter_prepare_cb(ctx, xid, gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1215">&#x200c;</a></span><span class="linkable">filter_by_origin_cb_wrapper</span>(LogicalDecodingContext *ctx, RepOriginId origin_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;filter_by_origin&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ret = ctx-&gt;callbacks.filter_by_origin_cb(ctx, origin_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1246">&#x200c;</a></span><span class="linkable">message_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr message_lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *prefix, Size message_size, <span class="Type">const</span> <span class="Type">char</span> *message)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.message_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;message&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = message_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn != <span class="Constant">NULL</span> ? txn-&gt;xid : InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = message_lsn;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.message_cb(ctx, txn, message_lsn, transactional, prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; message_size, message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1283">&#x200c;</a></span><span class="linkable">stream_start_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr first_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when streaming is supported. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_start&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = first_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report this message's lsn so replies from clients can give an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up-to-date answer. This won't ever be enough (and shouldn't be!) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confirm receipt of this transaction, but it might allow another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction's commit to be confirmed with one message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;write_location = first_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in streaming mode, stream_start_cb is required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.stream_start_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical streaming requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;stream_start_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.stream_start_cb(ctx, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1332">&#x200c;</a></span><span class="linkable">stream_stop_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr last_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when streaming is supported. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_stop&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = last_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report this message's lsn so replies from clients can give an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up-to-date answer. This won't ever be enough (and shouldn't be!) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confirm receipt of this transaction, but it might allow another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction's commit to be confirmed with one message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;write_location = last_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in streaming mode, stream_stop_cb is required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.stream_stop_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical streaming requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;stream_stop_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.stream_stop_cb(ctx, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1381">&#x200c;</a></span><span class="linkable">stream_abort_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr abort_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when streaming is supported. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_abort&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = abort_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = abort_lsn;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in streaming mode, stream_abort_cb is required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.stream_abort_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical streaming requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;stream_abort_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.stream_abort_cb(ctx, txn, abort_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1422">&#x200c;</a></span><span class="linkable">stream_prepare_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr prepare_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're only supposed to call this when streaming and two-phase commits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are supported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li>&nbsp; &nbsp; Assert(ctx-&gt;twophase);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_prepare&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;final_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;end_lsn;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in streaming mode with two-phase commits, stream_prepare_cb is required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.stream_prepare_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical streaming at prepare time requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;stream_prepare_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.stream_prepare_cb(ctx, txn, prepare_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1467">&#x200c;</a></span><span class="linkable">stream_commit_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when streaming is supported. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_commit&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = txn-&gt;final_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = txn-&gt;end_lsn;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in streaming mode, stream_commit_cb is required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.stream_commit_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical streaming requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;stream_commit_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.stream_commit_cb(ctx, txn, commit_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1508">&#x200c;</a></span><span class="linkable">stream_change_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation relation, ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when streaming is supported. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_change&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report this change's lsn so replies from clients can give an up-to-date<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answer. This won't ever be enough (and shouldn't be!) to confirm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receipt of this transaction, but it might allow another transaction's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit to be confirmed with one message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;write_location = change-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in streaming mode, stream_change_cb is required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.stream_change_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;logical streaming requires a </span><span class="Special">%s</span><span class="Constant"> callback&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;stream_change_cb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.stream_change_cb(ctx, txn, relation, change);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1557">&#x200c;</a></span><span class="linkable">stream_message_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr message_lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *prefix, Size message_size, <span class="Type">const</span> <span class="Type">char</span> *message)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when streaming is supported. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this callback is optional */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;callbacks.stream_message_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_message&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = message_lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn != <span class="Constant">NULL</span> ? txn-&gt;xid : InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_location = message_lsn;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual work: call callback */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;callbacks.stream_message_cb(ctx, txn, message_lsn, transactional, prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; message_size, message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1598">&#x200c;</a></span><span class="linkable">stream_truncate_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nrelations, Relation relations[],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're only supposed to call this when streaming is supported. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctx-&gt;streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this callback is optional */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ctx-&gt;callbacks.stream_truncate_cb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;stream_truncate&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = change-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report this change's lsn so replies from clients can give an up-to-date<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answer. This won't ever be enough (and shouldn't be!) to confirm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receipt of this transaction, but it might allow another transaction's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit to be confirmed with one message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;write_location = change-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;callbacks.stream_truncate_cb(ctx, txn, nrelations, relations, change);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1645">&#x200c;</a></span><span class="linkable">update_progress_txn_cb_wrapper</span>(ReorderBuffer *cache, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = cache-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="replication/logical/logical.c:48">LogicalErrorCallbackState</a> state;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ctx-&gt;fast_forward);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Push callback + info on the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; state.ctx = ctx;<br/></li>
<li>&nbsp; &nbsp; state.callback_name = <span class="Constant">&quot;update_progress_txn&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; state.report_location = lsn;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L771" title="replication/logical/logical.c:771">output_plugin_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) &amp;state;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set output state */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;accept_writes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ctx-&gt;write_xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report this change's lsn so replies from clients can give an up-to-date<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answer. This won't ever be enough (and shouldn't be!) to confirm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receipt of this transaction, but it might allow another transaction's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit to be confirmed with one message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx-&gt;write_location = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;end_xact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L734" title="replication/logical/logical.c:734">OutputPluginUpdateProgress</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the required catalog xmin horizon for historic snapshots in the current<br/></li>
<li></span><span class="Comment"> * replication slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that in the most cases, we won't be able to immediately use the xmin<br/></li>
<li></span><span class="Comment"> * to increase the xmin horizon: we need to wait till the client has confirmed<br/></li>
<li></span><span class="Comment"> * receiving current_lsn with <a href="#L1834" title="replication/logical/logical.c:1834">LogicalConfirmReceivedLocation</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1692">&#x200c;</a></span><span class="linkable">LogicalIncreaseXminForSlot</span>(XLogRecPtr current_lsn, TransactionId xmin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_xmin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; got_new_xmin = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't overwrite if we already have a newer xmin. This can happen if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart decoding in a slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(xmin, slot-&gt;data.catalog_xmin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the client has already confirmed up to this lsn, we directly can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark this as accepted. This can happen if we restart decoding in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (current_lsn &lt;= slot-&gt;data.confirmed_flush)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_catalog_xmin = xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_xmin_lsn = current_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* our candidate can directly be used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_xmin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only increase if the previous <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have been applied, otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might never end up updating if the receiver acks too slowly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (slot-&gt;candidate_xmin_lsn == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_catalog_xmin = xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_xmin_lsn = current_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Log new xmin at an appropriate log level after releasing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spinlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; got_new_xmin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (got_new_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;got new catalog xmin </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>, xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(current_lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* candidate already valid with the current flush position, apply */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updated_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1834" title="replication/logical/logical.c:1834">LogicalConfirmReceivedLocation</a>(slot-&gt;data.confirmed_flush);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark the minimal LSN (restart_lsn) we need to read to replay all<br/></li>
<li></span><span class="Comment"> * transactions that have not yet committed at current_lsn.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Just like <a href="#L1692" title="replication/logical/logical.c:1692">LogicalIncreaseXminForSlot</a> this only takes effect when the<br/></li>
<li></span><span class="Comment"> * client has confirmed to have received current_lsn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1760">&#x200c;</a></span><span class="linkable">LogicalIncreaseRestartDecodingForSlot</span>(XLogRecPtr current_lsn, XLogRecPtr restart_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_lsn = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(slot != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(restart_lsn != InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; Assert(current_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't overwrite if have a newer restart lsn */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (restart_lsn &lt;= slot-&gt;data.restart_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might have already flushed far enough to directly <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> this lsn,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in this case there is no need to check for existing candidate LSNs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (current_lsn &lt;= slot-&gt;data.confirmed_flush)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_restart_valid = current_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_restart_lsn = restart_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* our candidate can directly be used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_lsn = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only increase if the previous <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have been applied, otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might never end up updating if the receiver acks too slowly. A missed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value here will just cause some extra effort after reconnecting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;candidate_restart_valid == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_restart_valid = current_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;candidate_restart_lsn = restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;got new restart lsn </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(restart_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(current_lsn));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; candidate_restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; candidate_restart_valid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; confirmed_flush;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidate_restart_lsn = slot-&gt;candidate_restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; candidate_restart_valid = slot-&gt;candidate_restart_valid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; confirmed_flush = slot-&gt;data.confirmed_flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;failed to increase restart lsn: proposed </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, after </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, current candidate </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, current after </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, flushed up to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(restart_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(current_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(candidate_restart_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(candidate_restart_valid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(confirmed_flush));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* candidates are already valid with the current flush position, apply */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updated_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1834" title="replication/logical/logical.c:1834">LogicalConfirmReceivedLocation</a>(slot-&gt;data.confirmed_flush);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle a consumer's confirmation having received all changes up to lsn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1834">&#x200c;</a></span><span class="linkable">LogicalConfirmReceivedLocation</span>(XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do an unlocked check for candidate_lsn first. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_xmin_lsn != InvalidXLogRecPtr ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_restart_valid != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_xmin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated_restart = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we're past the location required for bumping xmin, do so */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_xmin_lsn != InvalidXLogRecPtr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_xmin_lsn &lt;= lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to write the changed xmin to disk *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* we change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the in-memory value, otherwise after a crash we wouldn't know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that some catalog tuples might have been removed already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure that by first writing to -&gt;xmin and only update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * -&gt;effective_xmin once the new state is synced to disk. After a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash -&gt;effective_xmin is set to -&gt;xmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_catalog_xmin) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.catalog_xmin != <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_catalog_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.catalog_xmin = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_catalog_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_xmin_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updated_xmin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_restart_valid != InvalidXLogRecPtr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_restart_valid &lt;= lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_restart_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_restart_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;candidate_restart_valid = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updated_restart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first write new xmin to disk, so we know what's up after a crash */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (updated_xmin || updated_restart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;updated xmin: </span><span class="Special">%u</span><span class="Constant"> restart: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, updated_xmin, updated_restart);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now the new xmin is safely on disk, we can let the global value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance. We do not take ProcArrayLock or similar since we only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance xmin here and there's not much harm done by a concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * computation missing that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (updated_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;effective_catalog_xmin = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1049" title="replication/slot.c:1049">ReplicationSlotsComputeRequiredXmin</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1105" title="replication/slot.c:1105">ReplicationSlotsComputeRequiredLSN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear logical streaming state during (sub)transaction abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1921">&#x200c;</a></span><span class="linkable">ResetLogicalStreamingState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L98" title="access/transam/xact.c:98">bsysscan</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report stats for a slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1931">&#x200c;</a></span><span class="linkable">UpdateDecodingStats</span>(LogicalDecodingContext *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBuffer *rb = ctx-&gt;reorder;<br/></li>
<li>&nbsp; &nbsp; PgStat_StatReplSlotEntry repSlotStat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if we don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> replication stats to be sent. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rb-&gt;spillBytes &lt;= <span class="Constant">0</span> &amp;&amp; rb-&gt;streamBytes &lt;= <span class="Constant">0</span> &amp;&amp; rb-&gt;totalBytes &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;<a href="#L1931" title="replication/logical/logical.c:1931">UpdateDecodingStats</a>: updating stats </span><span class="Special">%p</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;spillTxns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;spillCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;spillBytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;streamTxns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;streamCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;streamBytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;totalTxns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) rb-&gt;totalBytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; repSlotStat.spill_txns = rb-&gt;spillTxns;<br/></li>
<li>&nbsp; &nbsp; repSlotStat.spill_count = rb-&gt;spillCount;<br/></li>
<li>&nbsp; &nbsp; repSlotStat.spill_bytes = rb-&gt;spillBytes;<br/></li>
<li>&nbsp; &nbsp; repSlotStat.stream_txns = rb-&gt;streamTxns;<br/></li>
<li>&nbsp; &nbsp; repSlotStat.stream_count = rb-&gt;streamCount;<br/></li>
<li>&nbsp; &nbsp; repSlotStat.stream_bytes = rb-&gt;streamBytes;<br/></li>
<li>&nbsp; &nbsp; repSlotStat.total_txns = rb-&gt;totalTxns;<br/></li>
<li>&nbsp; &nbsp; repSlotStat.total_bytes = rb-&gt;totalBytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_replslot.c.html#L78" title="utils/activity/pgstat_replslot.c:78">pgstat_report_replslot</a>(ctx-&gt;slot, &amp;repSlotStat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rb-&gt;spillTxns = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;spillCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;spillBytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;streamTxns = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;streamCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;streamBytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;totalTxns = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rb-&gt;totalBytes = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read up to the end of WAL starting from the decoding slot's restart_lsn.<br/></li>
<li></span><span class="Comment"> * Return true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> meaningful/decodable WAL <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are encountered,<br/></li>
<li></span><span class="Comment"> * otherwise false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1978">&#x200c;</a></span><span class="linkable">LogicalReplicationSlotHasPendingWal</span>(XLogRecPtr end_of_wal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_pending_wal = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LogicalDecodingContext *ctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create our decoding context in fast_forward mode, passing start_lsn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as InvalidXLogRecPtr, so that we start processing from the slot's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confirmed_flush.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ctx = <a href="#L495" title="replication/logical/logical.c:495">CreateDecodingContext</a>(InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fast_forward */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = <a href="../../access/transam/xlogutils.c.html#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = <a href="../../access/transam/xlogutils.c.html#L817" title="access/transam/xlogutils.c:817">wal_segment_open</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = <a href="../../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start reading at the slot's restart_lsn, which we know points to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(ctx-&gt;reader, <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Invalidate non-timetravel entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop until the end of WAL or some changes are processed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!has_pending_wal &amp;&amp; ctx-&gt;reader-&gt;EndRecPtr &lt; end_of_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errm = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = <a href="../../access/transam/xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>(ctx-&gt;reader, &amp;errm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> record for logical decoding: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="decode.c.html#L88" title="replication/logical/decode.c:88">LogicalDecodingProcessRecord</a>(ctx, ctx-&gt;reader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_pending_wal = ctx-&gt;processing_required;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clean up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L693" title="replication/logical/logical.c:693">FreeDecodingContext</a>(ctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clear all timetravel entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> has_pending_wal;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for advancing our logical replication slot forward.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The slot's restart_lsn is used as start point for reading <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, while<br/></li>
<li></span><span class="Comment"> * confirmed_flush is used as base point for the decoding context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We cannot just do <a href="#L1834" title="replication/logical/logical.c:1834">LogicalConfirmReceivedLocation</a> to update confirmed_flush,<br/></li>
<li></span><span class="Comment"> * because we need to digest WAL to advance restart_lsn allowing to recycle<br/></li>
<li></span><span class="Comment"> * WAL and removal of old catalog tuples.&nbsp; As decoding is done in fast_forward<br/></li>
<li></span><span class="Comment"> * mode, no changes are generated anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *found_consistent_snapshot will be true if the initial decoding snapshot has<br/></li>
<li></span><span class="Comment"> * been built; Otherwise, it will be false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L2060">&#x200c;</a><span class="linkable">LogicalSlotAdvanceAndCheckSnapState</span>(XLogRecPtr moveto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *found_consistent_snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner old_resowner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; retlsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(moveto != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found_consistent_snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *found_consistent_snapshot = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create our decoding context in fast_forward mode, passing start_lsn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as InvalidXLogRecPtr, so that we start processing from my slot's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confirmed_flush.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ctx = <a href="#L495" title="replication/logical/logical.c:495">CreateDecodingContext</a>(InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fast_forward */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = <a href="../../access/transam/xlogutils.c.html#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = <a href="../../access/transam/xlogutils.c.html#L817" title="access/transam/xlogutils.c:817">wal_segment_open</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = <a href="../../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for specified streaming replication standby servers (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to confirm receipt of WAL up to moveto lsn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L2742" title="replication/slot.c:2742">WaitForStandbyConfirmation</a>(moveto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start reading at the slot's restart_lsn, which we know to point to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a valid record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(ctx-&gt;reader, <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* invalidate non-timetravel entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decode <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> until we reach the requested target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (ctx-&gt;reader-&gt;EndRecPtr &lt; moveto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errm = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecord *record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; No changes are generated in fast_forward mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but snapbuilder/slot statuses are updated properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = <a href="../../access/transam/xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>(ctx-&gt;reader, &amp;errm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> record while advancing replication slot: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errm);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process the record.&nbsp; Storage-level changes are ignored in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fast_forward mode, but other modules (such as snapbuilder)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might still have critical updates to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="decode.c.html#L88" title="replication/logical/decode.c:88">LogicalDecodingProcessRecord</a>(ctx, ctx-&gt;reader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_consistent_snapshot &amp;&amp; <a href="#L640" title="replication/logical/logical.c:640">DecodingContextReady</a>(ctx))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *found_consistent_snapshot = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Logical decoding could have clobbered <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction management, so restore the executor's value.&nbsp; (This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a kluge, but it's not worth cleaning up right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = old_resowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctx-&gt;reader-&gt;EndRecPtr != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1834" title="replication/logical/logical.c:1834">LogicalConfirmReceivedLocation</a>(moveto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If only the confirmed_flush LSN has changed the slot won't get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked as dirty by the above. Callers on the walsender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interface are expected to keep track of their own progress and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need it written out. But SQL-interface users cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specify their own start positions and it's harder for them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep track of their progress, so we should make more of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * effort to save it for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Dirty the slot so it is written out at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LSN position advanced to may still be lost on a crash but this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * makes the data consistent after a clean shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retlsn = <a href="../slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* free context, call shutdown callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L693" title="replication/logical/logical.c:693">FreeDecodingContext</a>(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clear all timetravel entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retlsn;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
