<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/walreceiver.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>replication/walreceiver.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L112">LogstreamResult</a></li>
<li><a href="#L93">WalReceiverFunctions</a></li>
<li><a href="#L89">hot_standby_feedback</a></li>
<li><a href="#L100">recvFile</a></li>
<li><a href="#L101">recvFileTLI</a></li>
<li><a href="#L102">recvSegNo</a></li>
<li><a href="#L131">reply_message</a></li>
<li><a href="#L129">wakeup</a></li>
<li><a href="#L87">wal_receiver_status_interval</a></li>
<li><a href="#L88">wal_receiver_timeout</a></li>
<li><a href="#L92">wrconn</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L117">WalRcvWakeupReason</a></li>
<li><a href="#L124">WalRcvWakeupReason</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L162">ProcessWalRcvInterrupts</a></li>
<li><a href="#L1265">ProcessWalSndrMessage</a></li>
<li><a href="#L1317">WalRcvComputeNextWakeup</a></li>
<li><a href="#L801">WalRcvDie</a></li>
<li><a href="#L745">WalRcvFetchTimeLineHistoryFiles</a></li>
<li><a href="#L1358">WalRcvForceReply</a></li>
<li><a href="#L1376">WalRcvGetStateString</a></li>
<li><a href="#L665">WalRcvWaitForStartPosition</a></li>
<li><a href="#L183">WalReceiverMain</a></li>
<li><a href="#L1048">XLogWalRcvClose</a></li>
<li><a href="#L993">XLogWalRcvFlush</a></li>
<li><a href="#L839">XLogWalRcvProcessMsg</a></li>
<li><a href="#L1169">XLogWalRcvSendHSFeedback</a></li>
<li><a href="#L1100">XLogWalRcvSendReply</a></li>
<li><a href="#L910">XLogWalRcvWrite</a></li>
<li><a href="#L1401">pg_stat_get_wal_receiver</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L123">NUM_WALRCV_WAKEUPS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * walreceiver.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The WAL receiver process (walreceiver) is new as of Postgres 9.0. It<br/></li>
<li></span><span class="Comment"> * is the process in the standby server that takes <a href="../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> of receiving<br/></li>
<li></span><span class="Comment"> * XLOG <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> from a primary server during streaming replication.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the startup process determines that it's time to start streaming,<br/></li>
<li></span><span class="Comment"> * it instructs postmaster to start walreceiver. Walreceiver first connects<br/></li>
<li></span><span class="Comment"> * to the primary server (it will be served by a walsender process<br/></li>
<li></span><span class="Comment"> * in the primary server), and then keeps receiving XLOG <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> and<br/></li>
<li></span><span class="Comment"> * writing them to the disk as long as the connection is alive. As XLOG<br/></li>
<li></span><span class="Comment"> * <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are received and flushed to disk, it updates the<br/></li>
<li></span><span class="Comment"> * <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;<a href="../access/transam/xlogrecovery.c.html#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> variable in shared memory, to inform the startup<br/></li>
<li></span><span class="Comment"> * process of how far it can proceed with XLOG replay.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A WAL receiver cannot directly load GUC parameters used when establishing<br/></li>
<li></span><span class="Comment"> * its connection to the primary. Instead it relies on parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * that are passed down by the startup process when streaming is requested.<br/></li>
<li></span><span class="Comment"> * This applies, for example, to the replication slot and the connection<br/></li>
<li></span><span class="Comment"> * string to be used for the connection with the primary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the primary server ends streaming, but doesn't disconnect, walreceiver<br/></li>
<li></span><span class="Comment"> * goes into &quot;<a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot; mode, and waits for the startup process to give new<br/></li>
<li></span><span class="Comment"> * instructions. The startup process will treat that the same as<br/></li>
<li></span><span class="Comment"> * disconnection, and will rescan the archive/pg_wal directory. But when the<br/></li>
<li></span><span class="Comment"> * startup process wants to try streaming replication again, it will just<br/></li>
<li></span><span class="Comment"> * nudge the existing walreceiver process that's <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>, instead of launching<br/></li>
<li></span><span class="Comment"> * a new one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normal termination is by SIGTERM, which instructs the walreceiver to<br/></li>
<li></span><span class="Comment"> * exit(0). Emergency termination is by SIGQUIT; like <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> postmaster child<br/></li>
<li></span><span class="Comment"> * process, the walreceiver will simply abort and exit on SIGQUIT. A close<br/></li>
<li></span><span class="Comment"> * of the connection and a FATAL error are treated not as a crash but as<br/></li>
<li></span><span class="Comment"> * normal operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains the server-facing parts of walreceiver. The libpq-<br/></li>
<li></span><span class="Comment"> * specific parts are in the libpqwalreceiver module. It's loaded<br/></li>
<li></span><span class="Comment"> * dynamically to avoid linking the server with libpq.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2010-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/walreceiver.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/timeline.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogarchive.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_authid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/auxprocess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC variables.&nbsp; (Other variables that affect walreceiver are in xlog.c<br/></li>
<li></span><span class="Comment"> * because they're passed down from the startup process, for better<br/></li>
<li></span><span class="Comment"> * synchronization.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_receiver_status_interval</span>;<br/></li>
<li><a id="L88">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_receiver_timeout</span>;<br/></li>
<li><a id="L89">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">hot_standby_feedback</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* libpqwalreceiver connection */<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="Type">static</span> <a href="libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<span class="linkable">wrconn</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L93">&#x200c;</a>WalReceiverFunctionsType *<span class="linkable">WalReceiverFunctions</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These variables are used similarly to <a href="../access/transam/xlog.c.html#L630" title="access/transam/xlog.c:630">openLogFile</a>/SegNo,<br/></li>
<li></span><span class="Comment"> * but for walreceiver to write the XLOG. <a href="#L101" title="replication/walreceiver.c:101">recvFileTLI</a> is the TimeLineID<br/></li>
<li></span><span class="Comment"> * corresponding the filename of <a href="#L100" title="replication/walreceiver.c:100">recvFile</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">recvFile</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L101">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">recvFileTLI</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L102">&#x200c;</a><span class="Type">static</span> XLogSegNo <span class="linkable">recvSegNo</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a> indicates the byte positions that we have already<br/></li>
<li></span><span class="Comment"> * written/fsynced.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Write;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last byte + 1 written out in the standby */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Flush;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last byte + 1 flushed in the standby */<br/></li>
<li><a id="L112">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">LogstreamResult</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reasons to wake up and perform periodic tasks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">WalRcvWakeupReason</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WALRCV_WAKEUP_TERMINATE,<br/></li>
<li>&nbsp; &nbsp; WALRCV_WAKEUP_PING,<br/></li>
<li>&nbsp; &nbsp; WALRCV_WAKEUP_REPLY,<br/></li>
<li>&nbsp; &nbsp; WALRCV_WAKEUP_HSFEEDBACK,<br/></li>
<li><a id="L123">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_WALRCV_WAKEUPS</span> (WALRCV_WAKEUP_HSFEEDBACK + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L124">&#x200c;</a></span>} <span class="linkable">WalRcvWakeupReason</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up times for periodic tasks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="Type">static</span> TimestampTz <span class="linkable">wakeup</span>[<a href="#L123" title="replication/walreceiver.c:123">NUM_WALRCV_WAKEUPS</a>];<br/></li>
<li><br/></li>
<li><a id="L131">&#x200c;</a><span class="Type">static</span> StringInfoData <span class="linkable">reply_message</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Prototypes for private <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L745" title="replication/walreceiver.c:745">WalRcvFetchTimeLineHistoryFiles</a>(TimeLineID first, TimeLineID last);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L665" title="replication/walreceiver.c:665">WalRcvWaitForStartPosition</a>(XLogRecPtr *startpoint, TimeLineID *startpointTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L801" title="replication/walreceiver.c:801">WalRcvDie</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L839" title="replication/walreceiver.c:839">XLogWalRcvProcessMsg</a>(<span class="Type">unsigned</span> <span class="Type">char</span> type, <span class="Type">char</span> *buf, Size len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L910" title="replication/walreceiver.c:910">XLogWalRcvWrite</a>(<span class="Type">char</span> *buf, Size nbytes, XLogRecPtr recptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L993" title="replication/walreceiver.c:993">XLogWalRcvFlush</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dying, TimeLineID tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1048" title="replication/walreceiver.c:1048">XLogWalRcvClose</a>(XLogRecPtr recptr, TimeLineID tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1100" title="replication/walreceiver.c:1100">XLogWalRcvSendReply</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> requestReply);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1169" title="replication/walreceiver.c:1169">XLogWalRcvSendHSFeedback</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> immed);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1265" title="replication/walreceiver.c:1265">ProcessWalSndrMessage</a>(XLogRecPtr walEnd, TimestampTz sendTime);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1317" title="replication/walreceiver.c:1317">WalRcvComputeNextWakeup</a>(<a href="#L117" title="replication/walreceiver.c:117">WalRcvWakeupReason</a> reason, TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> interrupts the walreceiver process may have received.<br/></li>
<li></span><span class="Comment"> * This should be called <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time the process's latch has become set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, only SIGTERM is of interest.&nbsp; We can't just exit(1) within the<br/></li>
<li></span><span class="Comment"> * SIGTERM signal handler, because the signal might arrive in the middle of<br/></li>
<li></span><span class="Comment"> * some critical operation, like while we're holding a spinlock.&nbsp; Instead, the<br/></li>
<li></span><span class="Comment"> * signal handler sets a flag variable as well as setting the process's latch.<br/></li>
<li></span><span class="Comment"> * We must check the flag (by calling <a href="#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>) anytime the<br/></li>
<li></span><span class="Comment"> * latch has become set.&nbsp; Operations that could block for a long time, such as<br/></li>
<li></span><span class="Comment"> * reading from a remote server, must pay attention to the latch too; see<br/></li>
<li></span><span class="Comment"> * <a href="libpqwalreceiver/libpqwalreceiver.c.html#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a> for example.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="linkable">ProcessWalRcvInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Although walreceiver interrupt handling doesn't use the same scheme as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular backends, call CHECK_FOR_INTERRUPTS() to make sure we receive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incoming signals on Win32, and also to make sure we process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barrier events.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating walreceiver process due to administrator command&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Main entry point for walreceiver process */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L183">&#x200c;</a></span><span class="linkable">WalReceiverMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; conninfo[MAXCONNINFO];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp_conninfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; slotname[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_temp_slot;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; startpoint;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; startpointTLI;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; primaryTLI;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first_stream;<br/></li>
<li>&nbsp; &nbsp; WalRcvData *walrcv;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *err;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sender_host = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sender_port = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_WAL_RECEIVER;<br/></li>
<li>&nbsp; &nbsp; <a href="../postmaster/auxprocess.c.html#L44" title="postmaster/auxprocess.c:44">AuxiliaryProcessMainCommon</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a> should be set up already (if we are a backend, we inherit this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by fork() or EXEC_BACKEND mechanism from the postmaster).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; walrcv = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>;<br/></li>
<li>&nbsp; &nbsp; Assert(walrcv != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark walreceiver as running in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do this as early as possible, so that if we fail later on, we'll set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state to STOPPED. If we <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this, the startup process will keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us to start up, until it times out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; Assert(walrcv-&gt;pid == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (walrcv-&gt;walRcvState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STOPPING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we've already been requested to stop, don't start up. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;walRcvState = WALRCV_STOPPED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STOPPED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;walrcv-&gt;walRcvStoppedCV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STARTING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The usual case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_WAITING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STREAMING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_RESTARTING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;walreceiver still running according to shared memory state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advertise our PID so that the startup process can kill us */<br/></li>
<li></span>&nbsp; &nbsp; walrcv-&gt;pid = <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;walRcvState = WALRCV_STREAMING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch information required to start streaming */<br/></li>
<li></span>&nbsp; &nbsp; walrcv-&gt;ready_to_display = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; strlcpy(conninfo, (<span class="Type">char</span> *) walrcv-&gt;conninfo, MAXCONNINFO);<br/></li>
<li>&nbsp; &nbsp; strlcpy(slotname, (<span class="Type">char</span> *) walrcv-&gt;slotname, NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; is_temp_slot = walrcv-&gt;is_temp_slot;<br/></li>
<li>&nbsp; &nbsp; startpoint = walrcv-&gt;receiveStart;<br/></li>
<li>&nbsp; &nbsp; startpointTLI = walrcv-&gt;receiveStartTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At most one of is_temp_slot and slotname can be set; otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="walreceiverfuncs.c.html#L245" title="replication/walreceiverfuncs.c:245">RequestXLogStreaming</a> messed up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!is_temp_slot || (slotname[<span class="Constant">0</span>] == <span class="Special">'\0'</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialise to a sanish value */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;lastMsgSendTime =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;lastMsgReceiptTime = walrcv-&gt;latestWalEndTime = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report the latch to use to awaken this process */<br/></li>
<li></span>&nbsp; &nbsp; walrcv-&gt;latch = &amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procLatch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;writtenUpto, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange to clean up at walreceiver exit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L801" title="replication/walreceiver.c:801">WalRcvDie</a>, PointerGetDatum(&amp;startpointTLI));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Properly <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> or ignore signals the postmaster might <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> us */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="../postmaster/interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>); <span class="Comment">/* set flag to read config<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../postmaster/interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>); <span class="Comment">/* request shutdown */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGALRM</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset some signals that are accepted by postmaster but not here */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the libpq-specific <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/fmgr/dfmgr.c.html#L144" title="utils/fmgr/dfmgr.c:144">load_file</a>(<span class="Constant">&quot;libpqwalreceiver&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L93" title="replication/walreceiver.c:93">WalReceiverFunctions</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;libpqwalreceiver didn't <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> correctly&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unblock signals (they were blocked when the postmaster forked us) */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Establish the connection to the primary for XLOG streaming */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L92" title="replication/walreceiver.c:92">wrconn</a> = walrcv_connect(conninfo, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L540" title="utils/misc/guc_tables.c:540">cluster_name</a>[<span class="Constant">0</span>] ? <a href="../utils/misc/guc_tables.c.html#L540" title="utils/misc/guc_tables.c:540">cluster_name</a> : <span class="Constant">&quot;walreceiver&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;err);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the primary server: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, err)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save user-visible connection string.&nbsp; This clobbers the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conninfo, for security. Also save host and port of the sender server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this walreceiver is connected to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmp_conninfo = walrcv_get_conninfo(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li>&nbsp; &nbsp; walrcv_get_senderinfo(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, &amp;sender_host, &amp;sender_port);<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; memset(walrcv-&gt;conninfo, <span class="Constant">0</span>, MAXCONNINFO);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tmp_conninfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy((<span class="Type">char</span> *) walrcv-&gt;conninfo, tmp_conninfo, MAXCONNINFO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(walrcv-&gt;sender_host, <span class="Constant">0</span>, NI_MAXHOST);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sender_host)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy((<span class="Type">char</span> *) walrcv-&gt;sender_host, sender_host, NI_MAXHOST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;sender_port = sender_port;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;ready_to_display = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tmp_conninfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp_conninfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sender_host)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sender_host);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; first_stream = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *primary_sysid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; standby_sysid[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalRcvStreamOptions options;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that we're connected to a valid server using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IDENTIFY_SYSTEM replication command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; primary_sysid = walrcv_identify_system(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, &amp;primaryTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(standby_sysid, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(standby_sysid), UINT64_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/xlog.c.html#L4535" title="access/transam/xlog.c:4535">GetSystemIdentifier</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(primary_sysid, standby_sysid) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system identifier differs between the primary and standby&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The primary's identifier is </span><span class="Special">%s</span><span class="Constant">, the standby's identifier is </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; primary_sysid, standby_sysid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Confirm that the current timeline of the primary is the same or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ahead of ours.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (primaryTLI &lt; startpointTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;highest timeline </span><span class="Special">%u</span><span class="Constant"> of the primary is behind recovery timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; primaryTLI, startpointTLI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing history files. We do this always, even when we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not interested in that timeline, so that if we're promoted to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * become the primary later on, we don't <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the same timeline that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was already used in the current primary. This isn't bullet-proof -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * you'll need some external software to manage your <a href="../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> if you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to ensure that a unique timeline id is chosen in every case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but let's avoid the confusion of timeline id collisions where we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L745" title="replication/walreceiver.c:745">WalRcvFetchTimeLineHistoryFiles</a>(startpointTLI, primaryTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create temporary replication slot if requested, and update slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * name in shared memory.&nbsp; (Note the slot name cannot already be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in this case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_temp_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(slotname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slotname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;pg_walreceiver_</span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span> <span class="Type">int</span>) walrcv_get_backend_pid(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv_create_slot(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, slotname, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlcpy(walrcv-&gt;slotname, slotname, NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start streaming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll try to start at the requested starting point and timeline,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if it's different from the server's latest timeline. In case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've already reached the end of the old timeline, the server will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finish the streaming immediately, and we will go back to await<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * orders from the startup process. If recovery_target_timeline is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'latest', the startup process will scan pg_wal and <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * history file, bump recovery target timeline, and ask us to restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the new timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; options.logical = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; options.startpoint = startpoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; options.slotname = slotname[<span class="Constant">0</span>] != <span class="Special">'\0'</span> ? slotname : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; options.proto.physical.startpointTLI = startpointTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walrcv_startstreaming(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, &amp;options))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_stream)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;started streaming WAL from primary at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(startpoint), startpointTLI)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;restarted WAL streaming at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(startpoint), startpointTLI)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_stream = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a> and buffers for processing messages */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write = <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Flush = <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize nap <a href="#L129" title="replication/walreceiver.c:129">wakeup</a> times. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L123" title="replication/walreceiver.c:123">NUM_WALRCV_WAKEUPS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1317" title="replication/walreceiver.c:1317">WalRcvComputeNextWakeup</a>(i, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send initial reply/feedback messages. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1100" title="replication/walreceiver.c:1100">XLogWalRcvSendReply</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1169" title="replication/walreceiver.c:1169">XLogWalRcvSendHSFeedback</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop until end-of-streaming or error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; endofwal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgsocket&nbsp; &nbsp; wait_fd = PGINVALID_SOCKET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz nextWakeup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; nap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Exit walreceiver if we're not in recovery. This should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen, but cross-check the status here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot continue WAL streaming, recovery has already ended&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> requests or signals received recently */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recompute <a href="#L129" title="replication/walreceiver.c:129">wakeup</a> times */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L123" title="replication/walreceiver.c:123">NUM_WALRCV_WAKEUPS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1317" title="replication/walreceiver.c:1317">WalRcvComputeNextWakeup</a>(i, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1169" title="replication/walreceiver.c:1169">XLogWalRcvSendHSFeedback</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if we can read data immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = walrcv_receive(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, &amp;buf, &amp;wait_fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process the received data, and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent data we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can read without blocking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Something was received from primary, so adjust<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the ping and terminate <a href="#L129" title="replication/walreceiver.c:129">wakeup</a> times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1317" title="replication/walreceiver.c:1317">WalRcvComputeNextWakeup</a>(WALRCV_WAKEUP_TERMINATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1317" title="replication/walreceiver.c:1317">WalRcvComputeNextWakeup</a>(WALRCV_WAKEUP_PING, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L839" title="replication/walreceiver.c:839">XLogWalRcvProcessMsg</a>(buf[<span class="Constant">0</span>], &amp;buf[<span class="Constant">1</span>], len - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; startpointTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication terminated by primary server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;End of WAL reached on timeline </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; startpointTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endofwal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = walrcv_receive(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, &amp;buf, &amp;wait_fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Let the primary know that we received some data. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1100" title="replication/walreceiver.c:1100">XLogWalRcvSendReply</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've written some <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, flush them to disk and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let the startup process and primary server know about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L993" title="replication/walreceiver.c:993">XLogWalRcvFlush</a>(<span class="Constant">false</span>, startpointTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we need to exit the streaming loop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endofwal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the soonest <a href="#L129" title="replication/walreceiver.c:129">wakeup</a> time, to limit our nap. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextWakeup = TIMESTAMP_INFINITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L123" title="replication/walreceiver.c:123">NUM_WALRCV_WAKEUPS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextWakeup = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[i], nextWakeup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Calculate the nap time, clamping as necessary. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nap = <a href="../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, nextWakeup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally we would reuse a <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> object repeatedly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here to avoid the overheads of <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a> on epoll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * systems, but we can't be sure that libpq (or <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * walreceiver implementation) has the same <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> (even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the fd is the same number, it may have been closed and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reopened since the last time).&nbsp; In future, if there is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function for removing sockets from <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could add and remove just the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> each time, potentially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoiding some system calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(wait_fd != PGINVALID_SOCKET);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_EXIT_ON_PM_DEATH | WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_TIMEOUT | WL_LATCH_SET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wait_fd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_WAL_RECEIVER_MAIN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walrcv-&gt;force_reply)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The recovery process has asked us to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * feedback <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Make sure the flag is really set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * false in shared memory <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sending the reply, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> a new request for a reply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;force_reply = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1100" title="replication/walreceiver.c:1100">XLogWalRcvSendReply</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_TIMEOUT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We didn't receive anything new. If we haven't heard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything from the server for more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a> / 2, ping the server. Also, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's been longer than <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since the last update we sent, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a status update to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the primary anyway, to report <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> progress in applying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; requestReply = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if time since last receive from primary has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached the configured limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[WALRCV_WAKEUP_TERMINATE])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating walreceiver due to timeout&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't receive anything new for half of receiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replication timeout, then ping the server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[WALRCV_WAKEUP_PING])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requestReply = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[WALRCV_WAKEUP_PING] = TIMESTAMP_INFINITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1100" title="replication/walreceiver.c:1100">XLogWalRcvSendReply</a>(requestReply, requestReply);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1169" title="replication/walreceiver.c:1169">XLogWalRcvSendHSFeedback</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The backend finished streaming. Exit streaming COPY-mode from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our side, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv_endstreaming(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, &amp;primaryTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the server had switched to a new timeline that we didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know about when we began streaming, fetch its timeline history<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L745" title="replication/walreceiver.c:745">WalRcvFetchTimeLineHistoryFiles</a>(startpointTLI, primaryTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;primary server contains no more WAL on requested timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startpointTLI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * End of WAL reached on the requested timeline. Close the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment, and await for new orders from the startup process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="replication/walreceiver.c:100">recvFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L993" title="replication/walreceiver.c:993">XLogWalRcvFlush</a>(<span class="Constant">false</span>, startpointTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, <a href="#L101" title="replication/walreceiver.c:101">recvFileTLI</a>, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (close(<a href="#L100" title="replication/walreceiver.c:100">recvFile</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close WAL segment </span><span class="Special">%s</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create .done file forcibly to prevent the streamed segment from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being archived later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L119" title="access/transam/xlog.c:119">XLogArchiveMode</a> != ARCHIVE_MODE_ALWAYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogarchive.c.html#L510" title="access/transam/xlogarchive.c:510">XLogArchiveForceDone</a>(xlogfname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogarchive.c.html#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a>(xlogfname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="replication/walreceiver.c:100">recvFile</a> = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;walreceiver ended streaming and awaits new instructions&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L665" title="replication/walreceiver.c:665">WalRcvWaitForStartPosition</a>(&amp;startpoint, &amp;startpointTLI);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for startup process to set receiveStart and receiveStartTLI.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L665">&#x200c;</a></span><span class="linkable">WalRcvWaitForStartPosition</span>(XLogRecPtr *startpoint, TimeLineID *startpointTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WalRcvData *walrcv = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; state = walrcv-&gt;walRcvState;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state != WALRCV_STREAMING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state == WALRCV_STOPPING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;unexpected walreceiver state&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;walRcvState = WALRCV_WAITING;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;receiveStart = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;receiveStartTLI = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;idle&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nudge startup process to notice that we've stopped streaming and are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for instructions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L4478" title="access/transam/xlogrecovery.c:4478">WakeupRecovery</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(walrcv-&gt;walRcvState == WALRCV_RESTARTING ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; walrcv-&gt;walRcvState == WALRCV_WAITING ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; walrcv-&gt;walRcvState == WALRCV_STOPPING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walrcv-&gt;walRcvState == WALRCV_RESTARTING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to handle changes in primary_conninfo or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary_slot_name here. Startup process will signal us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * terminate in case those change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *startpoint = walrcv-&gt;receiveStart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *startpointTLI = walrcv-&gt;receiveStartTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;walRcvState = WALRCV_STREAMING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walrcv-&gt;walRcvState == WALRCV_STOPPING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should've received SIGTERM if the startup process wants us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>, but might as well check it here too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_WAL_RECEIVER_WAIT_START);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/ps_status.c.html#L29" title="utils/misc/ps_status.c:29">update_process_title</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activitymsg[<span class="Constant">50</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;restarting at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(*startpoint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing timeline history files between 'first' and 'last'<br/></li>
<li></span><span class="Comment"> * (inclusive) from the server.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L745">&#x200c;</a></span><span class="linkable">WalRcvFetchTimeLineHistoryFiles</span>(TimeLineID first, TimeLineID last)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (tli = first; tli &lt;= last; tli++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there's no history file for timeline 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tli != <span class="Constant">1</span> &amp;&amp; !<a href="../access/transam/timeline.c.html#L222" title="access/transam/timeline.c:222">existsTimeLineHistory</a>(tli))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *content;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; expectedfname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;fetching timeline history file for timeline </span><span class="Special">%u</span><span class="Constant"> from primary server&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv_readtimelinehistoryfile(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, tli, &amp;fname, &amp;content, &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the filename on the primary matches what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calculated ourselves. This is just a sanity check, it should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TLHistoryFileName(expectedfname, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(fname, expectedfname) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;primary reported unexpected file name for timeline history file of timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tli)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write the file to pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/timeline.c.html#L463" title="access/transam/timeline.c:463">writeTimeLineHistoryFile</a>(tli, content, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the streamed history file as ready for archiving if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archive_mode is always.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L119" title="access/transam/xlog.c:119">XLogArchiveMode</a> != ARCHIVE_MODE_ALWAYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogarchive.c.html#L510" title="access/transam/xlogarchive.c:510">XLogArchiveForceDone</a>(fname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogarchive.c.html#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a>(fname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(content);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark us as STOPPED in shared memory at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L801">&#x200c;</a></span><span class="linkable">WalRcvDie</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WalRcvData *walrcv = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>;<br/></li>
<li>&nbsp; &nbsp; TimeLineID *startpointTLI_p = (TimeLineID *) DatumGetPointer(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(*startpointTLI_p != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure that all WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> received are flushed to disk */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L993" title="replication/walreceiver.c:993">XLogWalRcvFlush</a>(<span class="Constant">true</span>, *startpointTLI_p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark ourselves inactive in shared memory */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; Assert(walrcv-&gt;walRcvState == WALRCV_STREAMING ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; walrcv-&gt;walRcvState == WALRCV_RESTARTING ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; walrcv-&gt;walRcvState == WALRCV_STARTING ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; walrcv-&gt;walRcvState == WALRCV_WAITING ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; walrcv-&gt;walRcvState == WALRCV_STOPPING);<br/></li>
<li>&nbsp; &nbsp; Assert(walrcv-&gt;pid == <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;walRcvState = WALRCV_STOPPED;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;ready_to_display = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;latch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;walrcv-&gt;walRcvStoppedCV);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Terminate the connection gracefully. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L92" title="replication/walreceiver.c:92">wrconn</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walrcv_disconnect(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wake up the startup process to notice promptly that we're gone */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L4478" title="access/transam/xlogrecovery.c:4478">WakeupRecovery</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Accept the message from XLOG stream, and process it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L839">&#x200c;</a></span><span class="linkable">XLogWalRcvProcessMsg</span>(<span class="Type">unsigned</span> <span class="Type">char</span> type, <span class="Type">char</span> *buf, Size len, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdrlen;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; dataStart;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; walEnd;<br/></li>
<li>&nbsp; &nbsp; TimestampTz sendTime;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replyRequested;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'w'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData incoming_message;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdrlen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &lt; hdrlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;invalid WAL message received from primary&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a StringInfo with the given buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;incoming_message, buf, hdrlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataStart = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;incoming_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walEnd = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;incoming_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sendTime = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;incoming_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1265" title="replication/walreceiver.c:1265">ProcessWalSndrMessage</a>(walEnd, sendTime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf += hdrlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= hdrlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L910" title="replication/walreceiver.c:910">XLogWalRcvWrite</a>(buf, len, dataStart, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'k'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keepalive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData incoming_message;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdrlen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) + <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len != hdrlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;invalid keepalive message received from primary&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a StringInfo with the given buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;incoming_message, buf, hdrlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walEnd = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;incoming_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sendTime = <a href="../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(&amp;incoming_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replyRequested = <a href="../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;incoming_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1265" title="replication/walreceiver.c:1265">ProcessWalSndrMessage</a>(walEnd, sendTime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the primary requested a reply, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> one immediately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (replyRequested)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1100" title="replication/walreceiver.c:1100">XLogWalRcvSendReply</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;invalid replication message type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write XLOG data to disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L910">&#x200c;</a></span><span class="linkable">XLogWalRcvWrite</span>(<span class="Type">char</span> *buf, Size nbytes, XLogRecPtr recptr, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteswritten;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nbytes &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close the current segment if it's completed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="replication/walreceiver.c:100">recvFile</a> &gt;= <span class="Constant">0</span> &amp;&amp; !XLByteInSeg(recptr, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1048" title="replication/walreceiver.c:1048">XLogWalRcvClose</a>(recptr, tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="replication/walreceiver.c:100">recvFile</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create/use new log file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(recptr, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="replication/walreceiver.c:100">recvFile</a> = <a href="../access/transam/xlog.c.html#L3369" title="access/transam/xlog.c:3369">XLogFileInit</a>(<a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L101" title="replication/walreceiver.c:101">recvFileTLI</a> = tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Calculate the start offset of the received logs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; startoff = XLogSegmentOffset(recptr, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startoff + nbytes &gt; <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segbytes = <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a> - startoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segbytes = nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to write the logs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; byteswritten = pg_pwrite(<a href="#L100" title="replication/walreceiver.c:100">recvFile</a>, buf, segbytes, (<span class="Type">off_t</span>) startoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (byteswritten &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, <a href="#L101" title="replication/walreceiver.c:101">recvFileTLI</a>, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to WAL segment </span><span class="Special">%s</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;at offset </span><span class="Special">%d</span><span class="Constant">, length </span><span class="Special">%lu</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname, startoff, (<span class="Type">unsigned</span> <span class="Type">long</span>) segbytes)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update state for write */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; recptr += byteswritten;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes -= byteswritten;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf += byteswritten;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write = recptr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared-memory status */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;writtenUpto, <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the current segment if it's fully written up in the last cycle of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop, to create its archive notification file soon. Otherwise WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archiving of the segment will be delayed until <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data in the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment is received and written.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="replication/walreceiver.c:100">recvFile</a> &gt;= <span class="Constant">0</span> &amp;&amp; !XLByteInSeg(recptr, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1048" title="replication/walreceiver.c:1048">XLogWalRcvClose</a>(recptr, tli);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flush the log to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we're in the midst of dying, it's unwise to do anything that might throw<br/></li>
<li></span><span class="Comment"> * an error, so we <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> sending a reply in that case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L993">&#x200c;</a></span><span class="linkable">XLogWalRcvFlush</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> dying, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(tli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Flush &lt; <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalRcvData *walrcv = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L8603" title="access/transam/xlog.c:8603">issue_xlog_fsync</a>(<a href="#L100" title="replication/walreceiver.c:100">recvFile</a>, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Flush = <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update shared-memory status */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walrcv-&gt;<a href="../access/transam/xlogrecovery.c.html#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> &lt; <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;latestChunkStart = walrcv-&gt;<a href="../access/transam/xlogrecovery.c.html#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;<a href="../access/transam/xlogrecovery.c.html#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> = <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;receivedTLI = tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Signal the startup process and walsender that new WAL has arrived */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L4478" title="access/transam/xlogrecovery.c:4478">WakeupRecovery</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AllowCascadeReplication())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="walsender.c.html#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report XLOG streaming progress in PS display */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/ps_status.c.html#L29" title="utils/misc/ps_status.c:29">update_process_title</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activitymsg[<span class="Constant">50</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;streaming </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also let the primary know that we made some progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dying)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1100" title="replication/walreceiver.c:1100">XLogWalRcvSendReply</a>(<span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1169" title="replication/walreceiver.c:1169">XLogWalRcvSendHSFeedback</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close the current segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Flush the segment to disk <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> closing it. Otherwise we have to<br/></li>
<li></span><span class="Comment"> * reopen and fsync it later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create an archive notification file since the segment is known completed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1048">&#x200c;</a></span><span class="linkable">XLogWalRcvClose</span>(XLogRecPtr recptr, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L100" title="replication/walreceiver.c:100">recvFile</a> &gt;= <span class="Constant">0</span> &amp;&amp; !XLByteInSeg(recptr, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(tli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fsync() and close current file <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we switch to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one. We would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise have to reopen this file to fsync it later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L993" title="replication/walreceiver.c:993">XLogWalRcvFlush</a>(<span class="Constant">false</span>, tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFileName(xlogfname, <a href="#L101" title="replication/walreceiver.c:101">recvFileTLI</a>, <a href="#L102" title="replication/walreceiver.c:102">recvSegNo</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG segment files will be re-read by recovery in startup process soon,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we don't advise the OS to release cache pages associated with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file like <a href="../access/transam/xlog.c.html#L3628" title="access/transam/xlog.c:3628">XLogFileClose</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (close(<a href="#L100" title="replication/walreceiver.c:100">recvFile</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close WAL segment </span><span class="Special">%s</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create .done file forcibly to prevent the streamed segment from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archived later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L119" title="access/transam/xlog.c:119">XLogArchiveMode</a> != ARCHIVE_MODE_ALWAYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogarchive.c.html#L510" title="access/transam/xlogarchive.c:510">XLogArchiveForceDone</a>(xlogfname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogarchive.c.html#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a>(xlogfname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="replication/walreceiver.c:100">recvFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send reply message to primary, indicating our current WAL locations, oldest<br/></li>
<li></span><span class="Comment"> * xmin and the current time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'force' is not set, the message is only sent if enough time has<br/></li>
<li></span><span class="Comment"> * passed since last status update to reach <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a>.<br/></li>
<li></span><span class="Comment"> * If <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> is disabled altogether and 'force' is<br/></li>
<li></span><span class="Comment"> * false, this is a no-op.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'requestReply' is true, requests the server to reply immediately upon<br/></li>
<li></span><span class="Comment"> * receiving this message. This is used for heartbeats, when approaching<br/></li>
<li></span><span class="Comment"> * <a href="#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1100">&#x200c;</a></span><span class="linkable">XLogWalRcvSendReply</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> requestReply)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr writePtr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr flushPtr = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; applyPtr;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the user doesn't want status to be reported to the primary, be sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to exit <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing anything at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!force &amp;&amp; <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get current timestamp. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the write and flush positions to the last message we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sent without taking <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock, but the apply position requires a spin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock, so we don't check that unless something else has changed or 10<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seconds have passed.&nbsp; This means that the apply WAL location will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appear, from the primary's point of view, to lag slightly, but since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is only for reporting purposes and only on idle systems, that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!force<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; writePtr == <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; flushPtr == <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Flush<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &lt; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[WALRCV_WAKEUP_REPLY])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we wake up when it's time to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> another reply. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1317" title="replication/walreceiver.c:1317">WalRcvComputeNextWakeup</a>(WALRCV_WAKEUP_REPLY, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct a new message */<br/></li>
<li></span>&nbsp; &nbsp; writePtr = <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Write;<br/></li>
<li>&nbsp; &nbsp; flushPtr = <a href="#L112" title="replication/walreceiver.c:112">LogstreamResult</a>.Flush;<br/></li>
<li>&nbsp; &nbsp; applyPtr = <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; resetStringInfo(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, <span class="Constant">'r'</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, writePtr);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, flushPtr);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, applyPtr);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, requestReply ? <span class="Constant">1</span> : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send it */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;sending write </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> flush </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> apply </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(writePtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(flushPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(applyPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; requestReply ? <span class="Constant">&quot; (reply requested)&quot;</span> : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walrcv_send(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, <a href="#L131" title="replication/walreceiver.c:131">reply_message</a>.data, <a href="#L131" title="replication/walreceiver.c:131">reply_message</a>.len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send hot standby feedback message to primary, plus the current time,<br/></li>
<li></span><span class="Comment"> * in case they don't have a watch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the user disables feedback, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> one final message to tell sender<br/></li>
<li></span><span class="Comment"> * to forget about the xmin on this standby. We also <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> this message<br/></li>
<li></span><span class="Comment"> * on first <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> because a previous connection might have set xmin<br/></li>
<li></span><span class="Comment"> * on a replication slot. (If we're not using a slot it's harmless to<br/></li>
<li></span><span class="Comment"> * <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a feedback message explicitly setting InvalidTransactionId).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1169">&#x200c;</a></span><span class="linkable">XLogWalRcvSendHSFeedback</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> immed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId nextFullXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId nextXid;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; xmin_epoch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; catalog_xmin_epoch;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initially true so we always <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> at least one feedback message */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> primary_has_standby_xmin = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the user doesn't want status to be reported to the primary, be sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to exit <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing anything at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> &lt;= <span class="Constant">0</span> || !<a href="#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !primary_has_standby_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get current timestamp. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send feedback at most once per <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!immed &amp;&amp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &lt; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[WALRCV_WAKEUP_HSFEEDBACK])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we wake up when it's time to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> feedback again. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1317" title="replication/walreceiver.c:1317">WalRcvComputeNextWakeup</a>(WALRCV_WAKEUP_HSFEEDBACK, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If Hot Standby is not yet accepting connections there is nothing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>. Check this after the interval has expired to reduce number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bailing out here also ensures that we don't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> feedback until we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read our own replication slot state, so we don't tell the primary to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * discard needed xmin or catalog_xmin from <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slots that may exist on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this replica.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlogrecovery.c.html#L4502" title="access/transam/xlogrecovery.c:4502">HotStandbyActive</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the expensive call to get the oldest xmin once we are certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * everything else has been checked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procarray.c.html#L2035" title="storage/ipc/procarray.c:2035">GetReplicationHorizons</a>(&amp;xmin, &amp;catalog_xmin);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; catalog_xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get epoch and adjust if nextXid and oldestXmin are different sides of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the epoch boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nextFullXid = <a href="../access/transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; nextXid = XidFromFullTransactionId(nextFullXid);<br/></li>
<li>&nbsp; &nbsp; xmin_epoch = EpochFromFullTransactionId(nextFullXid);<br/></li>
<li>&nbsp; &nbsp; catalog_xmin_epoch = xmin_epoch;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextXid &lt; xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmin_epoch--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextXid &lt; catalog_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; catalog_xmin_epoch--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;sending hot standby feedback xmin </span><span class="Special">%u</span><span class="Constant"> epoch </span><span class="Special">%u</span><span class="Constant"> catalog_xmin </span><span class="Special">%u</span><span class="Constant"> catalog_xmin_epoch </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmin, xmin_epoch, catalog_xmin, catalog_xmin_epoch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct the message and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it. */<br/></li>
<li></span>&nbsp; &nbsp; resetStringInfo(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>);<br/></li>
<li>&nbsp; &nbsp; pq_sendbyte(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, <span class="Constant">'h'</span>);<br/></li>
<li>&nbsp; &nbsp; pq_sendint64(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, xmin);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, xmin_epoch);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, catalog_xmin);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;<a href="#L131" title="replication/walreceiver.c:131">reply_message</a>, catalog_xmin_epoch);<br/></li>
<li>&nbsp; &nbsp; walrcv_send(<a href="#L92" title="replication/walreceiver.c:92">wrconn</a>, <a href="#L131" title="replication/walreceiver.c:131">reply_message</a>.data, <a href="#L131" title="replication/walreceiver.c:131">reply_message</a>.len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xmin) || TransactionIdIsValid(catalog_xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; primary_has_standby_xmin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; primary_has_standby_xmin = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update shared memory status upon receiving a message from primary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'walEnd' and 'sendTime' are the end-of-WAL and timestamp of the latest<br/></li>
<li></span><span class="Comment"> * message, reported by primary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1265">&#x200c;</a></span><span class="linkable">ProcessWalSndrMessage</span>(XLogRecPtr walEnd, TimestampTz sendTime)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WalRcvData *walrcv = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>;<br/></li>
<li>&nbsp; &nbsp; TimestampTz lastMsgReceiptTime = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared-memory status */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;walrcv-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (walrcv-&gt;latestWalEnd &lt; walEnd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; walrcv-&gt;latestWalEndTime = sendTime;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;latestWalEnd = walEnd;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;lastMsgSendTime = sendTime;<br/></li>
<li>&nbsp; &nbsp; walrcv-&gt;lastMsgReceiptTime = lastMsgReceiptTime;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;walrcv-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sendtime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *receipttime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; applyDelay;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy because <a href="../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a> returns a static buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sendtime = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(sendTime));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; receipttime = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(lastMsgReceiptTime));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; applyDelay = <a href="walreceiverfuncs.c.html#L364" title="replication/walreceiverfuncs.c:364">GetReplicationApplyDelay</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* apply delay is not available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (applyDelay == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;sendtime </span><span class="Special">%s</span><span class="Constant"> receipttime </span><span class="Special">%s</span><span class="Constant"> replication apply delay (N/A) transfer latency </span><span class="Special">%d</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sendtime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; receipttime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="walreceiverfuncs.c.html#L394" title="replication/walreceiverfuncs.c:394">GetReplicationTransferLatency</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;sendtime </span><span class="Special">%s</span><span class="Constant"> receipttime </span><span class="Special">%s</span><span class="Constant"> replication apply delay </span><span class="Special">%d</span><span class="Constant"> ms transfer latency </span><span class="Special">%d</span><span class="Constant"> ms&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sendtime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; receipttime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; applyDelay,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="walreceiverfuncs.c.html#L394" title="replication/walreceiverfuncs.c:394">GetReplicationTransferLatency</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sendtime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(receipttime);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L129" title="replication/walreceiver.c:129">wakeup</a> time for a given <a href="#L129" title="replication/walreceiver.c:129">wakeup</a> reason.&nbsp; Can be called to<br/></li>
<li></span><span class="Comment"> * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a <a href="#L129" title="replication/walreceiver.c:129">wakeup</a> time, to adjust it for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>, or to<br/></li>
<li></span><span class="Comment"> * reinitialize it when GUCs have changed.&nbsp; We ask the caller to pass in the<br/></li>
<li></span><span class="Comment"> * value of &quot;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot; because this frequently avoids multiple calls of<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>().&nbsp; It had better be a reasonably up-to-date value<br/></li>
<li></span><span class="Comment"> * though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1317">&#x200c;</a></span><span class="linkable">WalRcvComputeNextWakeup</span>(<a href="#L117" title="replication/walreceiver.c:117">WalRcvWakeupReason</a> reason, TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (reason)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_WAKEUP_TERMINATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TIMESTAMP_INFINITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TimestampTzPlusMilliseconds(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_WAKEUP_PING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TIMESTAMP_INFINITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TimestampTzPlusMilliseconds(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="#L88" title="replication/walreceiver.c:88">wal_receiver_timeout</a> / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_WAKEUP_HSFEEDBACK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a> || <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TIMESTAMP_INFINITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TimestampTzPlusSeconds(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_WAKEUP_REPLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TIMESTAMP_INFINITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="replication/walreceiver.c:129">wakeup</a>[reason] = TimestampTzPlusSeconds(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="#L87" title="replication/walreceiver.c:87">wal_receiver_status_interval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there's intentionally no default: here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up the walreceiver <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called by the startup process whenever interesting xlog <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> * are applied, so that walreceiver can check if it needs to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> an apply<br/></li>
<li></span><span class="Comment"> * notification back to the primary which may be <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> in a COMMIT with<br/></li>
<li></span><span class="Comment"> * <a href="../access/transam/xact.c.html#L85" title="access/transam/xact.c:85">synchronous_commit</a> = remote_apply.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1358">&#x200c;</a></span><span class="linkable">WalRcvForceReply</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Latch&nbsp; &nbsp; &nbsp;&nbsp; *latch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;force_reply = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetching the latch pointer might not be atomic, so use spinlock */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; latch = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;latch;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (latch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(latch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a string constant representing the state. This is used<br/></li>
<li></span><span class="Comment"> * in system <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and views, and should *not* be translated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1376">&#x200c;</a><span class="linkable">WalRcvGetStateString</span>(WalRcvState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STOPPED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;stopped&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STARTING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;starting&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STREAMING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;streaming&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_WAITING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_RESTARTING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;restarting&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALRCV_STOPPING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;stopping&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;UNKNOWN&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns activity of WAL receiver, including pid, state and xlog locations<br/></li>
<li></span><span class="Comment"> * received from the WAL sender of another server.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1401">&#x200c;</a><span class="linkable">pg_stat_get_wal_receiver</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ready_to_display;<br/></li>
<li>&nbsp; &nbsp; WalRcvState state;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; receive_start_lsn;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; receive_start_tli;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; written_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; flushed_lsn;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; received_tli;<br/></li>
<li>&nbsp; &nbsp; TimestampTz last_send_time;<br/></li>
<li>&nbsp; &nbsp; TimestampTz last_receipt_time;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; latest_end_lsn;<br/></li>
<li>&nbsp; &nbsp; TimestampTz latest_end_time;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sender_host[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sender_port = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; slotname[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; conninfo[MAXCONNINFO];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take a lock to ensure value consistency */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; pid = (<span class="Type">int</span>) <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; ready_to_display = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;ready_to_display;<br/></li>
<li>&nbsp; &nbsp; state = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;walRcvState;<br/></li>
<li>&nbsp; &nbsp; receive_start_lsn = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;receiveStart;<br/></li>
<li>&nbsp; &nbsp; receive_start_tli = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;receiveStartTLI;<br/></li>
<li>&nbsp; &nbsp; flushed_lsn = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;<a href="../access/transam/xlogrecovery.c.html#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a>;<br/></li>
<li>&nbsp; &nbsp; received_tli = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;receivedTLI;<br/></li>
<li>&nbsp; &nbsp; last_send_time = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;lastMsgSendTime;<br/></li>
<li>&nbsp; &nbsp; last_receipt_time = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;lastMsgReceiptTime;<br/></li>
<li>&nbsp; &nbsp; latest_end_lsn = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;latestWalEnd;<br/></li>
<li>&nbsp; &nbsp; latest_end_time = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;latestWalEndTime;<br/></li>
<li>&nbsp; &nbsp; strlcpy(slotname, (<span class="Type">char</span> *) <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;slotname, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(slotname));<br/></li>
<li>&nbsp; &nbsp; strlcpy(sender_host, (<span class="Type">char</span> *) <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;sender_host, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sender_host));<br/></li>
<li>&nbsp; &nbsp; sender_port = <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;sender_port;<br/></li>
<li>&nbsp; &nbsp; strlcpy(conninfo, (<span class="Type">char</span> *) <a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;conninfo, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(conninfo));<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No WAL receiver (or not ready yet), just return a tuple with NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <span class="Constant">0</span> || !ready_to_display)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read &quot;writtenUpto&quot; without holding a spinlock.&nbsp; Note that it may not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent with the other shared variables of the WAL receiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protected by a spinlock, but this should not be used for data integrity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; written_lsn = pg_atomic_read_u64(&amp;<a href="walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;writtenUpto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* determine result type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * tupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; nulls = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = Int32GetDatum(pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/acl.c.html#L5128" title="utils/adt/acl.c:5128">has_privs_of_role</a>(<a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ROLE_PG_READ_ALL_STATS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only superusers and roles with privileges of pg_read_all_stats can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see details. Other users only get the pid value to know whether it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a WAL receiver, but no details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;nulls[<span class="Constant">1</span>], <span class="Constant">true</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * (tupdesc-&gt;natts - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(<a href="#L1376" title="replication/walreceiver.c:1376">WalRcvGetStateString</a>(state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(receive_start_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = LSNGetDatum(receive_start_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = Int32GetDatum(receive_start_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(written_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = LSNGetDatum(written_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(flushed_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = LSNGetDatum(flushed_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] = Int32GetDatum(received_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_send_time == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">7</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">7</span>] = TimestampTzGetDatum(last_send_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_receipt_time == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">8</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>] = TimestampTzGetDatum(last_receipt_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(latest_end_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">9</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = LSNGetDatum(latest_end_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (latest_end_time == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">10</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">10</span>] = TimestampTzGetDatum(latest_end_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*slotname == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">11</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">11</span>] = CStringGetTextDatum(slotname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*sender_host == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">12</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">12</span>] = CStringGetTextDatum(sender_host);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sender_port == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">13</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">13</span>] = Int32GetDatum(sender_port);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*conninfo == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">14</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">14</span>] = CStringGetTextDatum(conninfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Returns the record as Datum */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_DATUM(HeapTupleGetDatum(<a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls)));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
