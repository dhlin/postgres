<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/slotfuncs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>replication/slotfuncs.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L601">copy_replication_slot</a></li>
<li><a href="#L121">create_logical_replication_slot</a></li>
<li><a href="#L40">create_physical_replication_slot</a></li>
<li><a href="#L832">pg_copy_logical_replication_slot_a</a></li>
<li><a href="#L838">pg_copy_logical_replication_slot_b</a></li>
<li><a href="#L844">pg_copy_logical_replication_slot_c</a></li>
<li><a href="#L850">pg_copy_physical_replication_slot_a</a></li>
<li><a href="#L856">pg_copy_physical_replication_slot_b</a></li>
<li><a href="#L173">pg_create_logical_replication_slot</a></li>
<li><a href="#L69">pg_create_physical_replication_slot</a></li>
<li><a href="#L222">pg_drop_replication_slot</a></li>
<li><a href="#L240">pg_get_replication_slots</a></li>
<li><a href="#L499">pg_logical_replication_slot_advance</a></li>
<li><a href="#L463">pg_physical_replication_slot_advance</a></li>
<li><a href="#L508">pg_replication_slot_advance</a></li>
<li><a href="#L866">pg_sync_replication_slots</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L242">PG_GET_REPLICATION_SLOTS_COLS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * slotfuncs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Support <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for replication slots<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2012-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/slotfuncs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/decode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for creating a new physical replication slot with<br/></li>
<li></span><span class="Comment"> * given arguments. Note that this function doesn't release the created<br/></li>
<li></span><span class="Comment"> * slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If restart_lsn is a valid value, we use it without WAL reservation<br/></li>
<li></span><span class="Comment"> * routine. So the caller must guarantee that WAL is available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="linkable">create_physical_replication_slot</span>(<span class="Type">char</span> *name, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> immediately_reserve,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> temporary, XLogRecPtr restart_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* acquire replication slot, this will check for conflicting names */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slot.c.html#L309" title="replication/slot.c:309">ReplicationSlotCreate</a>(name, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temporary ? RS_TEMPORARY : RS_PERSISTENT, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (immediately_reserve)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reserve WAL as the user asked for it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1401" title="replication/slot.c:1401">ReplicationSlotReserveWal</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn = restart_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write this slot to disk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function for creating a new physical (streaming replication)<br/></li>
<li></span><span class="Comment"> * replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L69">&#x200c;</a><span class="linkable">pg_create_physical_replication_slot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; name = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; immediately_reserve = PG_GETARG_BOOL(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; temporary = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1384" title="replication/slot.c:1384">CheckSlotPermissions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1362" title="replication/slot.c:1362">CheckSlotRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="replication/slotfuncs.c:40">create_physical_replication_slot</a>(NameStr(*name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; immediately_reserve,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; temporary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = NameGetDatum(&amp;<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name);<br/></li>
<li>&nbsp; &nbsp; nulls[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (immediately_reserve)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = LSNGetDatum(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for creating a new logical replication slot with<br/></li>
<li></span><span class="Comment"> * given arguments. Note that this function doesn't release the created<br/></li>
<li></span><span class="Comment"> * slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When find_startpoint is false, the slot's confirmed_flush is not set; it's<br/></li>
<li></span><span class="Comment"> * caller's responsibility to ensure it's set to something sensible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L121">&#x200c;</a></span><span class="linkable">create_logical_replication_slot</span>(<span class="Type">char</span> *name, <span class="Type">char</span> *plugin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> temporary, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> two_phase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> failover,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr restart_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> find_startpoint)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalDecodingContext *ctx = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire a logical decoding slot, this will check for conflicting names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initially create persistent slot as ephemeral - that allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nicely handle errors during initialization because it'll get dropped if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this transaction fails. We'll make it persistent at the end. Temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slots can be created as temporary from beginning as they get dropped on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slot.c.html#L309" title="replication/slot.c:309">ReplicationSlotCreate</a>(name, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temporary ? RS_TEMPORARY : RS_EPHEMERAL, two_phase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failover, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create logical decoding context to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> start point or, if we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need it, to 1) bump slot's restart_lsn and xmin 2) check plugin sanity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: when !find_startpoint this is still important, because it's at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this point that the output plugin is validated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx = <a href="logical/logical.c.html#L329" title="replication/logical/logical.c:329">CreateInitDecodingContext</a>(plugin, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* just catalogs is OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restart_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = <a href="../access/transam/xlogutils.c.html#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = <a href="../access/transam/xlogutils.c.html#L817" title="access/transam/xlogutils.c:817">wal_segment_open</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = <a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If caller needs us to determine the decoding start point, do so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This might take a while.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (find_startpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/logical.c.html#L649" title="replication/logical/logical.c:649">DecodingContextFindStartpoint</a>(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need the decoding context anymore */<br/></li>
<li></span>&nbsp; &nbsp; <a href="logical/logical.c.html#L693" title="replication/logical/logical.c:693">FreeDecodingContext</a>(ctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function for creating a new logical replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L173">&#x200c;</a><span class="linkable">pg_create_logical_replication_slot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; name = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; plugin = PG_GETARG_NAME(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; temporary = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; two_phase = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; failover = PG_GETARG_BOOL(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1384" title="replication/slot.c:1384">CheckSlotPermissions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logical/logical.c.html#L109" title="replication/logical/logical.c:109">CheckLogicalDecodingRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="replication/slotfuncs.c:121">create_logical_replication_slot</a>(NameStr(*name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*plugin),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temporary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; two_phase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failover,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = NameGetDatum(&amp;<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = LSNGetDatum(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(nulls, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nulls));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ok, slot is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fully created, mark it as persistent if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!temporary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1027" title="replication/slot.c:1027">ReplicationSlotPersist</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function for dropping a replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L222">&#x200c;</a><span class="linkable">pg_drop_replication_slot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; name = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1384" title="replication/slot.c:1384">CheckSlotPermissions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1362" title="replication/slot.c:1362">CheckSlotRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L784" title="replication/slot.c:784">ReplicationSlotDrop</a>(NameStr(*name), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L240" title="replication/slotfuncs.c:240">pg_get_replication_slots</a> - SQL SRF showing all replication slots<br/></li>
<li></span><span class="Comment"> * that currently exist on the database <a href="../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L240">&#x200c;</a><span class="linkable">pg_get_replication_slots</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><a id="L242">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_GET_REPLICATION_SLOTS_COLS</span> </span><span class="Constant">19<br/></li>
<li></span>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; currlsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't require <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> special permission to see this function's data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because nothing should be sensitive. The most critical being the slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * name, which shouldn't contain anything particularly sensitive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; currlsn = <a href="../access/transam/xlog.c.html#L9371" title="access/transam/xlog.c:9371">GetXLogWriteRecPtr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationSlotControlLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (slotno = <span class="Constant">0</span>; slotno &lt; <a href="slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; slotno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlot *slot = &amp;<a href="slot.c.html#L135" title="replication/slot.c:135">ReplicationSlotCtl</a>-&gt;replication_slots[slotno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlot slot_contents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L242" title="replication/slotfuncs.c:242">PG_GET_REPLICATION_SLOTS_COLS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L242" title="replication/slotfuncs.c:242">PG_GET_REPLICATION_SLOTS_COLS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WALAvailability walstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlotInvalidationCause cause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slot-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy slot contents while holding spinlock, then examine at leisure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot_contents = *slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(nulls, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(nulls));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = NameGetDatum(&amp;slot_contents.data.name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.database == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = NameGetDatum(&amp;slot_contents.data.plugin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.database == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<span class="Constant">&quot;physical&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<span class="Constant">&quot;logical&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.database == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = ObjectIdGetDatum(slot_contents.data.database);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = BoolGetDatum(slot_contents.data.persistency == RS_TEMPORARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = BoolGetDatum(slot_contents.active_pid != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.active_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = Int32GetDatum(slot_contents.active_pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.xmin != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = TransactionIdGetDatum(slot_contents.data.xmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.catalog_xmin != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = TransactionIdGetDatum(slot_contents.data.catalog_xmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.restart_lsn != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = LSNGetDatum(slot_contents.data.restart_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.confirmed_flush != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = LSNGetDatum(slot_contents.data.confirmed_flush);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the slot has not been invalidated, test availability from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart_lsn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.data.invalidated != RS_INVAL_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walstate = WALAVAIL_REMOVED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walstate = <a href="../access/transam/xlog.c.html#L7790" title="access/transam/xlog.c:7790">GetWALAvailability</a>(slot_contents.data.restart_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (walstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALAVAIL_INVALID_LSN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALAVAIL_RESERVED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<span class="Constant">&quot;reserved&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALAVAIL_EXTENDED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<span class="Constant">&quot;extended&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALAVAIL_UNRESERVED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<span class="Constant">&quot;unreserved&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WALAVAIL_REMOVED:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we read the restart_lsn long enough ago, maybe that file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has been removed by <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; However, the walsender could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * moved forward enough that it jumped to another file after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we looked.&nbsp; If checkpointer signalled the process to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * termination, then it's definitely lost; but if a process is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still alive, then &quot;unreserved&quot; seems more appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we do change it, save the state for safe_wal_size below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(slot_contents.data.restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = slot-&gt;active_pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_contents.data.restart_lsn = slot-&gt;data.restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;slot-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<span class="Constant">&quot;unreserved&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walstate = WALAVAIL_UNRESERVED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<span class="Constant">&quot;lost&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safe_wal_size is only computed for slots that have not been lost,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and only if there's a configured maximum size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (walstate == WALAVAIL_REMOVED || <a href="../access/transam/xlog.c.html#L135" title="access/transam/xlog.c:135">max_slot_wal_keep_size_mb</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; targetSeg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; slotKeepSegs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; keepSegs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; failSeg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; failLSN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(slot_contents.data.restart_lsn, targetSeg, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* determine how many segments can be kept by slots */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotKeepSegs = XLogMBVarToSegs(<a href="../access/transam/xlog.c.html#L135" title="access/transam/xlog.c:135">max_slot_wal_keep_size_mb</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ditto for wal_keep_size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keepSegs = XLogMBVarToSegs(<a href="../access/transam/xlog.c.html#L116" title="access/transam/xlog.c:116">wal_keep_size_mb</a>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if currpos reaches failLSN, we lose our segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failSeg = targetSeg + Max(slotKeepSegs, keepSegs) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNoOffsetToRecPtr(failSeg, <span class="Constant">0</span>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, failLSN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(failLSN - currlsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = BoolGetDatum(slot_contents.data.two_phase);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot_contents.inactive_since &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = TimestampTzGetDatum(slot_contents.inactive_since);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cause = slot_contents.data.invalidated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SlotIsPhysical(&amp;slot_contents))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows_removed and wal_level_insufficient are the only two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reasons for the logical slot's conflict with recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cause == RS_INVAL_HORIZON ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cause == RS_INVAL_WAL_LEVEL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cause == RS_INVAL_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i++] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = CStringGetTextDatum(<a href="slot.c.html#L105" title="replication/slot.c:105">SlotInvalidationCauses</a>[cause]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = BoolGetDatum(slot_contents.data.failover);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i++] = BoolGetDatum(slot_contents.data.synced);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(i == <a href="#L242" title="replication/slotfuncs.c:242">PG_GET_REPLICATION_SLOTS_COLS</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationSlotControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for advancing our physical replication slot forward.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The LSN position to move to is compared simply to the slot's restart_lsn,<br/></li>
<li></span><span class="Comment"> * knowing that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> position older than that would be removed by successive<br/></li>
<li></span><span class="Comment"> * checkpoints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L463">&#x200c;</a><span class="linkable">pg_physical_replication_slot_advance</span>(XLogRecPtr moveto)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; startlsn = <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; retlsn = startlsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(moveto != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (startlsn &lt; moveto)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn = moveto;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retlsn = moveto;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Dirty the slot so as it is written out at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the LSN position advanced may still be lost in the event of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash, but this makes the data consistent after a clean shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wake up logical walsenders holding logical failover slots after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updating the restart_lsn of the physical slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="walsender.c.html#L1733" title="replication/walsender.c:1733">PhysicalWakeupLogicalWalSnd</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retlsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance our logical replication slot forward. See<br/></li>
<li></span><span class="Comment"> * <a href="logical/logical.c.html#L2060" title="replication/logical/logical.c:2060">LogicalSlotAdvanceAndCheckSnapState</a> for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L499">&#x200c;</a><span class="linkable">pg_logical_replication_slot_advance</span>(XLogRecPtr moveto)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="logical/logical.c.html#L2060" title="replication/logical/logical.c:2060">LogicalSlotAdvanceAndCheckSnapState</a>(moveto, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function for moving the position in a replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L508">&#x200c;</a><span class="linkable">pg_replication_slot_advance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; slotname = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; moveto = PG_GETARG_LSN(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; endlsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; minlsn;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1384" title="replication/slot.c:1384">CheckSlotPermissions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(moveto))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid target WAL LSN&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build a tuple descriptor for our result type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't move slot past what's been flushed/replayed so clamp the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target position accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; moveto = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(moveto, <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(<span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; moveto = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(moveto, <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(<span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire the slot so we &quot;own&quot; it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slot.c.html#L540" title="replication/slot.c:540">ReplicationSlotAcquire</a>(NameStr(*slotname), <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A slot whose restart_lsn has never been reserved cannot be advanced */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot be advanced&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*slotname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This slot has never previously reserved WAL, or it has been invalidated.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the slot is not moving backwards.&nbsp; Physical slots rely simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on restart_lsn as a minimum point, while logical slots have confirmed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consumption up to confirmed_flush, meaning that in both cases data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * older than that is not available anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.database))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minlsn = <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; minlsn = <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (moveto &lt; minlsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot advance replication slot to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, minimum is </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(moveto), LSN_FORMAT_ARGS(minlsn))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the actual slot update, depending on the slot type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.database))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endlsn = <a href="#L499" title="replication/slotfuncs.c:499">pg_logical_replication_slot_advance</a>(moveto);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; endlsn = <a href="#L463" title="replication/slotfuncs.c:463">pg_physical_replication_slot_advance</a>(moveto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = NameGetDatum(&amp;<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.name);<br/></li>
<li>&nbsp; &nbsp; nulls[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recompute the minimum LSN and xmin across all slots to adjust with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advancing potentially done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slot.c.html#L1049" title="replication/slot.c:1049">ReplicationSlotsComputeRequiredXmin</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1105" title="replication/slot.c:1105">ReplicationSlotsComputeRequiredLSN</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the reached position. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = LSNGetDatum(endlsn);<br/></li>
<li>&nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function of copying a replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L601">&#x200c;</a><span class="linkable">copy_replication_slot</span>(FunctionCallInfo fcinfo, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> logical_slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; src_name = PG_GETARG_NAME(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; dst_name = PG_GETARG_NAME(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot *src = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot first_slot_contents;<br/></li>
<li>&nbsp; &nbsp; ReplicationSlot second_slot_contents;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; src_restart_lsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; src_islogical;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; temporary;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *plugin;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1384" title="replication/slot.c:1384">CheckSlotPermissions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (logical_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="logical/logical.c.html#L109" title="replication/logical/logical.c:109">CheckLogicalDecodingRequirements</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1362" title="replication/slot.c:1362">CheckSlotRequirements</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ReplicationSlotControlLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to prevent the source slot's reserved WAL from being removed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we don't want to lock that slot for very long, and it can advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the meantime.&nbsp; So obtain the source slot's data, and create a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot using its restart_lsn.&nbsp; Afterwards we lock the source slot again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and verify that the data we copied (name, type) has not changed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incompatibly.&nbsp; No inconvenient WAL removal can occur once the new slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is created -- but since WAL removal could have occurred <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * managed to create the new slot, we advance the new slot's restart_lsn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the source slot's updated restart_lsn the second time we lock it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="slot.c.html#L141" title="replication/slot.c:141">max_replication_slots</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReplicationSlot *s = &amp;<a href="slot.c.html#L135" title="replication/slot.c:135">ReplicationSlotCtl</a>-&gt;replication_slots[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;in_use &amp;&amp; strcmp(NameStr(s-&gt;data.name), NameStr(*src_name)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the slot contents while holding spinlock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;s-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_slot_contents = *s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;s-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src = s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ReplicationSlotControlLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, NameStr(*src_name))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; src_islogical = SlotIsLogical(&amp;first_slot_contents);<br/></li>
<li>&nbsp; &nbsp; src_restart_lsn = first_slot_contents.data.restart_lsn;<br/></li>
<li>&nbsp; &nbsp; temporary = (first_slot_contents.data.persistency == RS_TEMPORARY);<br/></li>
<li>&nbsp; &nbsp; plugin = logical_slot ? NameStr(first_slot_contents.data.plugin) : <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check type of replication slot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (src_islogical != logical_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src_islogical ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot copy physical replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as a logical replication slot&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*src_name)) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot copy logical replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> as a physical replication slot&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*src_name))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copying non-reserved slot doesn't make sense */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(src_restart_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot copy a replication slot that doesn't reserve WAL&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Overwrite params from optional arguments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt;= <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; temporary = PG_GETARG_BOOL(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_NARGS() &gt;= <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(logical_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plugin = NameStr(*(PG_GETARG_NAME(<span class="Constant">3</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create new slot and acquire it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (logical_slot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must not try to read WAL, since we haven't reserved it yet --<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hence pass find_startpoint false.&nbsp; confirmed_flush will be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, by copying from the source slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid potential issues with the slot synchronization where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart_lsn of a replication slot can go backward, we set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failover option to false here.&nbsp; This situation occurs when a slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the primary server is dropped and immediately replaced with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new slot of the same name, created by copying from another existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot.&nbsp; However, the slot synchronization will only observe the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart_lsn of the same slot going backward.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L121" title="replication/slotfuncs.c:121">create_logical_replication_slot</a>(NameStr(*dst_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plugin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temporary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_restart_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="replication/slotfuncs.c:40">create_physical_replication_slot</a>(NameStr(*dst_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; temporary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src_restart_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the destination slot to current <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the source slot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recheck that the source slot is still the one we saw previously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId copy_effective_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId copy_effective_catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId copy_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId copy_catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; copy_restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; copy_confirmed_flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; copy_islogical;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *copy_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy data of source slot again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;src-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; second_slot_contents = *src;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;src-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_effective_xmin = second_slot_contents.effective_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_effective_catalog_xmin = second_slot_contents.effective_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_xmin = second_slot_contents.data.xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_catalog_xmin = second_slot_contents.data.catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_restart_lsn = second_slot_contents.data.restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_confirmed_flush = second_slot_contents.data.confirmed_flush;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for existence check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; copy_name = NameStr(second_slot_contents.data.name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; copy_islogical = SlotIsLogical(&amp;second_slot_contents);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if the source slot still exists and is valid. We regard it as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalid if the type of replication slot or name has been changed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or the restart_lsn either is invalid or has gone backward. (The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart_lsn could go backwards if the source slot is dropped and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copied from an older slot during installation.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since erroring out will release and drop the destination slot we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need to release it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (copy_restart_lsn &lt; src_restart_lsn ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_islogical != copy_islogical ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(copy_name, NameStr(*src_name)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not copy replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*src_name)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The source replication slot was modified incompatibly during the copy operation.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The source slot must have a consistent snapshot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_islogical &amp;&amp; XLogRecPtrIsInvalid(copy_confirmed_flush))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot copy unfinished logical replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*src_name)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Retry when the source replication slot's confirmed_flush_lsn is valid.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Install copied <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;effective_xmin = copy_effective_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;effective_catalog_xmin = copy_effective_catalog_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.xmin = copy_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.catalog_xmin = copy_catalog_xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.restart_lsn = copy_restart_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush = copy_confirmed_flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1010" title="replication/slot.c:1010">ReplicationSlotMarkDirty</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1049" title="replication/slot.c:1049">ReplicationSlotsComputeRequiredXmin</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1105" title="replication/slot.c:1105">ReplicationSlotsComputeRequiredLSN</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L992" title="replication/slot.c:992">ReplicationSlotSave</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that the restart_lsn is available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(copy_restart_lsn, segno, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../access/transam/xlog.c.html#L3747" title="access/transam/xlog.c:3747">XLogGetLastRemovedSegno</a>() &lt; segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* target slot fully created, mark as persistent if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (logical_slot &amp;&amp; !temporary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slot.c.html#L1027" title="replication/slot.c:1027">ReplicationSlotPersist</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All done.&nbsp; Set up the return <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = NameGetDatum(dst_name);<br/></li>
<li>&nbsp; &nbsp; nulls[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = LSNGetDatum(<a href="slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a>-&gt;data.confirmed_flush);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* The wrappers below are all to appease opr_sanity */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L832">&#x200c;</a><span class="linkable">pg_copy_logical_replication_slot_a</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L601" title="replication/slotfuncs.c:601">copy_replication_slot</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L838">&#x200c;</a><span class="linkable">pg_copy_logical_replication_slot_b</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L601" title="replication/slotfuncs.c:601">copy_replication_slot</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L844">&#x200c;</a><span class="linkable">pg_copy_logical_replication_slot_c</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L601" title="replication/slotfuncs.c:601">copy_replication_slot</a>(fcinfo, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L850">&#x200c;</a><span class="linkable">pg_copy_physical_replication_slot_a</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L601" title="replication/slotfuncs.c:601">copy_replication_slot</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L856">&#x200c;</a><span class="linkable">pg_copy_physical_replication_slot_b</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L601" title="replication/slotfuncs.c:601">copy_replication_slot</a>(fcinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Synchronize failover enabled replication slots to a standby server<br/></li>
<li></span><span class="Comment"> * from the primary server.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L866">&#x200c;</a><span class="linkable">pg_sync_replication_slots</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="libpqwalreceiver/libpqwalreceiver.c.html#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *err;<br/></li>
<li>&nbsp; &nbsp; StringInfoData app_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slot.c.html#L1384" title="replication/slot.c:1384">CheckSlotPermissions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;replication slots can only be synchronized to a standby server&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logical/slotsync.c.html#L1039" title="replication/logical/slotsync.c:1039">ValidateSlotSyncParams</a>(ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the libpq-specific <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/fmgr/dfmgr.c.html#L144" title="utils/fmgr/dfmgr.c:144">load_file</a>(<span class="Constant">&quot;libpqwalreceiver&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="logical/slotsync.c.html#L1013" title="replication/logical/slotsync.c:1013">CheckAndGetDbnameFromConninfo</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;app_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L540" title="utils/misc/guc_tables.c:540">cluster_name</a>[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;app_name, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">_slotsync&quot;</span>, <a href="../utils/misc/guc_tables.c.html#L540" title="utils/misc/guc_tables.c:540">cluster_name</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;app_name, <span class="Constant">&quot;slotsync&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Connect to the primary server. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a> = walrcv_connect(<a href="../access/transam/xlogrecovery.c.html#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app_name.data, &amp;err);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(app_name.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the primary server: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, err));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="logical/slotsync.c.html#L1725" title="replication/logical/slotsync.c:1725">SyncReplicationSlots</a>(<a href="walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walrcv_disconnect(<a href="walreceiver.c.html#L92" title="replication/walreceiver.c:92">wrconn</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
