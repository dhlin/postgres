<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/libpqwalreceiver/libpqwalreceiver.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/libpqwalreceiver/libpqwalreceiver.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L91">PQWalReceiverFunctions</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L40">WalReceiverConn</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L120">_PG_init</a></li>
<li><a href="#L786">libpqrcv_PQexec</a></li>
<li><a href="#L835">libpqrcv_PQgetResult</a></li>
<li><a href="#L1123">libpqrcv_alter_slot</a></li>
<li><a href="#L316">libpqrcv_check_conninfo</a></li>
<li><a href="#L143">libpqrcv_connect</a></li>
<li><a href="#L1010">libpqrcv_create_slot</a></li>
<li><a href="#L880">libpqrcv_disconnect</a></li>
<li><a href="#L655">libpqrcv_endstreaming</a></li>
<li><a href="#L1235">libpqrcv_exec</a></li>
<li><a href="#L1150">libpqrcv_get_backend_pid</a></li>
<li><a href="#L371">libpqrcv_get_conninfo</a></li>
<li><a href="#L502">libpqrcv_get_dbname_from_conninfo</a></li>
<li><a href="#L420">libpqrcv_get_senderinfo</a></li>
<li><a href="#L444">libpqrcv_identify_system</a></li>
<li><a href="#L1159">libpqrcv_processTuples</a></li>
<li><a href="#L732">libpqrcv_readtimelinehistoryfile</a></li>
<li><a href="#L904">libpqrcv_receive</a></li>
<li><a href="#L994">libpqrcv_send</a></li>
<li><a href="#L491">libpqrcv_server_version</a></li>
<li><a href="#L551">libpqrcv_startstreaming</a></li>
<li><a href="#L1315">stringlist_to_identifierstr</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * libpqwalreceiver.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains the libpq-specific parts of walreceiver. It's<br/></li>
<li></span><span class="Comment"> * loaded as a dynamic module to avoid linking the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> server binary with<br/></li>
<li></span><span class="Comment"> * libpq.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Apart from walreceiver, the libpq-specific routines are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> being used by<br/></li>
<li></span><span class="Comment"> * logical replication workers and slot synchronization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2010-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/replication/libpqwalreceiver/libpqwalreceiver.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/<a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq-fe.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pqexpbuffer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplestore.h&quot;<br/></li>
<li></span><br/></li>
<li>PG_MODULE_MAGIC;<br/></li>
<li><br/></li>
<li><a id="L40">&#x200c;</a><span class="Type">struct</span> <span class="linkable">WalReceiverConn</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Current connection to the primary, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; PGconn&nbsp; &nbsp; &nbsp;&nbsp; *streamConn;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Used to remember if the connection is logical or physical */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; logical;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Buffer for currently read <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *recvBuf;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Prototypes for interface <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<a href="#L143" title="replication/libpqwalreceiver/libpqwalreceiver.c:143">libpqrcv_connect</a>(<span class="Type">const</span> <span class="Type">char</span> *conninfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> replication, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> logical,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> must_use_password,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *appname, <span class="Type">char</span> **err);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L316" title="replication/libpqwalreceiver/libpqwalreceiver.c:316">libpqrcv_check_conninfo</a>(<span class="Type">const</span> <span class="Type">char</span> *conninfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> must_use_password);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L371" title="replication/libpqwalreceiver/libpqwalreceiver.c:371">libpqrcv_get_conninfo</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L420" title="replication/libpqwalreceiver/libpqwalreceiver.c:420">libpqrcv_get_senderinfo</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> **sender_host, <span class="Type">int</span> *sender_port);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L444" title="replication/libpqwalreceiver/libpqwalreceiver.c:444">libpqrcv_identify_system</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID *primary_tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L502" title="replication/libpqwalreceiver/libpqwalreceiver.c:502">libpqrcv_get_dbname_from_conninfo</a>(<span class="Type">const</span> <span class="Type">char</span> *conninfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L491" title="replication/libpqwalreceiver/libpqwalreceiver.c:491">libpqrcv_server_version</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L732" title="replication/libpqwalreceiver/libpqwalreceiver.c:732">libpqrcv_readtimelinehistoryfile</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID tli, <span class="Type">char</span> **filename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **content, <span class="Type">int</span> *len);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L551" title="replication/libpqwalreceiver/libpqwalreceiver.c:551">libpqrcv_startstreaming</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> WalRcvStreamOptions *options);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L655" title="replication/libpqwalreceiver/libpqwalreceiver.c:655">libpqrcv_endstreaming</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID *next_tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L904" title="replication/libpqwalreceiver/libpqwalreceiver.c:904">libpqrcv_receive</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">char</span> **buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pgsocket *wait_fd);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L994" title="replication/libpqwalreceiver/libpqwalreceiver.c:994">libpqrcv_send</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">const</span> <span class="Type">char</span> *buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nbytes);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1010" title="replication/libpqwalreceiver/libpqwalreceiver.c:1010">libpqrcv_create_slot</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *slotname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> temporary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> two_phase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> failover,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CRSSnapshotAction snapshot_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1123" title="replication/libpqwalreceiver/libpqwalreceiver.c:1123">libpqrcv_alter_slot</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">const</span> <span class="Type">char</span> *slotname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> failover);<br/></li>
<li><span class="Type">static</span> pid_t <a href="#L1150" title="replication/libpqwalreceiver/libpqwalreceiver.c:1150">libpqrcv_get_backend_pid</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn);<br/></li>
<li><span class="Type">static</span> WalRcvExecResult *<a href="#L1235" title="replication/libpqwalreceiver/libpqwalreceiver.c:1235">libpqrcv_exec</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">int</span> nRetTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *retTypes);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L880" title="replication/libpqwalreceiver/libpqwalreceiver.c:880">libpqrcv_disconnect</a>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn);<br/></li>
<li><br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> WalReceiverFunctionsType <span class="linkable">PQWalReceiverFunctions</span> = {<br/></li>
<li>&nbsp; &nbsp; .walrcv_connect = <a href="#L143" title="replication/libpqwalreceiver/libpqwalreceiver.c:143">libpqrcv_connect</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_check_conninfo = <a href="#L316" title="replication/libpqwalreceiver/libpqwalreceiver.c:316">libpqrcv_check_conninfo</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_get_conninfo = <a href="#L371" title="replication/libpqwalreceiver/libpqwalreceiver.c:371">libpqrcv_get_conninfo</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_get_senderinfo = <a href="#L420" title="replication/libpqwalreceiver/libpqwalreceiver.c:420">libpqrcv_get_senderinfo</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_identify_system = <a href="#L444" title="replication/libpqwalreceiver/libpqwalreceiver.c:444">libpqrcv_identify_system</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_server_version = <a href="#L491" title="replication/libpqwalreceiver/libpqwalreceiver.c:491">libpqrcv_server_version</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_readtimelinehistoryfile = <a href="#L732" title="replication/libpqwalreceiver/libpqwalreceiver.c:732">libpqrcv_readtimelinehistoryfile</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_startstreaming = <a href="#L551" title="replication/libpqwalreceiver/libpqwalreceiver.c:551">libpqrcv_startstreaming</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_endstreaming = <a href="#L655" title="replication/libpqwalreceiver/libpqwalreceiver.c:655">libpqrcv_endstreaming</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_receive = <a href="#L904" title="replication/libpqwalreceiver/libpqwalreceiver.c:904">libpqrcv_receive</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_send = <a href="#L994" title="replication/libpqwalreceiver/libpqwalreceiver.c:994">libpqrcv_send</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_create_slot = <a href="#L1010" title="replication/libpqwalreceiver/libpqwalreceiver.c:1010">libpqrcv_create_slot</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_alter_slot = <a href="#L1123" title="replication/libpqwalreceiver/libpqwalreceiver.c:1123">libpqrcv_alter_slot</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_get_dbname_from_conninfo = <a href="#L502" title="replication/libpqwalreceiver/libpqwalreceiver.c:502">libpqrcv_get_dbname_from_conninfo</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_get_backend_pid = <a href="#L1150" title="replication/libpqwalreceiver/libpqwalreceiver.c:1150">libpqrcv_get_backend_pid</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_exec = <a href="#L1235" title="replication/libpqwalreceiver/libpqwalreceiver.c:1235">libpqrcv_exec</a>,<br/></li>
<li>&nbsp; &nbsp; .walrcv_disconnect = <a href="#L880" title="replication/libpqwalreceiver/libpqwalreceiver.c:880">libpqrcv_disconnect</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Prototypes for private <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> PGresult *<a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(PGconn *streamConn, <span class="Type">const</span> <span class="Type">char</span> *query);<br/></li>
<li><span class="Type">static</span> PGresult *<a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(PGconn *streamConn);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1315" title="replication/libpqwalreceiver/libpqwalreceiver.c:1315">stringlist_to_identifierstr</a>(PGconn *conn, List *strings);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Module initialization function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L120">&#x200c;</a></span><span class="linkable">_PG_init</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../walreceiver.c.html#L93" title="replication/walreceiver.c:93">WalReceiverFunctions</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;libpqwalreceiver already loaded&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../walreceiver.c.html#L93" title="replication/walreceiver.c:93">WalReceiverFunctions</a> = &amp;<a href="#L91" title="replication/libpqwalreceiver/libpqwalreceiver.c:91">PQWalReceiverFunctions</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Establish the connection to the primary server.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function can be used for both replication and regular connections.<br/></li>
<li></span><span class="Comment"> * If it is a replication connection, it could be either logical or physical<br/></li>
<li></span><span class="Comment"> * based on input argument 'logical'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an error occurs, this function will normally return NULL and set *err<br/></li>
<li></span><span class="Comment"> * to a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ed error message. However, if must_use_password is true and<br/></li>
<li></span><span class="Comment"> * the connection fails to use the password, this function will ereport(ERROR).<br/></li>
<li></span><span class="Comment"> * We do this because in that case the error includes a detail and a hint for<br/></li>
<li></span><span class="Comment"> * consistency with other parts of the system, and it's not worth adding the<br/></li>
<li></span><span class="Comment"> * machinery to pass all of those back to the caller just to cover this one<br/></li>
<li></span><span class="Comment"> * case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *<br/></li>
<li><a id="L143">&#x200c;</a><span class="linkable">libpqrcv_connect</span>(<span class="Type">const</span> <span class="Type">char</span> *conninfo, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> replication, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> logical,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> must_use_password, <span class="Type">const</span> <span class="Type">char</span> *appname, <span class="Type">char</span> **err)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn;<br/></li>
<li>&nbsp; &nbsp; PostgresPollingStatusType status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *keys[<span class="Constant">6</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *vals[<span class="Constant">6</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-validate connection string. The validation already happened at DDL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time, but the subscription owner may have changed. If we don't recheck<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the correct must_use_password, it's possible that the connection<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will obtain the password from a different source, such as PGPASSFILE or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PGPASSWORD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L316" title="replication/libpqwalreceiver/libpqwalreceiver.c:316">libpqrcv_check_conninfo</a>(conninfo, must_use_password);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the expand_dbname parameter to process the connection string (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * URI), and pass some extra options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; keys[i] = <span class="Constant">&quot;dbname&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; vals[i] = conninfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can not have logical without replication */<br/></li>
<li></span>&nbsp; &nbsp; Assert(replication || !logical);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replication)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keys[++i] = <span class="Constant">&quot;replication&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vals[i] = logical ? <span class="Constant">&quot;database&quot;</span> : <span class="Constant">&quot;true&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (logical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell the publisher to <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> to our encoding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keys[++i] = <span class="Constant">&quot;client_encoding&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vals[i] = <a href="../../utils/mb/mbutils.c.html#L1267" title="utils/mb/mbutils.c:1267">GetDatabaseEncodingName</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force assorted GUC parameters to settings that ensure that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * publisher will output data <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a form that is unambiguous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the subscriber.&nbsp; (We don't want to modify the subscriber's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * GUC settings, since that might surprise user-defined code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running in the subscriber, such as triggers.)&nbsp; This should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match what pg_dump does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keys[++i] = <span class="Constant">&quot;options&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vals[i] = <span class="Constant">&quot;-c datestyle=ISO -c intervalstyle=postgres -c <a href="../../utils/adt/float.c.html#L41" title="utils/adt/float.c:41">extra_float_digits</a>=3&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The database name is ignored by the server in replication mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but specify &quot;replication&quot; for .pgpass lookup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keys[++i] = <span class="Constant">&quot;dbname&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vals[i] = <span class="Constant">&quot;replication&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keys[++i] = <span class="Constant">&quot;fallback_application_name&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; vals[i] = appname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keys[++i] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; vals[i] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(i &lt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(keys));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conn = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a>));<br/></li>
<li>&nbsp; &nbsp; conn-&gt;streamConn = PQconnectStartParams(keys, vals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* expand_dbname = */</span> <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQstatus(conn-&gt;streamConn) == CONNECTION_BAD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_connection_errmsg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Poll connection until we have OK or FAILED status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per spec for PQconnectPoll, first wait till <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is write-ready.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; status = PGRES_POLLING_WRITING;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_flag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == PGRES_POLLING_READING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_flag = WL_SOCKET_READABLE;<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Windows needs a different test while <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for connection-made */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (PQstatus(conn-&gt;streamConn) == CONNECTION_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_flag = WL_SOCKET_CONNECTED;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_flag = WL_SOCKET_WRITEABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_EXIT_ON_PM_DEATH | WL_LATCH_SET | io_flag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PQsocket(conn-&gt;streamConn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_LIBPQWALRECEIVER_CONNECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Interrupted? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiver.c.html#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is ready, advance the libpq state machine */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; io_flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = PQconnectPoll(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (status != PGRES_POLLING_OK &amp;&amp; status != PGRES_POLLING_FAILED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQstatus(conn-&gt;streamConn) != CONNECTION_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_connection_errmsg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (must_use_password &amp;&amp; !PQconnectionUsedPassword(conn-&gt;streamConn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQfinish(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(conn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_R_E_PROHIBITED_SQL_STATEMENT_ATTEMPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;password is required&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Non-<a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> cannot <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> if the server does not request a password.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Target server's authentication method must be changed, or set password_required=false in the subscription parameters.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set always-secure search path for the cases where the connection is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used to run SQL queries, so malicious users can't get control.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!replication || logical)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(conn-&gt;streamConn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALWAYS_SECURE_SEARCH_PATH_SQL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) != PGRES_TUPLES_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *err = psprintf(<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not clear search path: </span><span class="Special">%s</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> bad_connection;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; conn-&gt;logical = logical;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> conn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* error path, using libpq's error message */<br/></li>
<li></span><span class="Statement">bad_connection_errmsg</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; *err = <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* error path, error already set */<br/></li>
<li></span><span class="Statement">bad_connection</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; PQfinish(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(conn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate connection info string, and determine whether it might cause<br/></li>
<li></span><span class="Comment"> * local filesystem access to be attempted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the connection string can't be parsed, this function will raise<br/></li>
<li></span><span class="Comment"> * an error and will not return. If it can, it will return true if this<br/></li>
<li></span><span class="Comment"> * connection string specifies a password and false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L316">&#x200c;</a></span><span class="linkable">libpqrcv_check_conninfo</span>(<span class="Type">const</span> <span class="Type">char</span> *conninfo, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> must_use_password)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PQconninfoOption *opts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; PQconninfoOption *opt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *err = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opts = PQconninfoParse(conninfo, &amp;err);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The error string is malloc'd, so we must free it explicitly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errcopy = err ? <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(err) : <span class="Constant">&quot;out of memory&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQfreemem(err);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid connection string syntax: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errcopy)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (must_use_password)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; uses_password = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (opt = opts; opt-&gt;keyword != <span class="Constant">NULL</span>; ++opt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore connection options that are not present. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opt-&gt;val == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(opt-&gt;keyword, <span class="Constant">&quot;password&quot;</span>) == <span class="Constant">0</span> &amp;&amp; opt-&gt;val[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uses_password = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!uses_password)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* malloc'd, so we must free it explicitly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQconninfoFree(opts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_R_E_PROHIBITED_SQL_STATEMENT_ATTEMPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;password is required&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Non-superusers must provide a password in the connection string.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PQconninfoFree(opts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a user-displayable conninfo string.&nbsp; Any security-sensitive fields<br/></li>
<li></span><span class="Comment"> * are obfuscated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">libpqrcv_get_conninfo</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PQconninfoOption *conn_opts;<br/></li>
<li>&nbsp; &nbsp; PQconninfoOption *conn_opt;<br/></li>
<li>&nbsp; &nbsp; PQExpBufferData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(conn-&gt;streamConn != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initPQExpBuffer(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; conn_opts = PQconninfo(conn-&gt;streamConn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (conn_opts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> connection string: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;out of memory&quot;</span>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build a clean connection string from pieces */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (conn_opt = conn_opts; conn_opt-&gt;keyword != <span class="Constant">NULL</span>; conn_opt++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; obfuscate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip debug and empty options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strchr(conn_opt-&gt;dispchar, <span class="Constant">'D'</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conn_opt-&gt;val == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conn_opt-&gt;val[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Obfuscate security-sensitive options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; obfuscate = strchr(conn_opt-&gt;dispchar, <span class="Constant">'*'</span>) != <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendPQExpBuffer(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf.len == <span class="Constant">0</span> ? <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot; &quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conn_opt-&gt;keyword,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; obfuscate ? <span class="Constant">&quot;********&quot;</span> : conn_opt-&gt;val);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PQconninfoFree(conn_opts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = PQExpBufferDataBroken(buf) ? <span class="Constant">NULL</span> : <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; termPQExpBuffer(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Provides information of sender this WAL receiver is connected to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L420">&#x200c;</a></span><span class="linkable">libpqrcv_get_senderinfo</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">char</span> **sender_host,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *sender_port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *sender_host = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; *sender_port = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(conn-&gt;streamConn != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = PQhost(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret &amp;&amp; strlen(ret) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *sender_host = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(ret);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = PQport(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret &amp;&amp; strlen(ret) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *sender_port = atoi(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that primary's system identifier matches ours, and fetch the current<br/></li>
<li></span><span class="Comment"> * timeline ID of the primary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L444">&#x200c;</a><span class="linkable">libpqrcv_identify_system</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, TimeLineID *primary_tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *primary_sysid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the system identifier and timeline ID as a DataRow message from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * primary server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(conn-&gt;streamConn, <span class="Constant">&quot;IDENTIFY_SYSTEM&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) != PGRES_TUPLES_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive database system identifier and timeline ID from &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;the primary server: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IDENTIFY_SYSTEM returns 3 columns in 9.3 and earlier, and 4 columns in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 9.4 and onwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PQnfields(res) &lt; <span class="Constant">3</span> || PQntuples(res) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples = PQntuples(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfields = PQnfields(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid response from primary server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not identify system: got </span><span class="Special">%d</span><span class="Constant"> rows and </span><span class="Special">%d</span><span class="Constant"> fields, expected </span><span class="Special">%d</span><span class="Constant"> rows and </span><span class="Special">%d</span><span class="Constant"> or more fields.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ntuples, nfields, <span class="Constant">1</span>, <span class="Constant">3</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; primary_sysid = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(PQgetvalue(res, <span class="Constant">0</span>, <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; *primary_tli = <a href="../../utils/adt/numutils.c.html#L383" title="utils/adt/numutils.c:383">pg_strtoint32</a>(PQgetvalue(res, <span class="Constant">0</span>, <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; PQclear(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> primary_sysid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Thin wrapper around libpq to obtain server version.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L491">&#x200c;</a></span><span class="linkable">libpqrcv_server_version</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PQserverVersion(conn-&gt;streamConn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get database name from the primary server's conninfo.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If dbname is not found in connInfo, return NULL value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L502">&#x200c;</a><span class="linkable">libpqrcv_get_dbname_from_conninfo</span>(<span class="Type">const</span> <span class="Type">char</span> *connInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PQconninfoOption *opts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *err = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opts = PQconninfoParse(connInfo, &amp;err);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The error string is malloc'd, so we must free it explicitly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errcopy = err ? <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(err) : <span class="Constant">&quot;out of memory&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQfreemem(err);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid connection string syntax: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, errcopy)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (PQconninfoOption *opt = opts; opt-&gt;keyword != <span class="Constant">NULL</span>; ++opt)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If multiple dbnames are specified, then the last one will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(opt-&gt;keyword, <span class="Constant">&quot;dbname&quot;</span>) == <span class="Constant">0</span> &amp;&amp; opt-&gt;val &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *opt-&gt;val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dbname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dbname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(opt-&gt;val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PQconninfoFree(opts);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dbname;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start streaming WAL data from given streaming options.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if we switched successfully to copy-both mode. False<br/></li>
<li></span><span class="Comment"> * means the server received the command and executed it successfully, but<br/></li>
<li></span><span class="Comment"> * didn't switch to copy-mode.&nbsp; That means that there was no WAL on the<br/></li>
<li></span><span class="Comment"> * requested timeline and starting point, because the server switched to<br/></li>
<li></span><span class="Comment"> * another timeline at or <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the requested starting point. On failure,<br/></li>
<li></span><span class="Comment"> * throws an ERROR.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L551">&#x200c;</a></span><span class="linkable">libpqrcv_startstreaming</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> WalRcvStreamOptions *options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData cmd;<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(options-&gt;logical == conn-&gt;logical);<br/></li>
<li>&nbsp; &nbsp; Assert(options-&gt;slotname || !options-&gt;logical);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the command. */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;START_REPLICATION&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;slotname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot; SLOT </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; options-&gt;slotname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;logical)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot; LOGICAL&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot; </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>, LSN_FORMAT_ARGS(options-&gt;startpoint));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additional options are different depending on if we are doing logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or physical replication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;logical)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pubnames_str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pubnames;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pubnames_literal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot; (&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot;proto_version '</span><span class="Special">%u</span><span class="Constant">'&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; options-&gt;proto.logical.proto_version);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;proto.logical.streaming_str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot;, streaming '</span><span class="Special">%s</span><span class="Constant">'&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; options-&gt;proto.logical.streaming_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;proto.logical.twophase &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQserverVersion(conn-&gt;streamConn) &gt;= <span class="Constant">150000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;, two_phase 'on'&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;proto.logical.origin &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQserverVersion(conn-&gt;streamConn) &gt;= <span class="Constant">160000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot;, origin '</span><span class="Special">%s</span><span class="Constant">'&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; options-&gt;proto.logical.origin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubnames = options-&gt;proto.logical.publication_names;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubnames_str = <a href="#L1315" title="replication/libpqwalreceiver/libpqwalreceiver.c:1315">stringlist_to_identifierstr</a>(conn-&gt;streamConn, pubnames);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pubnames_str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),&nbsp; &nbsp; <span class="Comment">/* likely guess */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not start WAL streaming: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pubnames_literal = PQescapeLiteral(conn-&gt;streamConn, pubnames_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(pubnames_str));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pubnames_literal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),&nbsp; &nbsp; <span class="Comment">/* likely guess */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not start WAL streaming: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot;, publication_names </span><span class="Special">%s</span><span class="Constant">&quot;</span>, pubnames_literal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQfreemem(pubnames_literal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pubnames_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;proto.logical.binary &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQserverVersion(conn-&gt;streamConn) &gt;= <span class="Constant">140000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;, binary 'true'&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;cmd, <span class="Constant">')'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot; TIMELINE </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; options-&gt;proto.physical.startpointTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start streaming. */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(conn-&gt;streamConn, cmd.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cmd.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) == PGRES_COMMAND_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (PQresultStatus(res) != PGRES_COPY_BOTH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not start WAL streaming: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stop streaming WAL data. Returns the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline's ID in *next_tli, as<br/></li>
<li></span><span class="Comment"> * reported by the server, or 0 if it did not report it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L655">&#x200c;</a></span><span class="linkable">libpqrcv_endstreaming</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, TimeLineID *next_tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send copy-end message.&nbsp; As in <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>, this could theoretically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block, but the risk seems small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PQputCopyEnd(conn-&gt;streamConn, <span class="Constant">NULL</span>) &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQflush(conn-&gt;streamConn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> end-of-streaming message to primary: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *next_tli = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After COPY is finished, we should receive a result set indicating the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline's ID, or just CommandComplete if the server was shut<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we had not yet received CopyDone from the backend, PGRES_COPY_OUT is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also possible in case we aborted the copy in mid-stream.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) == PGRES_TUPLES_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline's ID. The server also sends the timeline's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting point, but it is ignored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQnfields(res) &lt; <span class="Constant">2</span> || PQntuples(res) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected result set after end-of-streaming&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *next_tli = <a href="../../utils/adt/numutils.c.html#L383" title="utils/adt/numutils.c:383">pg_strtoint32</a>(PQgetvalue(res, <span class="Constant">0</span>, <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the result set should be followed by CommandComplete */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (PQresultStatus(res) == PGRES_COPY_OUT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End the copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQendcopy(conn-&gt;streamConn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;error while shutting down streaming COPY: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CommandComplete should follow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) != PGRES_COMMAND_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;error reading result of streaming command: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; PQclear(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify that there are no more results */<br/></li>
<li></span>&nbsp; &nbsp; res = <a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected result after CommandComplete: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the timeline history file for 'tli' from primary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L732">&#x200c;</a></span><span class="linkable">libpqrcv_readtimelinehistoryfile</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID tli, <span class="Type">char</span> **filename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **content, <span class="Type">int</span> *len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; cmd[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!conn-&gt;logical);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Request the primary to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> over the history file for given timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(cmd, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(cmd), <span class="Constant">&quot;TIMELINE_HISTORY </span><span class="Special">%u</span><span class="Constant">&quot;</span>, tli);<br/></li>
<li>&nbsp; &nbsp; res = <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(conn-&gt;streamConn, cmd);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) != PGRES_TUPLES_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive timeline history file from &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;the primary server: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQnfields(res) != <span class="Constant">2</span> || PQntuples(res) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples = PQntuples(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfields = PQnfields(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid response from primary server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected 1 tuple with 2 fields, got </span><span class="Special">%d</span><span class="Constant"> tuples with </span><span class="Special">%d</span><span class="Constant"> fields.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ntuples, nfields)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *filename = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(PQgetvalue(res, <span class="Constant">0</span>, <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *len = PQgetlength(res, <span class="Constant">0</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; *content = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(*len);<br/></li>
<li>&nbsp; &nbsp; memcpy(*content, PQgetvalue(res, <span class="Constant">0</span>, <span class="Constant">1</span>), *len);<br/></li>
<li>&nbsp; &nbsp; PQclear(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a query and wait for the results by using the asynchronous libpq<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> readiness events.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function is modeled on libpqsrv_exec(), with the behavior difference<br/></li>
<li></span><span class="Comment"> * being that it calls <a href="../walreceiver.c.html#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>().&nbsp; As an optimization, it<br/></li>
<li></span><span class="Comment"> * skips try/catch, since all errors terminate the process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * May return NULL, rather than an error result, on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PGresult *<br/></li>
<li><a id="L786">&#x200c;</a><span class="linkable">libpqrcv_PQexec</span>(PGconn *streamConn, <span class="Type">const</span> <span class="Type">char</span> *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *lastResult = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PQexec() silently discards <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prior query results on the connection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not required for this function as it's expected that the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (which is this library in all cases) will behave correctly and we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to be backwards compatible with old libpq.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Submit the query.&nbsp; Since we don't use non-blocking mode, this could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * theoretically block.&nbsp; In practice, since we don't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> very long query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strings, the risk seems negligible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PQsendQuery(streamConn, query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for, and collect, the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> PGresult. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PGresult&nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(streamConn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* query is complete, or failure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emulate PQexec()'s behavior of returning the last result when there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are many.&nbsp; We are fine with returning just last error message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(lastResult);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastResult = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(lastResult) == PGRES_COPY_IN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQresultStatus(lastResult) == PGRES_COPY_OUT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQresultStatus(lastResult) == PGRES_COPY_BOTH ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQstatus(streamConn) == CONNECTION_BAD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lastResult;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform the equivalent of PQgetResult(), but watch for interrupts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> PGresult *<br/></li>
<li><a id="L835">&#x200c;</a><span class="linkable">libpqrcv_PQgetResult</span>(PGconn *streamConn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect data until PQgetResult is ready to get the result without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (PQisBusy(streamConn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to break down the sleep into smaller increments,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we'll get interrupted by signals and can handle <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupts here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L565" title="storage/ipc/latch.c:565">WaitLatchOrSocket</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_EXIT_ON_PM_DEATH | WL_SOCKET_READABLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PQsocket(streamConn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Interrupted? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiver.c.html#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Consume whatever data is available from the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQconsumeInput(streamConn) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trouble; return NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can collect and return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> PGresult */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> PQgetResult(streamConn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Disconnect connection to primary, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L880">&#x200c;</a></span><span class="linkable">libpqrcv_disconnect</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PQfinish(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; PQfreemem(conn-&gt;recvBuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(conn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Receive a message available from XLOG stream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; If data was received, returns the length of the data. *buffer is set to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; point to a buffer holding the received message. The buffer is only valid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> libpqrcv_* call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; If no data was available immediately, returns 0, and *wait_fd is set to a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> descriptor which can be waited on <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying again.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; -1 if the server ended the COPY.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ereports on error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L904">&#x200c;</a></span><span class="linkable">libpqrcv_receive</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">char</span> **buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pgsocket *wait_fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PQfreemem(conn-&gt;recvBuf);<br/></li>
<li>&nbsp; &nbsp; conn-&gt;recvBuf = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to receive a CopyData message */<br/></li>
<li></span>&nbsp; &nbsp; rawlen = PQgetCopyData(conn-&gt;streamConn, &amp;conn-&gt;recvBuf, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rawlen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try consuming some data. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQconsumeInput(conn-&gt;streamConn) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive data from WAL stream: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now that we've consumed some input, try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rawlen = PQgetCopyData(conn-&gt;streamConn, &amp;conn-&gt;recvBuf, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rawlen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell caller to try again when our <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is ready. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *wait_fd = PQsocket(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rawlen == -<span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end-of-streaming or error */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) == PGRES_COMMAND_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that there are no more results. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L835" title="replication/libpqwalreceiver/libpqwalreceiver.c:835">libpqrcv_PQgetResult</a>(conn-&gt;streamConn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the other side closed the connection orderly (otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'd seen an error, or PGRES_COPY_IN) don't report an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here, but let callers deal with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQstatus(conn-&gt;streamConn) == CONNECTION_BAD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected result after CommandComplete: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQerrorMessage(conn-&gt;streamConn))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (PQresultStatus(res) == PGRES_COPY_IN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive data from WAL stream: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rawlen &lt; -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not receive data from WAL stream: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return received messages to caller */<br/></li>
<li></span>&nbsp; &nbsp; *buffer = conn-&gt;recvBuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rawlen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a message to XLOG stream.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ereports on error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L994">&#x200c;</a></span><span class="linkable">libpqrcv_send</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">const</span> <span class="Type">char</span> *buffer, <span class="Type">int</span> nbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQputCopyData(conn-&gt;streamConn, buffer, nbytes) &lt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQflush(conn-&gt;streamConn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data to WAL stream: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create new replication slot.<br/></li>
<li></span><span class="Comment"> * Returns the name of the exported snapshot for logical slot or NULL for<br/></li>
<li></span><span class="Comment"> * physical slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1010">&#x200c;</a><span class="linkable">libpqrcv_create_slot</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">const</span> <span class="Type">char</span> *slotname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> temporary, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> two_phase, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> failover,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CRSSnapshotAction snapshot_action, XLogRecPtr *lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li>&nbsp; &nbsp; StringInfoData cmd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *snapshot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_new_options_syntax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; use_new_options_syntax = (PQserverVersion(conn-&gt;streamConn) &gt;= <span class="Constant">150000</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot;CREATE_REPLICATION_SLOT </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, slotname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (temporary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot; TEMPORARY&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (conn-&gt;logical)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot; LOGICAL pgoutput &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_new_options_syntax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;cmd, <span class="Constant">'('</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (two_phase)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;TWO_PHASE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_new_options_syntax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;cmd, <span class="Constant">' '</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (failover)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;FAILOVER&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_new_options_syntax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;cmd, <span class="Constant">' '</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_new_options_syntax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (snapshot_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CRS_EXPORT_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;SNAPSHOT 'export'&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CRS_NOEXPORT_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;SNAPSHOT 'nothing'&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CRS_USE_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;SNAPSHOT 'use'&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (snapshot_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CRS_EXPORT_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;EXPORT_SNAPSHOT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CRS_NOEXPORT_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;NOEXPORT_SNAPSHOT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CRS_USE_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot;USE_SNAPSHOT&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_new_options_syntax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;cmd, <span class="Constant">')'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_new_options_syntax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot; PHYSICAL (RESERVE_WAL)&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;cmd, <span class="Constant">&quot; PHYSICAL RESERVE_WAL&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(conn-&gt;streamConn, cmd.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cmd.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) != PGRES_TUPLES_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQclear(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotname, <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lsn = DatumGetLSN(<a href="../../utils/fmgr/fmgr.c.html#L792" title="utils/fmgr/fmgr.c:792">DirectFunctionCall1Coll</a>(<a href="../../utils/adt/pg_lsn.c.html#L63" title="utils/adt/pg_lsn.c:63">pg_lsn_in</a>, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(PQgetvalue(res, <span class="Constant">0</span>, <span class="Constant">1</span>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PQgetisnull(res, <span class="Constant">0</span>, <span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(PQgetvalue(res, <span class="Constant">0</span>, <span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PQclear(res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Change the definition of the replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1123">&#x200c;</a></span><span class="linkable">libpqrcv_alter_slot</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">const</span> <span class="Type">char</span> *slotname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> failover)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData cmd;<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;cmd);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;cmd, <span class="Constant">&quot;ALTER_REPLICATION_SLOT </span><span class="Special">%s</span><span class="Constant"> ( FAILOVER </span><span class="Special">%s</span><span class="Constant"> )&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/adt/ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(slotname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; failover ? <span class="Constant">&quot;true&quot;</span> : <span class="Constant">&quot;false&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(conn-&gt;streamConn, cmd.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cmd.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PQresultStatus(res) != PGRES_COMMAND_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not alter replication slot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotname, <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PQclear(res);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return PID of remote backend process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pid_t<br/></li>
<li><a id="L1150">&#x200c;</a><span class="linkable">libpqrcv_get_backend_pid</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PQbackendPID(conn-&gt;streamConn);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert tuple query result to tuplestore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1159">&#x200c;</a></span><span class="linkable">libpqrcv_processTuples</span>(PGresult *pgres, WalRcvExecResult *walres,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">int</span> nRetTypes, <span class="Type">const</span> Oid *retTypes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coln;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfields = PQnfields(pgres);<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; AttInMetadata *attinmeta;<br/></li>
<li>&nbsp; &nbsp; MemoryContext rowcontext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we got expected number of fields. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nfields != nRetTypes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid query response&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Expected </span><span class="Special">%d</span><span class="Constant"> fields, got </span><span class="Special">%d</span><span class="Constant"> fields.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nRetTypes, nfields)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walres-&gt;tuplestore = <a href="../../utils/sort/tuplestore.c.html#L318" title="utils/sort/tuplestore.c:318">tuplestore_begin_heap</a>(<span class="Constant">true</span>, <span class="Constant">false</span>, <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create tuple descriptor corresponding to expected result. */<br/></li>
<li></span>&nbsp; &nbsp; walres-&gt;tupledesc = <a href="../../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(nRetTypes);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (coln = <span class="Constant">0</span>; coln &lt; nRetTypes; coln++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(walres-&gt;tupledesc, (AttrNumber) coln + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PQfname(pgres, coln), retTypes[coln], -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; attinmeta = <a href="../../executor/execTuples.c.html#L2173" title="executor/execTuples.c:2173">TupleDescGetAttInMetadata</a>(walres-&gt;tupledesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No point in doing more here if there were no tuples returned. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PQntuples(pgres) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create temporary context for local allocations. */<br/></li>
<li></span>&nbsp; &nbsp; rowcontext = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;libpqrcv query result context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process returned rows. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (tupn = <span class="Constant">0</span>; tupn &lt; PQntuples(pgres); tupn++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cstrs[MaxTupleAttributeNumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../walreceiver.c.html#L162" title="replication/walreceiver.c:162">ProcessWalRcvInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the allocations in temporary context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(rowcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fill cstrs with null-terminated strings of column <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (coln = <span class="Constant">0</span>; coln &lt; nfields; coln++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PQgetisnull(pgres, tupn, coln))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstrs[coln] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cstrs[coln] = PQgetvalue(pgres, tupn, coln);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert row to a tuple, and add it to the tuplestore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../executor/execTuples.c.html#L2222" title="executor/execTuples.c:2222">BuildTupleFromCStrings</a>(attinmeta, cstrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplestore.c.html#L730" title="utils/sort/tuplestore.c:730">tuplestore_puttuple</a>(walres-&gt;tuplestore, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clean up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(rowcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(rowcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Public interface for sending generic queries (and commands).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can only be called from process connected to database.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> WalRcvExecResult *<br/></li>
<li><a id="L1235">&#x200c;</a><span class="linkable">libpqrcv_exec</span>(<a href="#L40" title="replication/libpqwalreceiver/libpqwalreceiver.c:40">WalReceiverConn</a> *conn, <span class="Type">const</span> <span class="Type">char</span> *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span> nRetTypes, <span class="Type">const</span> Oid *retTypes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGresult&nbsp;&nbsp; *pgres = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; WalRcvExecResult *walres = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalRcvExecResult));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *diag_sqlstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the query interface requires a database connection&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgres = <a href="#L786" title="replication/libpqwalreceiver/libpqwalreceiver.c:786">libpqrcv_PQexec</a>(conn-&gt;streamConn, query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (PQresultStatus(pgres))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_TUPLES_OK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_SINGLE_TUPLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_TUPLES_CHUNK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_OK_TUPLES;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1159" title="replication/libpqwalreceiver/libpqwalreceiver.c:1159">libpqrcv_processTuples</a>(pgres, walres, nRetTypes, retTypes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_COPY_IN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_OK_COPY_IN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_COPY_OUT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_OK_COPY_OUT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_COPY_BOTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_OK_COPY_BOTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_COMMAND_OK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_OK_COMMAND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Empty query is considered error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_EMPTY_QUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;err = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;empty query&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_PIPELINE_SYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_PIPELINE_ABORTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;err = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;unexpected pipeline mode&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_NONFATAL_ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_FATAL_ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PGRES_BAD_RESPONSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;status = WALRCV_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;err = <a href="../../utils/mmgr/mcxt.c.html#L1723" title="utils/mmgr/mcxt.c:1723">pchomp</a>(PQerrorMessage(conn-&gt;streamConn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diag_sqlstate = PQresultErrorField(pgres, PG_DIAG_SQLSTATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (diag_sqlstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walres-&gt;sqlstate = MAKE_SQLSTATE(diag_sqlstate[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diag_sqlstate[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diag_sqlstate[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diag_sqlstate[<span class="Constant">3</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; diag_sqlstate[<span class="Constant">4</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PQclear(pgres);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> walres;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a List of strings, return it as single comma separated<br/></li>
<li></span><span class="Comment"> * string, quoting identifiers as needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is essentially the reverse of <a href="../../utils/adt/varlena.c.html#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller should free the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1315">&#x200c;</a><span class="linkable">stringlist_to_identifierstr</span>(PGconn *conn, List *strings)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; StringInfoData res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;res);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, strings)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val = strVal(lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *val_escaped;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;res, <span class="Constant">','</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val_escaped = PQescapeIdentifier(conn, val, strlen(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!val_escaped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(res.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;res, val_escaped);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PQfreemem(val_escaped);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res.data;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
