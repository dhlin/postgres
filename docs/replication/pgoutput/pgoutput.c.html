<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>replication/pgoutput/pgoutput.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>replication/pgoutput/pgoutput.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L210">RelationSyncCache</a></li>
<li><a href="#L82">publications_valid</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L204">PGOutputTxnData</a></li>
<li><a href="#L207">PGOutputTxnData</a></li>
<li><a href="#L125">RelationSyncEntry</a></li>
<li><a href="#L178">RelationSyncEntry</a></li>
<li><a href="#L98">RowFilterPubAction</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1707">LoadPublications</a></li>
<li><a href="#L247">_PG_output_plugin_init</a></li>
<li><a href="#L2232">cleanup_rel_sync_cache</a></li>
<li><a href="#L794">create_estate_for_relation</a></li>
<li><a href="#L1963">get_rel_sync_entry</a></li>
<li><a href="#L1932">get_schema_sent_in_streamed_txn</a></li>
<li><a href="#L1878">init_rel_sync_cache</a></li>
<li><a href="#L1130">init_tuple_slot</a></li>
<li><a href="#L679">maybe_send_schema</a></li>
<li><a href="#L276">parse_output_parameters</a></li>
<li><a href="#L616">pgoutput_begin_prepare_txn</a></li>
<li><a href="#L548">pgoutput_begin_txn</a></li>
<li><a href="#L1403">pgoutput_change</a></li>
<li><a href="#L1015">pgoutput_column_list_init</a></li>
<li><a href="#L647">pgoutput_commit_prepared_txn</a></li>
<li><a href="#L584">pgoutput_commit_txn</a></li>
<li><a href="#L847">pgoutput_ensure_entry_cxt</a></li>
<li><a href="#L1630">pgoutput_message</a></li>
<li><a href="#L1675">pgoutput_origin_filter</a></li>
<li><a href="#L633">pgoutput_prepare_txn</a></li>
<li><a href="#L661">pgoutput_rollback_prepared_txn</a></li>
<li><a href="#L1222">pgoutput_row_filter</a></li>
<li><a href="#L824">pgoutput_row_filter_exec_expr</a></li>
<li><a href="#L869">pgoutput_row_filter_init</a></li>
<li><a href="#L562">pgoutput_send_begin</a></li>
<li><a href="#L1694">pgoutput_shutdown</a></li>
<li><a href="#L418">pgoutput_startup</a></li>
<li><a href="#L1797">pgoutput_stream_abort</a></li>
<li><a href="#L1830">pgoutput_stream_commit</a></li>
<li><a href="#L1858">pgoutput_stream_prepare_txn</a></li>
<li><a href="#L1744">pgoutput_stream_start</a></li>
<li><a href="#L1776">pgoutput_stream_stop</a></li>
<li><a href="#L1562">pgoutput_truncate</a></li>
<li><a href="#L1729">publication_invalidation_cb</a></li>
<li><a href="#L2318">rel_sync_cache_publication_cb</a></li>
<li><a href="#L2267">rel_sync_cache_relation_cb</a></li>
<li><a href="#L750">send_relation_and_attrs</a></li>
<li><a href="#L2344">send_repl_origin</a></li>
<li><a href="#L1942">set_schema_sent_in_streamed_txn</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L105">NUM_ROWFILTER_PUBACTIONS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pgoutput.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Logical Replication output plugin<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2012-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/replication/pgoutput/pgoutput.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/tupconvert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_publication.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_publication_rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/subscriptioncmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;fmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalproto.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/pgoutput.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li>PG_MODULE_MAGIC;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L418" title="replication/pgoutput/pgoutput.c:418">pgoutput_startup</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OutputPluginOptions *opt, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_init);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1694" title="replication/pgoutput/pgoutput.c:1694">pgoutput_shutdown</a>(LogicalDecodingContext *ctx);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L548" title="replication/pgoutput/pgoutput.c:548">pgoutput_begin_txn</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L584" title="replication/pgoutput/pgoutput.c:584">pgoutput_commit_txn</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn, XLogRecPtr commit_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1403" title="replication/pgoutput/pgoutput.c:1403">pgoutput_change</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn, Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1562" title="replication/pgoutput/pgoutput.c:1562">pgoutput_truncate</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn, <span class="Type">int</span> nrelations, Relation relations[],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1630" title="replication/pgoutput/pgoutput.c:1630">pgoutput_message</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn, XLogRecPtr message_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional, <span class="Type">const</span> <span class="Type">char</span> *prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size sz, <span class="Type">const</span> <span class="Type">char</span> *message);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1675" title="replication/pgoutput/pgoutput.c:1675">pgoutput_origin_filter</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RepOriginId origin_id);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L616" title="replication/pgoutput/pgoutput.c:616">pgoutput_begin_prepare_txn</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L633" title="replication/pgoutput/pgoutput.c:633">pgoutput_prepare_txn</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn, XLogRecPtr prepare_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L647" title="replication/pgoutput/pgoutput.c:647">pgoutput_commit_prepared_txn</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn, XLogRecPtr commit_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L661" title="replication/pgoutput/pgoutput.c:661">pgoutput_rollback_prepared_txn</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz prepare_time);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1744" title="replication/pgoutput/pgoutput.c:1744">pgoutput_stream_start</a>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1776" title="replication/pgoutput/pgoutput.c:1776">pgoutput_stream_stop</a>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1797" title="replication/pgoutput/pgoutput.c:1797">pgoutput_stream_abort</a>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr abort_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1830" title="replication/pgoutput/pgoutput.c:1830">pgoutput_stream_commit</a>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1858" title="replication/pgoutput/pgoutput.c:1858">pgoutput_stream_prepare_txn</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn, XLogRecPtr prepare_lsn);<br/></li>
<li><br/></li>
<li><a id="L82">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">publications_valid</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> List *<a href="#L1707" title="replication/pgoutput/pgoutput.c:1707">LoadPublications</a>(List *pubnames);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1729" title="replication/pgoutput/pgoutput.c:1729">publication_invalidation_cb</a>(Datum arg, <span class="Type">int</span> cacheid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 hashvalue);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L750" title="replication/pgoutput/pgoutput.c:750">send_relation_and_attrs</a>(Relation relation, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *columns);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2344" title="replication/pgoutput/pgoutput.c:2344">send_repl_origin</a>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RepOriginId origin_id, XLogRecPtr origin_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> send_origin);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Only 3 publication actions are used for row filtering (&quot;insert&quot;, &quot;update&quot;,<br/></li>
<li></span><span class="Comment"> * &quot;delete&quot;). See <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a>.exprstate[].<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="Type">enum</span> <span class="linkable">RowFilterPubAction</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PUBACTION_INSERT,<br/></li>
<li>&nbsp; &nbsp; PUBACTION_UPDATE,<br/></li>
<li>&nbsp; &nbsp; PUBACTION_DELETE,<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L105">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_ROWFILTER_PUBACTIONS</span> (PUBACTION_DELETE+</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entry in the map used to remember which relation schemas we sent.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The schema_sent flag determines if the current schema record for the<br/></li>
<li></span><span class="Comment"> * relation (and for its ancestor if publish_as_relid is set) was already<br/></li>
<li></span><span class="Comment"> * sent to the subscriber (in which case we don't need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it again).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The schema cache on downstream is however updated only at commit time,<br/></li>
<li></span><span class="Comment"> * and with streamed transactions the commit order may be different from<br/></li>
<li></span><span class="Comment"> * the order the transactions are sent in. Also, the (sub) transactions<br/></li>
<li></span><span class="Comment"> * might get aborted so we need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the schema for each (sub) transaction<br/></li>
<li></span><span class="Comment"> * so that we don't lose the schema information on abort. For handling this,<br/></li>
<li></span><span class="Comment"> * we maintain the list of xids (streamed_txns) for those we have already sent<br/></li>
<li></span><span class="Comment"> * the schema.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For partitions, 'pubactions' considers not only the table's own<br/></li>
<li></span><span class="Comment"> * publications, but also those of all of its ancestors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RelationSyncEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relation oid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replicate_valid;&nbsp; &nbsp; <span class="Comment">/* overall validity flag for entry */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; schema_sent;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *streamed_txns;&nbsp; &nbsp; <span class="Comment">/* streamed toplevel transactions with this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * schema */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* are we publishing this rel? */<br/></li>
<li></span>&nbsp; &nbsp; PublicationActions pubactions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ExprState array for row filter. Different publication actions don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allow multiple expressions to always be combined into one, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updates or deletes restrict the column in expression to be part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replica identity index whereas inserts do not have this restriction, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is one ExprState per publication action.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ExprState&nbsp; *exprstate[<a href="#L105" title="replication/pgoutput/pgoutput.c:105">NUM_ROWFILTER_PUBACTIONS</a>];<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* executor state used for row filter */<br/></li>
<li></span>&nbsp; &nbsp; TupleTableSlot *new_slot;&nbsp; &nbsp; <span class="Comment">/* slot for storing new tuple */<br/></li>
<li></span>&nbsp; &nbsp; TupleTableSlot *old_slot;&nbsp; &nbsp; <span class="Comment">/* slot for storing old tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OID of the relation to publish changes as.&nbsp; For a partition, this may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be set to one of its ancestors whose schema will be used when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replicating changes, if publish_via_partition_root is set for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * publication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publish_as_relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Map used when replicating using an ancestor's schema to convert tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from partition's type to the ancestor's; NULL if publish_as_relid is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same as 'relid' or if unnecessary due to partition and the ancestor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having identical TupleDesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attrmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Columns included in the publication, or NULL if all columns are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * included implicitly.&nbsp; Note that the attnums in this bitmap are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shifted by FirstLowInvalidHeapAttributeNumber.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Bitmapset&nbsp; *columns;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Private context to store additional data for this entry - state for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row filter expressions, column list, etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext entry_cxt;<br/></li>
<li><a id="L178">&#x200c;</a>} <span class="linkable">RelationSyncEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maintain a per-transaction level variable to track whether the transaction<br/></li>
<li></span><span class="Comment"> * has sent BEGIN. BEGIN is only sent when the first change in a transaction<br/></li>
<li></span><span class="Comment"> * is processed. This makes it possible to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> sending a pair of BEGIN/COMMIT<br/></li>
<li></span><span class="Comment"> * messages for empty transactions which saves network bandwidth.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This optimization is not used for prepared transactions because if the<br/></li>
<li></span><span class="Comment"> * WALSender restarts after prepare of a transaction and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit prepared<br/></li>
<li></span><span class="Comment"> * of the same transaction then we won't be able to figure out if we have<br/></li>
<li></span><span class="Comment"> * skipped sending BEGIN/PREPARE of a transaction as it was empty. This is<br/></li>
<li></span><span class="Comment"> * because we would have lost the in-memory txndata information that was<br/></li>
<li></span><span class="Comment"> * present prior to the restart. This will result in sending a spurious<br/></li>
<li></span><span class="Comment"> * COMMIT PREPARED without a corresponding prepared transaction at the<br/></li>
<li></span><span class="Comment"> * downstream which would lead to an error when it tries to process it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We could achieve this optimization by changing protocol to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment"> * additional information so that downstream can detect that the corresponding<br/></li>
<li></span><span class="Comment"> * prepare has not been sent. However, adding such a check for every<br/></li>
<li></span><span class="Comment"> * transaction in the downstream could be costly so we might want to do it<br/></li>
<li></span><span class="Comment"> * optionally.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also don't have this optimization for streamed transactions because<br/></li>
<li></span><span class="Comment"> * they can contain prepared transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L204">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PGOutputTxnData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sent_begin_txn; <span class="Comment">/* flag indicating whether BEGIN has been sent */<br/></li>
<li><a id="L207">&#x200c;</a></span>} <span class="linkable">PGOutputTxnData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Map used to remember which relation schemas we sent. */<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">RelationSyncCache</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1878" title="replication/pgoutput/pgoutput.c:1878">init_rel_sync_cache</a>(MemoryContext cachectx);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2232" title="replication/pgoutput/pgoutput.c:2232">cleanup_rel_sync_cache</a>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_commit);<br/></li>
<li><span class="Type">static</span> <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *<a href="#L1963" title="replication/pgoutput/pgoutput.c:1963">get_rel_sync_entry</a>(PGOutputData *data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation relation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2267" title="replication/pgoutput/pgoutput.c:2267">rel_sync_cache_relation_cb</a>(Datum arg, Oid relid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2318" title="replication/pgoutput/pgoutput.c:2318">rel_sync_cache_publication_cb</a>(Datum arg, <span class="Type">int</span> cacheid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 hashvalue);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1942" title="replication/pgoutput/pgoutput.c:1942">set_schema_sent_in_streamed_txn</a>(<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1932" title="replication/pgoutput/pgoutput.c:1932">get_schema_sent_in_streamed_txn</a>(<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1130" title="replication/pgoutput/pgoutput.c:1130">init_tuple_slot</a>(PGOutputData *data, Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry);<br/></li>
<li><br/></li>
<li><span class="Comment">/* row filter routines */<br/></li>
<li></span><span class="Type">static</span> EState *<a href="#L794" title="replication/pgoutput/pgoutput.c:794">create_estate_for_relation</a>(Relation rel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L869" title="replication/pgoutput/pgoutput.c:869">pgoutput_row_filter_init</a>(PGOutputData *data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *publications,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L824" title="replication/pgoutput/pgoutput.c:824">pgoutput_row_filter_exec_expr</a>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1222" title="replication/pgoutput/pgoutput.c:1222">pgoutput_row_filter</a>(Relation relation, TupleTableSlot *old_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot **new_slot_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChangeType *action);<br/></li>
<li><br/></li>
<li><span class="Comment">/* column list routines */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1015" title="replication/pgoutput/pgoutput.c:1015">pgoutput_column_list_init</a>(PGOutputData *data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *publications,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Specify output plugin callbacks<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L247">&#x200c;</a></span><span class="linkable">_PG_output_plugin_init</span>(OutputPluginCallbacks *cb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; cb-&gt;startup_cb = <a href="#L418" title="replication/pgoutput/pgoutput.c:418">pgoutput_startup</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;begin_cb = <a href="#L548" title="replication/pgoutput/pgoutput.c:548">pgoutput_begin_txn</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;change_cb = <a href="#L1403" title="replication/pgoutput/pgoutput.c:1403">pgoutput_change</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;truncate_cb = <a href="#L1562" title="replication/pgoutput/pgoutput.c:1562">pgoutput_truncate</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;message_cb = <a href="#L1630" title="replication/pgoutput/pgoutput.c:1630">pgoutput_message</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;commit_cb = <a href="#L584" title="replication/pgoutput/pgoutput.c:584">pgoutput_commit_txn</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cb-&gt;begin_prepare_cb = <a href="#L616" title="replication/pgoutput/pgoutput.c:616">pgoutput_begin_prepare_txn</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;prepare_cb = <a href="#L633" title="replication/pgoutput/pgoutput.c:633">pgoutput_prepare_txn</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;commit_prepared_cb = <a href="#L647" title="replication/pgoutput/pgoutput.c:647">pgoutput_commit_prepared_txn</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;rollback_prepared_cb = <a href="#L661" title="replication/pgoutput/pgoutput.c:661">pgoutput_rollback_prepared_txn</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;filter_by_origin_cb = <a href="#L1675" title="replication/pgoutput/pgoutput.c:1675">pgoutput_origin_filter</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;shutdown_cb = <a href="#L1694" title="replication/pgoutput/pgoutput.c:1694">pgoutput_shutdown</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction streaming */<br/></li>
<li></span>&nbsp; &nbsp; cb-&gt;stream_start_cb = <a href="#L1744" title="replication/pgoutput/pgoutput.c:1744">pgoutput_stream_start</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;stream_stop_cb = <a href="#L1776" title="replication/pgoutput/pgoutput.c:1776">pgoutput_stream_stop</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;stream_abort_cb = <a href="#L1797" title="replication/pgoutput/pgoutput.c:1797">pgoutput_stream_abort</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;stream_commit_cb = <a href="#L1830" title="replication/pgoutput/pgoutput.c:1830">pgoutput_stream_commit</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;stream_change_cb = <a href="#L1403" title="replication/pgoutput/pgoutput.c:1403">pgoutput_change</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;stream_message_cb = <a href="#L1630" title="replication/pgoutput/pgoutput.c:1630">pgoutput_message</a>;<br/></li>
<li>&nbsp; &nbsp; cb-&gt;stream_truncate_cb = <a href="#L1562" title="replication/pgoutput/pgoutput.c:1562">pgoutput_truncate</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction streaming - two-phase commit */<br/></li>
<li></span>&nbsp; &nbsp; cb-&gt;stream_prepare_cb = <a href="#L1858" title="replication/pgoutput/pgoutput.c:1858">pgoutput_stream_prepare_txn</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L276">&#x200c;</a></span><span class="linkable">parse_output_parameters</span>(List *options, PGOutputData *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; protocol_version_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; publication_names_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; binary_option_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; messages_option_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; streaming_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; two_phase_option_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; origin_option_given = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data-&gt;binary = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; data-&gt;streaming = LOGICALREP_STREAM_OFF;<br/></li>
<li>&nbsp; &nbsp; data-&gt;messages = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; data-&gt;two_phase = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, options)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *defel = (DefElem *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(defel-&gt;arg == <span class="Constant">NULL</span> || IsA(defel-&gt;arg, String));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check each param, whether or not we recognize it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;proto_version&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">long</span> parsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (protocol_version_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; protocol_version_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsed = strtoul(strVal(defel-&gt;arg), &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span> || *endptr != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid proto_version&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsed &gt; PG_UINT32_MAX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;proto_version </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strVal(defel-&gt;arg))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;protocol_version = (uint32) parsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;publication_names&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (publication_names_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publication_names_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/adt/varlena.c.html#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>(strVal(defel-&gt;arg), <span class="Constant">','</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;data-&gt;publication_names))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid publication_names syntax&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;binary&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (binary_option_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binary_option_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;binary = <a href="../../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;messages&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (messages_option_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; messages_option_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;messages = <a href="../../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;streaming&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (streaming_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; streaming_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;streaming = <a href="../../commands/subscriptioncmds.c.html#L2386" title="commands/subscriptioncmds.c:2386">defGetStreamingMode</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;two_phase&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (two_phase_option_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; two_phase_option_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;two_phase = <a href="../../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;origin&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *origin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (origin_option_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting or redundant options&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origin_option_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origin = <a href="../../commands/define.c.html#L48" title="commands/define.c:48">defGetString</a>(defel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(origin, LOGICALREP_ORIGIN_NONE) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;publish_no_origin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_strcasecmp(origin, LOGICALREP_ORIGIN_ANY) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;publish_no_origin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unrecognized origin value: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, origin));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized pgoutput option: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, defel-&gt;defname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check required options */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!protocol_version_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;proto_version option missing&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!publication_names_given)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;publication_names option missing&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize this plugin<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L418">&#x200c;</a></span><span class="linkable">pgoutput_startup</span>(LogicalDecodingContext *ctx, OutputPluginOptions *opt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_init)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGOutputData));<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> publication_callback_registered = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create our memory context for private allocations. */<br/></li>
<li></span>&nbsp; &nbsp; data-&gt;context = AllocSetContextCreate(ctx-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;logical replication output context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data-&gt;cachectx = AllocSetContextCreate(ctx-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;logical replication cache context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctx-&gt;output_plugin_private = data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This plugin uses binary protocol. */<br/></li>
<li></span>&nbsp; &nbsp; opt-&gt;output_type = OUTPUT_PLUGIN_BINARY_OUTPUT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is replication start and not slot initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse and validate options passed by the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_init)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse the params and ERROR if we see <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> we don't recognize */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L276" title="replication/pgoutput/pgoutput.c:276">parse_output_parameters</a>(ctx-&gt;output_plugin_options, data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we support requested protocol */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;protocol_version &gt; LOGICALREP_PROTO_MAX_VERSION_NUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;client sent proto_version=</span><span class="Special">%d</span><span class="Constant"> but server only supports protocol </span><span class="Special">%d</span><span class="Constant"> or <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;protocol_version, LOGICALREP_PROTO_MAX_VERSION_NUM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;protocol_version &lt; LOGICALREP_PROTO_MIN_VERSION_NUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;client sent proto_version=</span><span class="Special">%d</span><span class="Constant"> but server only supports protocol </span><span class="Special">%d</span><span class="Constant"> or higher&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;protocol_version, LOGICALREP_PROTO_MIN_VERSION_NUM)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decide whether to enable streaming. It is disabled by default, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case we just update the flag in decoding context. Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we only allow it with sufficient version of the protocol, and when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the output plugin supports it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;streaming == LOGICALREP_STREAM_OFF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;streaming = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (data-&gt;streaming == LOGICALREP_STREAM_ON &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data-&gt;protocol_version &lt; LOGICALREP_PROTO_STREAM_VERSION_NUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested proto_version=</span><span class="Special">%d</span><span class="Constant"> does not support streaming, need </span><span class="Special">%d</span><span class="Constant"> or higher&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;protocol_version, LOGICALREP_PROTO_STREAM_VERSION_NUM)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (data-&gt;streaming == LOGICALREP_STREAM_PARALLEL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data-&gt;protocol_version &lt; LOGICALREP_PROTO_STREAM_PARALLEL_VERSION_NUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested proto_version=</span><span class="Special">%d</span><span class="Constant"> does not support parallel streaming, need </span><span class="Special">%d</span><span class="Constant"> or higher&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;protocol_version, LOGICALREP_PROTO_STREAM_PARALLEL_VERSION_NUM)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!ctx-&gt;streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;streaming requested, but not supported by output plugin&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we just check whether the two-phase option is passed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plugin and decide whether to enable it at later point of time. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remains enabled if the previous start-up has done so. But we only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow the option to be passed in with sufficient version of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * protocol, and when the output plugin supports it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!data-&gt;two_phase)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;twophase_opt_given = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (data-&gt;protocol_version &lt; LOGICALREP_PROTO_TWOPHASE_VERSION_NUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested proto_version=</span><span class="Special">%d</span><span class="Constant"> does not support two-phase commit, need </span><span class="Special">%d</span><span class="Constant"> or higher&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;protocol_version, LOGICALREP_PROTO_TWOPHASE_VERSION_NUM)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!ctx-&gt;twophase)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;two-phase commit requested, but not supported by output plugin&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;twophase_opt_given = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Init publication state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;publications = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="replication/pgoutput/pgoutput.c:82">publications_valid</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Register callback for pg_publication if we didn't already do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during some previous call in this process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!publication_callback_registered)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(PUBLICATIONOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1729" title="replication/pgoutput/pgoutput.c:1729">publication_invalidation_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publication_callback_registered = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize relation schema cache. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1878" title="replication/pgoutput/pgoutput.c:1878">init_rel_sync_cache</a>(<a href="../../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disable the streaming and prepared transactions during the slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initialization mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;streaming = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;twophase = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BEGIN callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the BEGIN message here instead postpone it until the first<br/></li>
<li></span><span class="Comment"> * change. In logical replication, a common scenario is to replicate a set of<br/></li>
<li></span><span class="Comment"> * tables (instead of all tables) and transactions whose changes were on<br/></li>
<li></span><span class="Comment"> * the table(s) that are not published will produce empty transactions. These<br/></li>
<li></span><span class="Comment"> * empty transactions will <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> BEGIN and COMMIT messages to subscribers,<br/></li>
<li></span><span class="Comment"> * using bandwidth on something with little/no use for logical replication.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L548">&#x200c;</a></span><span class="linkable">pgoutput_begin_txn</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *txndata = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(ctx-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; txn-&gt;output_plugin_private = txndata;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send BEGIN.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called while processing the first change of the transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L562">&#x200c;</a></span><span class="linkable">pgoutput_send_begin</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; send_replication_origin = txn-&gt;origin_id != InvalidRepOriginId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *txndata = (<a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *) txn-&gt;output_plugin_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(txndata);<br/></li>
<li>&nbsp; &nbsp; Assert(!txndata-&gt;sent_begin_txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, !send_replication_origin);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L60" title="replication/logical/proto.c:60">logicalrep_write_begin</a>(ctx-&gt;out, txn);<br/></li>
<li>&nbsp; &nbsp; txndata-&gt;sent_begin_txn = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2344" title="replication/pgoutput/pgoutput.c:2344">send_repl_origin</a>(ctx, txn-&gt;origin_id, txn-&gt;origin_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; send_replication_origin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * COMMIT callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L584">&#x200c;</a></span><span class="linkable">pgoutput_commit_txn</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *txndata = (<a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *) txn-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sent_begin_txn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(txndata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the commit message unless some relevant change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from this transaction has been sent to the downstream.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sent_begin_txn = txndata-&gt;sent_begin_txn;<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L734" title="replication/logical/logical.c:734">OutputPluginUpdateProgress</a>(ctx, !sent_begin_txn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(txndata);<br/></li>
<li>&nbsp; &nbsp; txn-&gt;output_plugin_private = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!sent_begin_txn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;skipped replication of an empty transaction with XID: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, txn-&gt;xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L89" title="replication/logical/proto.c:89">logicalrep_write_commit</a>(ctx-&gt;out, txn, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BEGIN PREPARE callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L616">&#x200c;</a></span><span class="linkable">pgoutput_begin_prepare_txn</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; send_replication_origin = txn-&gt;origin_id != InvalidRepOriginId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, !send_replication_origin);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L127" title="replication/logical/proto.c:127">logicalrep_write_begin_prepare</a>(ctx-&gt;out, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2344" title="replication/pgoutput/pgoutput.c:2344">send_repl_origin</a>(ctx, txn-&gt;origin_id, txn-&gt;origin_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; send_replication_origin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * PREPARE callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L633">&#x200c;</a></span><span class="linkable">pgoutput_prepare_txn</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L734" title="replication/logical/logical.c:734">OutputPluginUpdateProgress</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L198" title="replication/logical/proto.c:198">logicalrep_write_prepare</a>(ctx-&gt;out, txn, prepare_lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * COMMIT PREPARED callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L647">&#x200c;</a></span><span class="linkable">pgoutput_commit_prepared_txn</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L734" title="replication/logical/logical.c:734">OutputPluginUpdateProgress</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L248" title="replication/logical/proto.c:248">logicalrep_write_commit_prepared</a>(ctx-&gt;out, txn, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * ROLLBACK PREPARED callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L661">&#x200c;</a></span><span class="linkable">pgoutput_rollback_prepared_txn</span>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimestampTz prepare_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L734" title="replication/logical/logical.c:734">OutputPluginUpdateProgress</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L304" title="replication/logical/proto.c:304">logicalrep_write_rollback_prepared</a>(ctx-&gt;out, txn, prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prepare_time);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the current schema of the relation and its ancestor (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) if not<br/></li>
<li></span><span class="Comment"> * done yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L679">&#x200c;</a></span><span class="linkable">maybe_send_schema</span>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChange *change,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *relentry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; schema_sent;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; TransactionId topxid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember XID of the (sub)transaction for the change. We don't care if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's top-level transaction or not (we have already sent that XID in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start of the current streaming block).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not in a streaming block, just use InvalidTransactionId and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the write methods will not include it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;in_streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = change-&gt;txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_subtxn(change-&gt;txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; topxid = rbtxn_get_toptxn(change-&gt;txn)-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; topxid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do we need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the schema? We do track streamed transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separately, because those may be applied later (and the regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions won't see their effects until then) and in an order that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't know at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> There is a scope of optimization here. Currently, we always <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the schema first time in a streaming transaction but we can probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid that by checking 'relentry-&gt;schema_sent' flag. However, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing that we need to study its impact on the case where we have a mix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of streaming and non-streaming transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;in_streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; schema_sent = <a href="#L1932" title="replication/pgoutput/pgoutput.c:1932">get_schema_sent_in_streamed_txn</a>(relentry, topxid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; schema_sent = relentry-&gt;schema_sent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if we already sent the schema. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (schema_sent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send the schema.&nbsp; If the changes will be published using an ancestor's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * schema, not the relation's own, <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> that ancestor's schema <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sending relation's own (</span><span class="Todo">XXX</span><span class="Comment"> - maybe sending only the former suffices?).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relentry-&gt;publish_as_relid != RelationGetRelid(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; ancestor = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(relentry-&gt;publish_as_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L750" title="replication/pgoutput/pgoutput.c:750">send_relation_and_attrs</a>(ancestor, xid, ctx, relentry-&gt;columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(ancestor);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L750" title="replication/pgoutput/pgoutput.c:750">send_relation_and_attrs</a>(relation, xid, ctx, relentry-&gt;columns);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;in_streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1942" title="replication/pgoutput/pgoutput.c:1942">set_schema_sent_in_streamed_txn</a>(relentry, topxid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relentry-&gt;schema_sent = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sends a relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L750">&#x200c;</a></span><span class="linkable">send_relation_and_attrs</span>(Relation relation, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *columns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc = RelationGetDescr(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write out type info if needed.&nbsp; We do that only for user-created types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use FirstGenbkiObjectId as the cutoff, so that we only consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * objects with hand-assigned OIDs to be &quot;built in&quot;, not for instance <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function or type defined in the information_schema. This is important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because only hand-assigned OIDs can be expected to remain stable across<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * major versions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped || att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;atttypid &lt; FirstGenbkiObjectId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip this attribute if it's not present in the column list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (columns != <span class="Constant">NULL</span> &amp;&amp; !<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(att-&gt;attnum, columns))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/proto.c.html#L725" title="replication/logical/proto.c:725">logicalrep_write_typ</a>(ctx-&gt;out, xid, att-&gt;atttypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L670" title="replication/logical/proto.c:670">logicalrep_write_rel</a>(ctx-&gt;out, xid, relation, columns);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Executor state preparation for evaluation of row filter expressions for the<br/></li>
<li></span><span class="Comment"> * specified relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> EState *<br/></li>
<li><a id="L794">&#x200c;</a><span class="linkable">create_estate_for_relation</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *perminfos = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate = <a href="../../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rtekind = RTE_RELATION;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; rte-&gt;relkind = rel-&gt;rd_rel-&gt;relkind;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;rellockmode = AccessShareLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>(&amp;perminfos, rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execUtils.c.html#L728" title="executor/execUtils.c:728">ExecInitRangeTable</a>(estate, list_make1(rte), perminfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; estate-&gt;es_output_cid = <a href="../../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> estate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluates row filter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the row filter evaluates to NULL, it is taken as false i.e. the change<br/></li>
<li></span><span class="Comment"> * isn't replicated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L824">&#x200c;</a></span><span class="linkable">pgoutput_row_filter_exec_expr</span>(ExprState *state, ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ret = ExecEvalExprSwitchContext(state, econtext, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;row filter evaluates to </span><span class="Special">%s</span><span class="Constant"> (isnull: </span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnull ? <span class="Constant">&quot;false&quot;</span> : DatumGetBool(ret) ? <span class="Constant">&quot;true&quot;</span> : <span class="Constant">&quot;false&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnull ? <span class="Constant">&quot;true&quot;</span> : <span class="Constant">&quot;false&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetBool(ret);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure the per-entry memory context exists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L847">&#x200c;</a></span><span class="linkable">pgoutput_ensure_entry_cxt</span>(PGOutputData *data, <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The context may already exist, in which case bail out. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;entry_cxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(entry-&gt;publish_as_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;entry_cxt = AllocSetContextCreate(data-&gt;cachectx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;entry private context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextCopyAndSetIdentifier(entry-&gt;entry_cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the row filter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L869">&#x200c;</a></span><span class="linkable">pgoutput_row_filter_init</span>(PGOutputData *data, List *publications,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rfnodes[] = {NIL, NIL, NIL};&nbsp; &nbsp; <span class="Comment">/* One per pubaction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; no_filter[] = {<span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>};&nbsp; &nbsp; <span class="Comment">/* One per pubaction */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_filter = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schemaid = <a href="../../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(entry-&gt;publish_as_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row filters for this relation. If there are, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepare the necessary ExprState and cache it in entry-&gt;exprstate. To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build an expression state, we need to ensure the following:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All the given publication-table mappings must be checked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Multiple publications might have multiple row filters for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation. Since row filter usage depends on the DML operation, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are multiple lists (one for each operation) to which row filters will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be appended.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FOR ALL TABLES and FOR TABLES IN SCHEMA implies &quot;don't use row filter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expression&quot; so it takes precedence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, publications)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Publication *pub = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; rftuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; rfdatum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pub_no_filter = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the publication is FOR ALL TABLES, or the publication includes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FOR TABLES IN SCHEMA where the table belongs to the referred<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * schema, then it is treated the same as if there are no row filters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (even if other publications have a row filter).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pub-&gt;alltables &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !SearchSysCacheExists2(PUBLICATIONNAMESPACEMAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(schemaid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(pub-&gt;oid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for the presence of a row filter in this publication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rftuple = <a href="../../utils/cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(PUBLICATIONRELMAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(entry-&gt;publish_as_relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(pub-&gt;oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(rftuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Null indicates no filter. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rfdatum = <a href="../../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(PUBLICATIONRELMAP, rftuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_publication_rel_prqual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pub_no_filter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pub_no_filter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rftuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(rftuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no_filter[PUBACTION_INSERT] |= pub-&gt;pubactions.pubinsert;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no_filter[PUBACTION_UPDATE] |= pub-&gt;pubactions.pubupdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no_filter[PUBACTION_DELETE] |= pub-&gt;pubactions.pubdelete;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Quick exit if all the DML actions are publicized via this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * publication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (no_filter[PUBACTION_INSERT] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no_filter[PUBACTION_UPDATE] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no_filter[PUBACTION_DELETE])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_filter = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No additional work for this publication. Next one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form the per pubaction row filter lists. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pub-&gt;pubactions.pubinsert &amp;&amp; !no_filter[PUBACTION_INSERT])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rfnodes[PUBACTION_INSERT] = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rfnodes[PUBACTION_INSERT],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TextDatumGetCString(rfdatum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pub-&gt;pubactions.pubupdate &amp;&amp; !no_filter[PUBACTION_UPDATE])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rfnodes[PUBACTION_UPDATE] = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rfnodes[PUBACTION_UPDATE],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TextDatumGetCString(rfdatum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pub-&gt;pubactions.pubdelete &amp;&amp; !no_filter[PUBACTION_DELETE])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rfnodes[PUBACTION_DELETE] = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rfnodes[PUBACTION_DELETE],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TextDatumGetCString(rfdatum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(rftuple);<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop all subscribed publications */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean the row filter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (idx = <span class="Constant">0</span>; idx &lt; <a href="#L105" title="replication/pgoutput/pgoutput.c:105">NUM_ROWFILTER_PUBACTIONS</a>; idx++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (no_filter[idx])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(rfnodes[idx]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rfnodes[idx] = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (has_filter)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; relation = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(entry-&gt;publish_as_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L847" title="replication/pgoutput/pgoutput.c:847">pgoutput_ensure_entry_cxt</a>(data, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now all the filters for all pubactions are known. Combine them when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their pubactions are the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(entry-&gt;entry_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;estate = <a href="#L794" title="replication/pgoutput/pgoutput.c:794">create_estate_for_relation</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (idx = <span class="Constant">0</span>; idx &lt; <a href="#L105" title="replication/pgoutput/pgoutput.c:105">NUM_ROWFILTER_PUBACTIONS</a>; idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *filters = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *rfnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rfnodes[idx] == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, rfnodes[idx])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filters = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(filters, <a href="../../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>((<span class="Type">char</span> *) lfirst(lc)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the row filter and cache the ExprState */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rfnode = <a href="../../nodes/makefuncs.c.html#L670" title="nodes/makefuncs.c:670">make_orclause</a>(filters);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;exprstate[idx] = <a href="../../executor/execExpr.c.html#L739" title="executor/execExpr.c:739">ExecPrepareExpr</a>(rfnode, entry-&gt;estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for each pubaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(relation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the column list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1015">&#x200c;</a></span><span class="linkable">pgoutput_column_list_init</span>(PGOutputData *data, List *publications,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(entry-&gt;publish_as_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> column lists for this relation. If there are,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build a bitmap using the column lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Multiple publications might have multiple column lists for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't support the case where the column list is different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the same table when combining publications. See comments atop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../commands/subscriptioncmds.c.html#L2135" title="commands/subscriptioncmds.c:2135">fetch_table_list</a>. But one can later change the publication so we still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to check all the given publication-table mappings and report an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> publications have a different column list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FOR ALL TABLES and FOR TABLES IN SCHEMA imply &quot;don't use column list&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, publications)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Publication *pub = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; cftuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; cfdatum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *cols = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the publication is FOR ALL TABLES then it is treated the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there are no column lists (even if other publications have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pub-&gt;alltables)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pub_no_list = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for the presence of a column list in this publication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> no pg_publication_rel row, it's a publication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defined for a whole schema, so it can't have a column list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just like a FOR ALL TABLES publication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cftuple = <a href="../../utils/cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(PUBLICATIONRELMAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(entry-&gt;publish_as_relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(pub-&gt;oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(cftuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Lookup the column list attribute. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cfdatum = <a href="../../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(PUBLICATIONRELMAP, cftuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_publication_rel_prattrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pub_no_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build the column list bitmap in the per-entry context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pub_no_list)&nbsp; &nbsp; <span class="Comment">/* when not null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nliveatts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc = RelationGetDescr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L847" title="replication/pgoutput/pgoutput.c:847">pgoutput_ensure_entry_cxt</a>(data, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols = <a href="../../catalog/pg_publication.c.html#L570" title="catalog/pg_publication.c:570">pub_collist_to_bitmapset</a>(cols, cfdatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;entry_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the number of live attributes. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped || att-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nliveatts++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If column list includes all the columns of the table,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set it to NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L751" title="nodes/bitmapset.c:751">bms_num_members</a>(cols) == nliveatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(cftuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;columns = cols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L142" title="nodes/bitmapset.c:142">bms_equal</a>(entry-&gt;columns, cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use different column lists for table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> in different publications&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation)));<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop all subscribed publications */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the slot for storing new and old tuples, and build the map that<br/></li>
<li></span><span class="Comment"> * will be used to convert the relation's tuples into the ancestor's format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1130">&#x200c;</a></span><span class="linkable">init_tuple_slot</span>(PGOutputData *data, Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; oldtupdesc;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; newtupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(data-&gt;cachectx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create tuple table slots. Create a copy of the TupleDesc as it needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * live as long as the cache remains.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldtupdesc = <a href="../../access/common/tupdesc.c.html#L173" title="access/common/tupdesc.c:173">CreateTupleDescCopyConstr</a>(RelationGetDescr(relation));<br/></li>
<li>&nbsp; &nbsp; newtupdesc = <a href="../../access/common/tupdesc.c.html#L173" title="access/common/tupdesc.c:173">CreateTupleDescCopyConstr</a>(RelationGetDescr(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;old_slot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(oldtupdesc, &amp;<a href="../../executor/execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a>);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;new_slot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(newtupdesc, &amp;<a href="../../executor/execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cache the map that will be used to convert the relation's tuples into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ancestor's format, if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;publish_as_relid != RelationGetRelid(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; ancestor = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(entry-&gt;publish_as_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; indesc = RelationGetDescr(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; outdesc = RelationGetDescr(ancestor);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Map must live as long as the session does. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <a href="../../access/common/attmap.c.html#L263" title="access/common/attmap.c:263">build_attrmap_by_name_if_req</a>(indesc, outdesc, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(ancestor);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Change is checked against the row filter if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the change is to be replicated, else false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For inserts, evaluate the row filter for new tuple.<br/></li>
<li></span><span class="Comment"> * For deletes, evaluate the row filter for old tuple.<br/></li>
<li></span><span class="Comment"> * For updates, evaluate the row filter for old and new tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For updates, if both evaluations are true, we allow sending the UPDATE and<br/></li>
<li></span><span class="Comment"> * if both the evaluations are false, it doesn't replicate the UPDATE. Now, if<br/></li>
<li></span><span class="Comment"> * only one of the tuples matches the row filter expression, we transform<br/></li>
<li></span><span class="Comment"> * UPDATE to DELETE or INSERT to avoid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data inconsistency based on the<br/></li>
<li></span><span class="Comment"> * following rules:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Case 1: old-row (no match)&nbsp; &nbsp; new-row (no match)&nbsp; -&gt; (drop change)<br/></li>
<li></span><span class="Comment"> * Case 2: old-row (no match)&nbsp; &nbsp; new row (match)&nbsp; &nbsp;&nbsp; -&gt; INSERT<br/></li>
<li></span><span class="Comment"> * Case 3: old-row (match)&nbsp; &nbsp; &nbsp;&nbsp; new-row (no match)&nbsp; -&gt; DELETE<br/></li>
<li></span><span class="Comment"> * Case 4: old-row (match)&nbsp; &nbsp; &nbsp;&nbsp; new row (match)&nbsp; &nbsp;&nbsp; -&gt; UPDATE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new action is updated in the action parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new slot could be updated when transforming the UPDATE into INSERT,<br/></li>
<li></span><span class="Comment"> * because the original new tuple might not have column <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the replica<br/></li>
<li></span><span class="Comment"> * identity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Examples:<br/></li>
<li></span><span class="Comment"> * Let's say the old tuple satisfies the row filter but the new tuple doesn't.<br/></li>
<li></span><span class="Comment"> * Since the old tuple satisfies, the initial table synchronization copied this<br/></li>
<li></span><span class="Comment"> * row (or another method was used to guarantee that there is data<br/></li>
<li></span><span class="Comment"> * consistency).&nbsp; However, after the UPDATE the new tuple doesn't satisfy the<br/></li>
<li></span><span class="Comment"> * row filter, so from a data consistency perspective, that row should be<br/></li>
<li></span><span class="Comment"> * removed on the subscriber. The UPDATE should be transformed into a DELETE<br/></li>
<li></span><span class="Comment"> * statement and be sent to the subscriber. Keeping this row on the subscriber<br/></li>
<li></span><span class="Comment"> * is undesirable because it doesn't reflect what was defined in the row filter<br/></li>
<li></span><span class="Comment"> * expression on the publisher. This row on the subscriber would likely not be<br/></li>
<li></span><span class="Comment"> * modified by replication again. If someone inserted a new row with the same<br/></li>
<li></span><span class="Comment"> * old identifier, replication could stop due to a constraint violation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Let's say the old tuple doesn't match the row filter but the new tuple does.<br/></li>
<li></span><span class="Comment"> * Since the old tuple doesn't satisfy, the initial table synchronization<br/></li>
<li></span><span class="Comment"> * probably didn't copy this row. However, after the UPDATE the new tuple does<br/></li>
<li></span><span class="Comment"> * satisfy the row filter, so from a data consistency perspective, that row<br/></li>
<li></span><span class="Comment"> * should be inserted on the subscriber. Otherwise, subsequent UPDATE or DELETE<br/></li>
<li></span><span class="Comment"> * statements have no effect (it matches no row -- see<br/></li>
<li></span><span class="Comment"> * <a href="../logical/worker.c.html#L2637" title="replication/logical/worker.c:2637">apply_handle_update_internal</a>()). So, the UPDATE should be transformed into a<br/></li>
<li></span><span class="Comment"> * INSERT statement and be sent to the subscriber. However, this might surprise<br/></li>
<li></span><span class="Comment"> * someone who expects the data set to satisfy the row filter expression on the<br/></li>
<li></span><span class="Comment"> * <a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1222">&#x200c;</a></span><span class="linkable">pgoutput_row_filter</span>(Relation relation, TupleTableSlot *old_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot **new_slot_ptr, <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferChangeType *action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_matched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_matched,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *tmp_new_slot;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *new_slot = *new_slot_ptr;<br/></li>
<li>&nbsp; &nbsp; ExprContext *ecxt;<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *filter_exprstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need this map to avoid relying on ReorderBufferChangeType enums<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having specific <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> map_changetype_pubaction[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; [REORDER_BUFFER_CHANGE_INSERT] = PUBACTION_INSERT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; [REORDER_BUFFER_CHANGE_UPDATE] = PUBACTION_UPDATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; [REORDER_BUFFER_CHANGE_DELETE] = PUBACTION_DELETE<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(*action == REORDER_BUFFER_CHANGE_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *action == REORDER_BUFFER_CHANGE_UPDATE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *action == REORDER_BUFFER_CHANGE_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(new_slot || old_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the corresponding row filter */<br/></li>
<li></span>&nbsp; &nbsp; filter_exprstate = entry-&gt;exprstate[map_changetype_pubaction[*action]];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bail out if there is no row filter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!filter_exprstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> has row filter&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ResetPerTupleExprContext(entry-&gt;estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ecxt = GetPerTupleExprContext(entry-&gt;estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the following occasions where there is only one tuple, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * evaluate the row filter for that tuple and return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For inserts, we only have the new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For updates, we can have only a new tuple when <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the replica<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identity columns changed and <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of those columns have external data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we still need to evaluate the row filter for the new tuple as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of those columns might not match the filter. Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * users can use constant expressions in the row filter, so we anyway need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to evaluate it for the new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For deletes, we only have the old tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!new_slot || !old_slot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ecxt-&gt;ecxt_scantuple = new_slot ? new_slot : old_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L824" title="replication/pgoutput/pgoutput.c:824">pgoutput_row_filter_exec_expr</a>(filter_exprstate, ecxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both the old and new tuples must be valid only for updates and need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be checked against the row filter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(map_changetype_pubaction[*action] == PUBACTION_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot_getallattrs(new_slot);<br/></li>
<li>&nbsp; &nbsp; slot_getallattrs(old_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmp_new_slot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; desc = RelationGetDescr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The new tuple might not have all the replica identity columns, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case it needs to be copied over from the old tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(desc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the column in the new tuple or old tuple is null, nothing to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_slot-&gt;tts_isnull[i] || old_slot-&gt;tts_isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unchanged toasted replica identity columns are only logged in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old tuple. Copy this over to the new tuple. The changed (or WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Logged) toast <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are always assembled in memory and set as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * VARTAG_INDIRECT. See <a href="../logical/reorderbuffer.c.html#L4762" title="replication/logical/reorderbuffer.c:4762">ReorderBufferToastReplace</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL_ONDISK(new_slot-&gt;tts_values[i]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !VARATT_IS_EXTERNAL_ONDISK(old_slot-&gt;tts_values[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tmp_new_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_new_slot = <a href="../../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(desc, &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(tmp_new_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(tmp_new_slot-&gt;tts_values, new_slot-&gt;tts_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; desc-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(tmp_new_slot-&gt;tts_isnull, new_slot-&gt;tts_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; desc-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_new_slot-&gt;tts_values[i] = old_slot-&gt;tts_values[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_new_slot-&gt;tts_isnull[i] = old_slot-&gt;tts_isnull[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ecxt-&gt;ecxt_scantuple = old_slot;<br/></li>
<li>&nbsp; &nbsp; old_matched = <a href="#L824" title="replication/pgoutput/pgoutput.c:824">pgoutput_row_filter_exec_expr</a>(filter_exprstate, ecxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tmp_new_slot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1639" title="executor/execTuples.c:1639">ExecStoreVirtualTuple</a>(tmp_new_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ecxt-&gt;ecxt_scantuple = tmp_new_slot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ecxt-&gt;ecxt_scantuple = new_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_matched = <a href="#L824" title="replication/pgoutput/pgoutput.c:824">pgoutput_row_filter_exec_expr</a>(filter_exprstate, ecxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Case 1: if both tuples don't match the row filter, bailout. Send<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!old_matched &amp;&amp; !new_matched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Case 2: if the old tuple doesn't satisfy the row filter but the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple does, transform the UPDATE into INSERT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the newly transformed tuple that must contain the column <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all the replica identity columns. This is required to ensure that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while inserting the tuple in the downstream node, we have all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required column <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!old_matched &amp;&amp; new_matched)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *action = REORDER_BUFFER_CHANGE_INSERT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmp_new_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *new_slot_ptr = tmp_new_slot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Case 3: if the old tuple satisfies the row filter but the new tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't, transform the UPDATE into DELETE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This transformation does not require another tuple. The Old tuple will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be used for DELETE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (old_matched &amp;&amp; !new_matched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *action = REORDER_BUFFER_CHANGE_DELETE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Case 4: if both tuples match the row filter, transformation isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required. (*action is default UPDATE).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sends the decoded DML over wire.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called both in streaming and non-streaming modes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1403">&#x200c;</a></span><span class="linkable">pgoutput_change</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation, ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; <a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *txndata = (<a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *) txn-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *relentry;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; ancestor = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; targetrel = relation;<br/></li>
<li>&nbsp; &nbsp; ReorderBufferChangeType action = change-&gt;action;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *old_slot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *new_slot = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/pg_publication.c.html#L150" title="catalog/pg_publication.c:150">is_publishable_relation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the xid for the change in streaming mode. We need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with each change in the streaming mode so that subscriber can make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their association and on aborts, it can discard the corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;in_streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = change-&gt;txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relentry = <a href="#L1963" title="replication/pgoutput/pgoutput.c:1963">get_rel_sync_entry</a>(data, relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First check the table filter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!relentry-&gt;pubactions.pubinsert)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!relentry-&gt;pubactions.pubupdate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!relentry-&gt;pubactions.pubdelete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is only possible if deletes are allowed even when replica<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * identity is not defined for a table. Since the DELETE action<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't be published, we simply return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!change-&gt;data.tp.oldtuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;didn't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> DELETE change because of missing oldtuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory by using and resetting our own context */<br/></li>
<li></span>&nbsp; &nbsp; old = MemoryContextSwitchTo(data-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch relation if publishing via root. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relentry-&gt;publish_as_relid != RelationGetRelid(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(relation-&gt;rd_rel-&gt;relispartition);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ancestor = <a href="../../utils/cache/relcache.c.html#L2062" title="utils/cache/relcache.c:2062">RelationIdGetRelation</a>(relentry-&gt;publish_as_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetrel = ancestor;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.tp.oldtuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_slot = relentry-&gt;old_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(change-&gt;data.tp.oldtuple, old_slot, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert tuple if needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relentry-&gt;attrmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot = <a href="../../executor/execTuples.c.html#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(RelationGetDescr(targetrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_slot = <a href="../../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(relentry-&gt;attrmap, old_slot, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (change-&gt;data.tp.newtuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_slot = relentry-&gt;new_slot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(change-&gt;data.tp.newtuple, new_slot, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert tuple if needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relentry-&gt;attrmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot = <a href="../../executor/execTuples.c.html#L1199" title="executor/execTuples.c:1199">MakeTupleTableSlot</a>(RelationGetDescr(targetrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../../executor/execTuples.c.html#L84" title="executor/execTuples.c:84">TTSOpsVirtual</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_slot = <a href="../../access/common/tupconvert.c.html#L192" title="access/common/tupconvert.c:192">execute_attr_map_slot</a>(relentry-&gt;attrmap, new_slot, slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check row filter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Updates could be transformed to inserts or deletes based on the results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the row filter for old and new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1222" title="replication/pgoutput/pgoutput.c:1222">pgoutput_row_filter</a>(targetrel, old_slot, &amp;new_slot, relentry, &amp;action))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send BEGIN if we haven't yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the BEGIN message after ensuring that we will actually <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change. This avoids sending a pair of BEGIN/COMMIT messages for empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (txndata &amp;&amp; !txndata-&gt;sent_begin_txn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L562" title="replication/pgoutput/pgoutput.c:562">pgoutput_send_begin</a>(ctx, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Schema should be sent using the original relation because it also sends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ancestor's relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L679" title="replication/pgoutput/pgoutput.c:679">maybe_send_schema</a>(ctx, change, relation, relentry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send the data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/proto.c.html#L414" title="replication/logical/proto.c:414">logicalrep_write_insert</a>(ctx-&gt;out, xid, targetrel, new_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;binary, relentry-&gt;columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/proto.c.html#L458" title="replication/logical/proto.c:458">logicalrep_write_update</a>(ctx-&gt;out, xid, targetrel, old_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_slot, data-&gt;binary, relentry-&gt;columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REORDER_BUFFER_CHANGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/proto.c.html#L533" title="replication/logical/proto.c:533">logicalrep_write_delete</a>(ctx-&gt;out, xid, targetrel, old_slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;binary, relentry-&gt;columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li><span class="Statement"><a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a></span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationIsValid(ancestor))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(ancestor);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ancestor = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(data-&gt;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1562">&#x200c;</a></span><span class="linkable">pgoutput_truncate</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nrelations, Relation relations[], ReorderBufferChange *change)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; <a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *txndata = (<a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *) txn-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *relentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrelids;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *relids;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember the xid for the change in streaming mode. See <a href="#L1403" title="replication/pgoutput/pgoutput.c:1403">pgoutput_change</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;in_streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = change-&gt;txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old = MemoryContextSwitchTo(data-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relids = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(nrelations * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; nrelids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nrelations; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; relation = relations[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/pg_publication.c.html#L150" title="catalog/pg_publication.c:150">is_publishable_relation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relentry = <a href="#L1963" title="replication/pgoutput/pgoutput.c:1963">get_rel_sync_entry</a>(data, relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!relentry-&gt;pubactions.pubtruncate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> partitions if the publication wants to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root tables through it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relispartition &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relentry-&gt;publish_as_relid != relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relids[nrelids++] = relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send BEGIN if we haven't yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txndata &amp;&amp; !txndata-&gt;sent_begin_txn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L562" title="replication/pgoutput/pgoutput.c:562">pgoutput_send_begin</a>(ctx, txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L679" title="replication/pgoutput/pgoutput.c:679">maybe_send_schema</a>(ctx, change, relation, relentry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrelids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/proto.c.html#L586" title="replication/logical/proto.c:586">logicalrep_write_truncate</a>(ctx-&gt;out,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrelids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.truncate.cascade,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; change-&gt;data.truncate.restart_seqs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(data-&gt;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1630">&#x200c;</a></span><span class="linkable">pgoutput_message</span>(LogicalDecodingContext *ctx, ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr message_lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> transactional, <span class="Type">const</span> <span class="Type">char</span> *prefix, Size sz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *message)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!data-&gt;messages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the xid for the message in streaming mode. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1403" title="replication/pgoutput/pgoutput.c:1403">pgoutput_change</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;in_streaming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = txn-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Output BEGIN if we haven't yet. Avoid for non-transactional messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (transactional)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *txndata = (<a href="#L204" title="replication/pgoutput/pgoutput.c:204">PGOutputTxnData</a> *) txn-&gt;output_plugin_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send BEGIN if we haven't yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (txndata &amp;&amp; !txndata-&gt;sent_begin_txn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L562" title="replication/pgoutput/pgoutput.c:562">pgoutput_send_begin</a>(ctx, txn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L643" title="replication/logical/proto.c:643">logicalrep_write_message</a>(ctx-&gt;out,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; message_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; transactional,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; message);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true if the data is associated with an origin and the user has<br/></li>
<li></span><span class="Comment"> * requested the changes that don't have an origin, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1675">&#x200c;</a></span><span class="linkable">pgoutput_origin_filter</span>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RepOriginId origin_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;publish_no_origin &amp;&amp; origin_id != InvalidRepOriginId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> the output plugin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note, we don't need to clean the data-&gt;context and data-&gt;cachectx as<br/></li>
<li></span><span class="Comment"> * they are child contexts of the ctx-&gt;context so they will be cleaned up by<br/></li>
<li></span><span class="Comment"> * logical decoding machinery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1694">&#x200c;</a></span><span class="linkable">pgoutput_shutdown</span>(LogicalDecodingContext *ctx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load publications from the list of publication names.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1707">&#x200c;</a><span class="linkable">LoadPublications</span>(List *pubnames)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, pubnames)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pubname = (<span class="Type">char</span> *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Publication *pub = <a href="../../catalog/pg_publication.c.html#L1037" title="catalog/pg_publication.c:1037">GetPublicationByName</a>(pubname, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, pub);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Publication syscache invalidation callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called for invalidations on pg_publication.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1729">&#x200c;</a></span><span class="linkable">publication_invalidation_cb</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L82" title="replication/pgoutput/pgoutput.c:82">publications_valid</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also invalidate per-relation cache so that <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time the filtering info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is checked it will be updated with the new publication settings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2318" title="replication/pgoutput/pgoutput.c:2318">rel_sync_cache_publication_cb</a>(arg, cacheid, hashvalue);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * START STREAM callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1744">&#x200c;</a></span><span class="linkable">pgoutput_stream_start</span>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; send_replication_origin = txn-&gt;origin_id != InvalidRepOriginId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we can't nest streaming of transactions */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!data-&gt;in_streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we already sent the first stream for this transaction then don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the origin id in the subsequent streams.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rbtxn_is_streamed(txn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; send_replication_origin = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, !send_replication_origin);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L1069" title="replication/logical/proto.c:1069">logicalrep_write_stream_start</a>(ctx-&gt;out, txn-&gt;xid, !rbtxn_is_streamed(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2344" title="replication/pgoutput/pgoutput.c:2344">send_repl_origin</a>(ctx, txn-&gt;origin_id, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; send_replication_origin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we're streaming a chunk of transaction <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; data-&gt;in_streaming = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * STOP STREAM callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1776">&#x200c;</a></span><span class="linkable">pgoutput_stream_stop</span>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we should be streaming a transaction */<br/></li>
<li></span>&nbsp; &nbsp; Assert(data-&gt;in_streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L1103" title="replication/logical/proto.c:1103">logicalrep_write_stream_stop</a>(ctx-&gt;out);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we've stopped streaming a transaction */<br/></li>
<li></span>&nbsp; &nbsp; data-&gt;in_streaming = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Notify downstream to discard the streamed transaction (along with all<br/></li>
<li></span><span class="Comment"> * it's subtransactions, if it's a toplevel transaction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1797">&#x200c;</a></span><span class="linkable">pgoutput_stream_abort</span>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr abort_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReorderBufferTXN *toptxn;<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; write_abort_info = (data-&gt;streaming == LOGICALREP_STREAM_PARALLEL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The abort should happen outside streaming block, even for streamed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions. The transaction has to be marked as streamed, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!data-&gt;in_streaming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* determine the toplevel transaction */<br/></li>
<li></span>&nbsp; &nbsp; toptxn = rbtxn_get_toptxn(txn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rbtxn_is_streamed(toptxn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L1166" title="replication/logical/proto.c:1166">logicalrep_write_stream_abort</a>(ctx-&gt;out, toptxn-&gt;xid, txn-&gt;xid, abort_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; txn-&gt;xact_time.abort_time, write_abort_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2232" title="replication/pgoutput/pgoutput.c:2232">cleanup_rel_sync_cache</a>(toptxn-&gt;xid, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Notify downstream to apply the streamed transaction (along with all<br/></li>
<li></span><span class="Comment"> * it's subtransactions).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1830">&#x200c;</a></span><span class="linkable">pgoutput_stream_commit</span>(<span class="Type">struct</span> LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr commit_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGOutputData *data <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = (PGOutputData *) ctx-&gt;output_plugin_private;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The commit should happen outside streaming block, even for streamed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions. The transaction has to be marked as streamed, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!data-&gt;in_streaming);<br/></li>
<li>&nbsp; &nbsp; Assert(rbtxn_is_streamed(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L734" title="replication/logical/logical.c:734">OutputPluginUpdateProgress</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L1112" title="replication/logical/proto.c:1112">logicalrep_write_stream_commit</a>(ctx-&gt;out, txn, commit_lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2232" title="replication/pgoutput/pgoutput.c:2232">cleanup_rel_sync_cache</a>(txn-&gt;xid, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * PREPARE callback (for streaming two-phase commit).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notify the downstream to prepare the transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1858">&#x200c;</a></span><span class="linkable">pgoutput_stream_prepare_txn</span>(LogicalDecodingContext *ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReorderBufferTXN *txn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr prepare_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(rbtxn_is_streamed(txn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L734" title="replication/logical/logical.c:734">OutputPluginUpdateProgress</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/proto.c.html#L364" title="replication/logical/proto.c:364">logicalrep_write_stream_prepare</a>(ctx-&gt;out, txn, prepare_lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the relation schema sync cache for a decoding session.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table is destroyed at the end of a decoding session. While<br/></li>
<li></span><span class="Comment"> * relcache invalidations still exist and will still be invoked, they<br/></li>
<li></span><span class="Comment"> * will just see the null <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table global and take no action.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1878">&#x200c;</a></span><span class="linkable">init_rel_sync_cache</span>(MemoryContext cachectx)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> relation_callbacks_registered = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table already exists */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for the cache */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = cachectx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;logical replication output relation cache&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">128</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_CONTEXT | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No more to do if we already registered callbacks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation_callbacks_registered)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must update the cache entry for a relation after a relcache flush */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1558" title="utils/cache/inval.c:1558">CacheRegisterRelcacheCallback</a>(<a href="#L2267" title="replication/pgoutput/pgoutput.c:2267">rel_sync_cache_relation_cb</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flush all cache entries after a pg_namespace change, in case it was a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * schema rename affecting a relation being replicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(NAMESPACEOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2318" title="replication/pgoutput/pgoutput.c:2318">rel_sync_cache_publication_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flush all cache entries after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> publication changes.&nbsp; (We need no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callback entry for pg_publication, because <a href="#L1729" title="replication/pgoutput/pgoutput.c:1729">publication_invalidation_cb</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will take care of it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(PUBLICATIONRELMAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2318" title="replication/pgoutput/pgoutput.c:2318">rel_sync_cache_publication_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(PUBLICATIONNAMESPACEMAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2318" title="replication/pgoutput/pgoutput.c:2318">rel_sync_cache_publication_cb</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation_callbacks_registered = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We expect relatively small number of streamed transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1932">&#x200c;</a></span><span class="linkable">get_schema_sent_in_streamed_txn</span>(<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/list.c.html#L742" title="nodes/list.c:742">list_member_xid</a>(entry-&gt;streamed_txns, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add the xid in the rel sync entry for which we have already sent the schema<br/></li>
<li></span><span class="Comment"> * of the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1942">&#x200c;</a></span><span class="linkable">set_schema_sent_in_streamed_txn</span>(<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;streamed_txns = <a href="../../nodes/list.c.html#L393" title="nodes/list.c:393">lappend_xid</a>(entry-&gt;streamed_txns, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find or create entry in the relation schema cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This looks up publications that the given relation is directly or<br/></li>
<li></span><span class="Comment"> * indirectly part of (the latter if it's really the relation's ancestor that<br/></li>
<li></span><span class="Comment"> * is part of a publication) and fills up the found entry with the information<br/></li>
<li></span><span class="Comment"> * about which operations to publish and whether to use an ancestor's schema<br/></li>
<li></span><span class="Comment"> * when publishing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *<br/></li>
<li><a id="L1963">&#x200c;</a><span class="linkable">get_rel_sync_entry</span>(PGOutputData *data, Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find cached relation info, creating if not found */<br/></li>
<li></span>&nbsp; &nbsp; entry = (<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(entry != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> entry, if it's new */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;replicate_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;schema_sent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;streamed_txns = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubinsert = entry-&gt;pubactions.pubupdate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubdelete = entry-&gt;pubactions.pubtruncate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;new_slot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;old_slot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(entry-&gt;exprstate, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(entry-&gt;exprstate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;entry_cxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;publish_as_relid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;columns = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate the entry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;replicate_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; schemaId = <a href="../../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pubids = <a href="../../catalog/pg_publication.c.html#L687" title="catalog/pg_publication.c:687">GetRelationPublications</a>(relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't acquire a lock on the namespace system table as we build<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cache entry using a historic snapshot and all the later changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are absorbed while decoding WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *schemaPubids = <a href="../../catalog/pg_publication.c.html#L899" title="catalog/pg_publication.c:899">GetSchemaPublications</a>(schemaId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publish_as_relid = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publish_ancestor_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; am_partition = <a href="../../utils/cache/lsyscache.c.html#L2027" title="utils/cache/lsyscache.c:2027">get_rel_relispartition</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind = <a href="../../utils/cache/lsyscache.c.html#L2003" title="utils/cache/lsyscache.c:2003">get_rel_relkind</a>(relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rel_publications = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reload publications if needed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> use. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L82" title="replication/pgoutput/pgoutput.c:82">publications_valid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L152" title="utils/mmgr/mcxt.c:152">CacheMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;publications)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(data-&gt;publications);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;publications = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;publications = <a href="#L1707" title="replication/pgoutput/pgoutput.c:1707">LoadPublications</a>(data-&gt;publication_names);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="replication/pgoutput/pgoutput.c:82">publications_valid</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset schema_sent status as the relation definition may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed.&nbsp; Also reset pubactions to empty in case rel was dropped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from a publication.&nbsp; Also free <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> objects that depended on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier definition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;schema_sent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(entry-&gt;streamed_txns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;streamed_txns = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(entry-&gt;columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;columns = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubinsert = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubupdate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubdelete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubtruncate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple slots cleanups. (Will be rebuilt later if needed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;old_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(entry-&gt;old_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;new_slot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(entry-&gt;new_slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;old_slot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;new_slot = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;attrmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/attmap.c.html#L56" title="access/common/attmap.c:56">free_attrmap</a>(entry-&gt;attrmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attrmap = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Row filter cache cleanups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;entry_cxt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(entry-&gt;entry_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;entry_cxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;estate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(entry-&gt;exprstate, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(entry-&gt;exprstate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build publication cache. We can't use one provided by relcache as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relcache considers all publications that the given relation is in,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but here we only need to consider ones that the subscriber<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, data-&gt;publications)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Publication *pub = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; publish = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Under what relid should we publish changes in this publication?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll use the top-most relid across all publications. Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * track the ancestor level for this publication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pub_relid = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor_level = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a FOR ALL TABLES publication, pick the partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root and set the ancestor level accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pub-&gt;alltables)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publish = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pub-&gt;pubviaroot &amp;&amp; am_partition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ancestors = <a href="../../catalog/partition.c.html#L134" title="catalog/partition.c:134">get_partition_ancestors</a>(relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pub_relid = llast_oid(ancestors);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor_level = list_length(ancestors);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!publish)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ancestor_published = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a partition, check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the ancestors are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * published.&nbsp; If so, note down the topmost ancestor that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * published via this publication, which will be used as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation via which to publish the partition's changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (am_partition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ancestors = <a href="../../catalog/partition.c.html#L134" title="catalog/partition.c:134">get_partition_ancestors</a>(relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor = <a href="../../catalog/pg_publication.c.html#L311" title="catalog/pg_publication.c:311">GetTopMostAncestorInPublication</a>(pub-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ancestors,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ancestor != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor_published = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pub-&gt;pubviaroot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pub_relid = ancestor;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor_level = level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(pubids, pub-&gt;oid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(schemaPubids, pub-&gt;oid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ancestor_published)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publish = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the relation is to be published, determine actions to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * publish, and list of columns, if appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't publish changes for partitioned tables, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * publishing those of its partitions suffices, unless partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changes won't be published due to pubviaroot being set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (publish &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (relkind != RELKIND_PARTITIONED_TABLE || pub-&gt;pubviaroot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubinsert |= pub-&gt;pubactions.pubinsert;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubupdate |= pub-&gt;pubactions.pubupdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubdelete |= pub-&gt;pubactions.pubdelete;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubtruncate |= pub-&gt;pubactions.pubtruncate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to publish the changes as the top-most ancestor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * across all publications. So we need to check if the already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calculated level is higher than the new one. If yes, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignore the new value (as it's a child). Otherwise the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value is an ancestor, so we keep it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (publish_ancestor_level &gt; ancestor_level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found an ancestor higher up in the tree, discard the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list of publications through which we replicate it, and use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new ancestor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (publish_ancestor_level &lt; ancestor_level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publish_as_relid = pub_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; publish_ancestor_level = ancestor_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset the publication list for this relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel_publications = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same ancestor level, has to be the same OID. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(publish_as_relid == pub_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Track publications for this ancestor. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel_publications = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rel_publications, pub);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;publish_as_relid = publish_as_relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize the tuple slot, map, and row filter. These are only used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when publishing inserts, updates, or deletes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;pubactions.pubinsert || entry-&gt;pubactions.pubupdate ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;pubactions.pubdelete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize the tuple slot and map */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1130" title="replication/pgoutput/pgoutput.c:1130">init_tuple_slot</a>(data, relation, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize the row filter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L869" title="replication/pgoutput/pgoutput.c:869">pgoutput_row_filter_init</a>(data, rel_publications, entry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize the column list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1015" title="replication/pgoutput/pgoutput.c:1015">pgoutput_column_list_init</a>(data, rel_publications, entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(pubids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(schemaPubids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(rel_publications);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;replicate_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup list of streamed transactions and update the schema_sent flag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a streamed transaction commits or aborts, we need to remove the<br/></li>
<li></span><span class="Comment"> * toplevel XID from the schema cache. If the transaction aborted, the<br/></li>
<li></span><span class="Comment"> * subscriber will simply throw away the schema <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> we streamed, so<br/></li>
<li></span><span class="Comment"> * we don't need to do anything else.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the transaction is committed, the subscriber will update the relation<br/></li>
<li></span><span class="Comment"> * cache - so tweak the schema_sent flag accordingly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2232">&#x200c;</a></span><span class="linkable">cleanup_rel_sync_cache</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_commit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS hash_seq;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;hash_seq, <a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;hash_seq)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can set the schema_sent flag for an entry that has committed xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the list as that ensures that the subscriber would have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding schema and we don't need to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it unless there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalidation for that relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach_xid(streamed_txn, entry-&gt;streamed_txns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xid == streamed_txn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_commit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;schema_sent = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;streamed_txns =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_delete_current(entry-&gt;streamed_txns, streamed_txn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Relcache invalidation callback<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2267">&#x200c;</a></span><span class="linkable">rel_sync_cache_relation_cb</span>(Datum arg, Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can get here if the plugin was used in SQL interface as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> is destroyed when the decoding finishes, but there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no way to unregister the relcache invalidation callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nobody keeps pointers to entries in this <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table around outside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logical decoding callback calls - but invalidation events can come in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *during* a callback if we do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> syscache access in the callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because of that we must mark the cache entry as invalid but not damage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its substructure here.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L1963" title="replication/pgoutput/pgoutput.c:1963">get_rel_sync_entry</a>() call will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rebuild it all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(relid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Getting invalidations for relations that aren't in the table is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely normal.&nbsp; So we don't care if it's found or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = (<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a>, &amp;relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;replicate_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Whole cache must be flushed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((entry = (<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;replicate_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Publication relation/schema map syscache invalidation callback<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called for invalidations on pg_publication, pg_publication_rel,<br/></li>
<li></span><span class="Comment"> * pg_publication_namespace, and pg_namespace.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2318">&#x200c;</a></span><span class="linkable">rel_sync_cache_publication_cb</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can get here if the plugin was used in SQL interface as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> is destroyed when the decoding finishes, but there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no way to unregister the invalidation callbacks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have no easy way to identify which cache entries this invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * event might have affected, so just mark them all invalid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L210" title="replication/pgoutput/pgoutput.c:210">RelationSyncCache</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((entry = (<a href="#L125" title="replication/pgoutput/pgoutput.c:125">RelationSyncEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;replicate_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Send Replication origin */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2344">&#x200c;</a></span><span class="linkable">send_repl_origin</span>(LogicalDecodingContext *ctx, RepOriginId origin_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr origin_lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> send_origin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (send_origin)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *origin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: which behaviour do we want here?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Alternatives:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; - don't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> origin message if origin name not found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; (that's what we do <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; - throw error - that will break replication, not good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; - <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> some special &quot;unknown&quot; origin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../logical/origin.c.html#L465" title="replication/logical/origin.c:465">replorigin_by_oid</a>(origin_id, <span class="Constant">true</span>, &amp;origin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Message boundary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/logical.c.html#L721" title="replication/logical/logical.c:721">OutputPluginWrite</a>(ctx, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/logical.c.html#L708" title="replication/logical/logical.c:708">OutputPluginPrepareWrite</a>(ctx, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../logical/proto.c.html#L385" title="replication/logical/proto.c:385">logicalrep_write_origin</a>(ctx-&gt;out, origin, origin_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
